/*   Translated to FB using         HeadToHead       by Bernie Wylde         ----------        5 January 2009*//* CoreGraphics - CGContext.h * Copyright (c) 2000-2006 Apple Computer, Inc. * All rights reserved.*/#if ndef _DEFINEDINCARBON#if ndef _kHIViewAttributeSendCommandToUserFocus#define CGContextRef as pointer#endif#endifinclude "CoreGraphics:CGPath.incl"include "CoreGraphics:CGGradient.incl"include "CoreGraphics:CGShading.incl"include "CoreGraphics:CGFont.incl"include "CoreGraphics:CGPDFPage.incl"include "CoreGraphics:CGPDFDocument.incl"include "CoreGraphics:CGColor.incl"#if ndef _DEFINEDINCARBON/* Line join styles. */begin enum not output_kCGLineJoinMiter_kCGLineJoinRound_kCGLineJoinBevelend enum#define CGLineJoin as UInt32/* Line cap styles. */begin enum not output_kCGLineCapButt_kCGLineCapRound_kCGLineCapSquareend enum#define CGLineCap as UInt32/* Drawing modes for paths. */begin enum not output // CGPathDrawingMode_kCGPathFill_kCGPathEOFill_kCGPathStroke_kCGPathFillStroke_kCGPathEOFillStrokeend enum#define CGPathDrawingMode as UInt32/* Drawing modes for text. */begin enum not output_kCGTextFill_kCGTextStroke_kCGTextFillStroke_kCGTextInvisible_kCGTextFillClip_kCGTextStrokeClip_kCGTextFillStrokeClip_kCGTextClipend enum#define CGTextDrawingMode as UInt32/* Text encodings. */begin enum not output_kCGEncodingFontSpecific_kCGEncodingMacRomanend enum#define CGTextEncoding as UInt32/* Interpolation quality. */begin enum not output_kCGInterpolationDefault/* Let the context decide. */_kCGInterpolationNone/* Never interpolate. */_kCGInterpolationLow/* Faster  lower quality. */_kCGInterpolationHigh/* Slower  higher quality. */end enum#define CGInterpolationQuality as UInt32/* Blend modes. * * The blend modes from kCGBlendModeNormal to kCGBlendModeLuminosity are * supported in Mac OS X 10.4 and later. The Porter-Duff blend modes (from * kCGBlendModeClear to kCGBlendModePlusLighter) are supported in Mac OS X * 10.5 and later. The names of the Porter-Duff blend modes are historical. * * Note that the Porter-Duff blend modes are not necessarily supported in * every context. In particular, they are only guaranteed to work in * bitmap-based contexts, such as those created by CGBitmapContextCreate. * It is your responsibility to make sure that they do what you want when* you use them in a CGContext. */begin enum not output/* Available in Mac OS X 10.4 & later. */_kCGBlendModeNormal_kCGBlendModeMultiply_kCGBlendModeScreen_kCGBlendModeOverlay_kCGBlendModeDarken_kCGBlendModeLighten_kCGBlendModeColorDodge_kCGBlendModeColorBurn_kCGBlendModeSoftLight_kCGBlendModeHardLight_kCGBlendModeDifference_kCGBlendModeExclusion_kCGBlendModeHue_kCGBlendModeSaturation_kCGBlendModeColor_kCGBlendModeLuminosity                             /* Available in Mac OS X 10.5 & later. R, S, and D are, respectively,* premultiplied result, source, and destination colors with alpha; Ra,* Sa, and Da are the alpha components of these colors.** The Porter-Duff "source over" mode is called `kCGBlendModeNormal':* R = _S + D*(1 - Sa)** Note that the Porter-Duff "XOR" mode is only titularly related to* the classical bitmap XOR operation (which is unsupported by* CoreGraphics). */_kCGBlendModeClear/* R = 0 */_kCGBlendModeCopy/* R = S */_kCGBlendModeSourceIn/* R = S*Da */_kCGBlendModeSourceOut/* R = S*(1 - Da) */_kCGBlendModeSourceAtop/* R = S*Da + D*(1 - Sa) */_kCGBlendModeDestinationOver/* R = S*(1 - Da) + D */_kCGBlendModeDestinationIn/* R = D*Sa */_kCGBlendModeDestinationOut/* R = D*(1 - Sa) */_kCGBlendModeDestinationAtop/* R = S*(1 - Da) + D*Sa */_kCGBlendModeXOR/* R = S*(1 - Da) + D*(1 - Sa) */_kCGBlendModePlusDarker/* R = MAX(0  (1 - D) + (1 - S)) */_kCGBlendModePlusLighter/* R = MIN(1  S + D) */end enum#define CGBlendMode as UInt32/* Available in Mac OS X 10.4 & later. *//* Return the CFTypeID for CGContextRefs. */toolbox fn CGContextGetTypeID = CFTypeID// AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/** Graphics state functions. **//* Push a copy of the current graphics state onto the graphics state stack. * Note that the path is not considered part of the gstate, and is not* saved. */toolbox CGContextSaveGState( CGContextRef c )/* Restore the current graphics state from the one on the top of the * graphics state stack, popping the graphics state stack in the* process. */toolbox CGContextRestoreGState( CGContextRef c )/** Coordinate space transformations. **//* Scale the current graphics state's transformation matrix (the CTM) by* `(sx, sy)'. */toolbox CGContextScaleCTM( CGContextRef c, CGFloat sx, CGFloat sy )/* Translate the current graphics state's transformation matrix (the CTM)* by `(tx, ty)'. */toolbox CGContextTranslateCTM( CGContextRef c, CGFloat tx, CGFloat ty )/* Rotate the current graphics state's transformation matrix (the CTM) by* `angle' radians. */toolbox CGContextRotateCTM( CGContextRef c, CGFloat angle )/* Concatenate the current graphics state's transformation matrix (the CTM)* with the affine transform `transform'. */toolbox CGContextConcatCTM( CGContextRef, CGAffineTransform )/* Return the current graphics state's transformation matrix. */toolbox fn CGContextGetCTM( CGContextRef c ) = CGAffineTransform/** Drawing attribute functions. **//* Set the line width in the current graphics state to `width'. */toolbox CGContextSetLineWidth( CGContextRef c, CGFloat width )/* Set the line cap in the current graphics state to `cap'. */toolbox CGContextSetLineCap( CGContextRef c, CGLineCap cap )/* Set the line join in the current graphics state to `join'. */toolbox CGContextSetLineJoin( CGContextRef c, CGLineJoin join )/* Set the miter limit in the current graphics state to `limit'. */toolbox CGContextSetMiterLimit( CGContextRef c, CGFloat limit )/* Set the line dash patttern in the current graphics state of `c'. */toolbox CGContextSetLineDash( CGContextRef c, CGFloat phase, const CGFloat *lengths, UInt32 count )/* Set the path flatness parameter in the current graphics state of `c' to* `flatness'. */toolbox CGContextSetFlatness( CGContextRef c, CGFloat flatness )/* Set the alpha value in the current graphics state of `c' to `alpha'. */toolbox CGContextSetAlpha( CGContextRef c, CGFloat alpha )/* Set the blend mode of `context' to `mode'. */toolbox CGContextSetBlendMode( CGContextRef context, CGBlendMode mode ) // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/** Path construction functions. **//* Note that a context has a single path in use at any time: a path is not* part of the graphics state. *//* Begin a new path. The old path is discarded. */toolbox CGContextBeginPath( CGContextRef c )/* Start a new subpath at point `(x, y)' in the context's path. */toolbox CGContextMoveToPoint( CGContextRef c, CGFloat x, CGFloat y )/* Append a straight line segment from the current point to `(x, y)'. */toolbox CGContextAddLineToPoint( CGContextRef c, CGFloat x, CGFloat y )/* Append a cubic Bezier curve from the current point to `(x,y)', with* control points `(cp1x, cp1y)' and `(cp2x, cp2y)'. */toolbox CGContextAddCurveToPoint( CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y )/* Append a quadratic curve from the current point to `(x, y)', with* control point `(cpx, cpy)'. */toolbox CGContextAddQuadCurveToPoint( CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y )/* Close the current subpath of the context's path. */toolbox CGContextClosePath( CGContextRef c )/** Path construction convenience functions. **//* Add a single rect to the context's path. */toolbox CGContextAddRect( CGContextRef, CGRect )/* Add a set of rects to the context's path. */toolbox CGContextAddRects( CGContextRef c, const CGRect * rects, UInt32 count )/* Add a set of lines to the context's path. */toolbox CGContextAddLines( CGContextRef c, CGPoint *points, UInt32 count )/* Add an ellipse inside `rect' to the current path of `context'. See the * function `CGPathAddEllipseInRect' for more information on how the path* for the ellipse is constructed. */toolbox CGContextAddEllipseInRect( CGContextRef context, CGRect rect ) // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Add an arc of a circle to the context's path, possibly preceded by a * straight line segment. `(x, y)' is the center of the arc; `radius' is * its radius; `startAngle' is the angle to the first endpoint of the arc; * `endAngle' is the angle to the second endpoint of the arc; and * `clockwise' is 1 if the arc is to be drawn clockwise, 0 otherwise.* `startAngle' and `endAngle' are measured in radians. */toolbox CGContextAddArc( CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, long clockwise )/* Add an arc of a circle to the context's path, possibly preceded by a * straight line segment. `radius' is the radius of the arc. The arc is * tangent to the line from the current point to `(x1, y1)', and the line* from `(x1, y1)' to `(x2, y2)'. */toolbox CGContextAddArcToPoint( CGContextRef c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius )/* Add `path' to the path of context. The points in `path' are transformed* by the CTM of context before they are added. */toolbox CGContextAddPath( CGContextRef context, CGPathRef path ) // AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/** Path stroking. **//* Replace the path in `context' with the stroked version of the path, * using the parameters of `context' to calculate the stroked path. The * resulting path is created such that filling it with the appropriate * color will produce the same results as stroking the original path. You * can use this path in the same way you can use the path of any context; * for example, you can clip to the stroked version of a path by calling* this function followed by a call to "CGContextClip". */toolbox CGContextReplacePathWithStrokedPath( CGContextRef c )// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/** Path information functions. **//* Return true if the context's path contains no elements, false* otherwise. */toolbox fn CGContextIsPathEmpty( CGContextRef c ) = Boolean/* Return the current point of the current subpath of the context's* path. */toolbox fn CGContextGetPathCurrentPoint( CGContextRef c ) = CGPoint/* Return the bounding box of the context's path. The bounding box is the * smallest rectangle completely enclosing all points in the path,* including control points for Bezier and quadratic curves. */toolbox fn CGContextGetPathBoundingBox( CGContextRef c ) = CGRect/* Return true if `point' is contained in the current path of `context'. A * point is contained within a context's path if it is inside the painted * region when the path is stroked or filled with opaque colors using the* path drawing mode `mode'. `point' is specified is user space. */toolbox fn CGContextPathContainsPoint( CGContextRef context, CGPoint point, CGPathDrawingMode mode ) = Boolean// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/** Path drawing functions. **//* Draw the context's path using drawing mode `mode'. */toolbox CGContextDrawPath( CGContextRef c, CGPathDrawingMode mode )/** Path drawing convenience functions. **//* Fill the context's path using the winding-number fill rule. Any open* subpath of the path is implicitly closed. */toolbox CGContextFillPath( CGContextRef c )/* Fill the context's path using the even-odd fill rule. Any open subpath* of the path is implicitly closed. */toolbox CGContextEOFillPath( CGContextRef c )/* Stroke the context's path. */toolbox CGContextStrokePath( CGContextRef c)/* Fill `rect' with the current fill color. */toolbox CGContextFillRect( CGContextRef c, CGRect rect )/* Fill `rects', an array of `count' CGRects, with the current fill* color. */toolbox CGContextFillRects( CGContextRef c, const CGRect *rects, UInt32 count )/* Stroke `rect' with the current stroke color and the current* linewidth. */toolbox CGContextStrokeRect( CGContextRef c, CGRect rect )/* Stroke `rect' with the current stroke color, using `width' as the the* line width. */toolbox CGContextStrokeRectWithWidth( CGContextRef c, CGRect rect, CGFloat width )/* Clear `rect' (that is, set the region within the rect to* transparent). */toolbox CGContextClearRect( CGContextRef c, CGRect rect )/* Fill an ellipse (an oval) inside `rect'. */toolbox CGContextFillEllipseInRect( CGContextRef context, CGRect rect ) // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Stroke an ellipse (an oval) inside `rect'. */toolbox CGContextStrokeEllipseInRect( CGContextRef context, CGRect rect ) // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Stroke a sequence of line segments one after another in `context'. The * line segments are specified by `points', an array of `count' CGPoints. * This function is equivalent to CGContextBeginPath(context); for (k = 0; * k < count; k += 2) { CGContextMoveToPoint(context, s[k].x, s[k].y); * CGContextAddLineToPoint(context, s[k+1].x, s[k+1].y); } * CGContextStrokePath(context);*/toolbox CGContextStrokeLineSegments( CGContextRef c, const CGPoint *points, UInt32 count )// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/** Clipping functions. **//* Intersect the context's path with the current clip path and use the * resulting path as the clip path for subsequent rendering operations. Use* the winding-number fill rule for deciding what's inside the path. */toolbox CGContextClip( CGContextRef c )/* Intersect the context's path with the current clip path and use the * resulting path as the clip path for subsequent rendering operations. Use* the even-odd fill rule for deciding what's inside the path. */toolbox CGContextEOClip( CGContextRef c )/* Add `mask' transformed to `rect' to the clipping area of `context'. The * mask, which may be either an image mask or an image, is mapped into the * specified rectangle and intersected with the current clipping area of * the context. * * If `mask' is an image mask, then it clips in a manner identical to the * behavior if it were used with "CGContextDrawImage": it indicates an area * to be masked out (left unchanged) when drawing. The source samples of * the image mask determine which points of the clipping area are changed, * acting as an "inverse alpha": if the value of a source sample in the * image mask is S, then the corresponding point in the current clipping * area will be multiplied by an alpha of (1-S). (For example, if S is 1, * then the point in the clipping area becomes clear, while if S is 0, the * point in the clipping area is unchanged. * * If `mask' is an image, then it serves as alpha mask and is blended with * the current clipping area. The source samples of mask determine which * points of the clipping area are changed: if the value of the source * sample in mask is S, then the corresponding point in the current * clipping area will be multiplied by an alpha of S. (For example, if S is * 0, then the point in the clipping area becomes clear, while if S is 1, * the point in the clipping area is unchanged. * * If `mask' is an image, then it must be in the DeviceGray color space, * may not have alpha, and may not be masked by an image mask or masking* color. */toolbox CGContextClipToMask( CGContextRef c, CGRect rect, CGImageRef mask ) // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Return the bounding box of the clip path of `c' in user space. The * bounding box is the smallest rectangle completely enclosing all points* in the clip. */toolbox fn CGContextGetClipBoundingBox( CGContextRef c ) = CGRect // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/** Clipping convenience functions. **//* Intersect the current clipping path with `rect'. Note that this function* resets the context's path to the empty path. */toolbox CGContextClipToRect( CGContextRef c, CGRect rect )/* Intersect the current clipping path with the clipping region formed by * creating a path consisting of all rects in `rects'. Note that this* function resets the context's path to the empty path. */toolbox CGContextClipToRects( CGContextRef c, const CGRect *rects, UInt32 count )/** Primitive color functions. **//* Set the current fill color in the context `c' to `color'. */toolbox CGContextSetFillColorWithColor( CGContextRef c, CGColorRef color ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/* Set the current stroke color in the context `c' to `color'. */toolbox CGContextSetStrokeColorWithColor( CGContextRef c, CGColorRef color ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/** Colorspace functions. **//* Set the current fill colorspace in the context `c' to `colorspace'. As a * side-effect, set the fill color to a default value appropriate for the* colorspace. */toolbox CGContextSetFillColorSpace( CGContextRef c, CGColorSpaceRef colorspace )/* Set the current stroke colorspace in the context `c' to `colorspace'. As * a side-effect, set the stroke color to a default value appropriate for* the colorspace. */toolbox CGContextSetStrokeColorSpace( CGContextRef c, CGColorSpaceRef colorspace  )/** Color functions. **//* Set the components of the current fill color in the context `c' to the * values specifed by `components'. The number of elements in `components' * must be one greater than the number of components in the current fill * colorspace (N color components + 1 alpha component). The current fill* colorspace must not be a pattern colorspace. */toolbox CGContextSetFillColor( CGContextRef c, const CGFloat *components )/* Set the components of the current stroke color in the context `c' to the * values specifed by `components'. The number of elements in `components' * must be one greater than the number of components in the current stroke * colorspace (N color components + 1 alpha component). The current stroke* colorspace must not be a pattern colorspace. */toolbox CGContextSetStrokeColor( CGContextRef c, const CGFloat *components )/** Pattern functions. **//* Set the components of the current fill color in the context `c' to the * values specifed by `components', and set the current fill pattern to * `pattern'. The number of elements in `components' must be one greater * than the number of components in the current fill colorspace (N color * components + 1 alpha component). The current fill colorspace must be a* pattern colorspace. */toolbox CGContextSetFillPattern( CGContextRef c, CGPatternRef pattern, float * components )/* Set the components of the current stroke color in the context `c' to the * values specifed by `components', and set the current stroke pattern to * `pattern'. The number of elements in `components' must be one greater * than the number of components in the current stroke colorspace (N color * components + 1 alpha component). The current stroke colorspace must be a* pattern colorspace. */toolbox CGContextSetStrokePattern( CGContextRef c, CGPatternRef pattern, float * components )/* Set the pattern phase in the current graphics state of the context `c'* to `phase'. */toolbox CGContextSetPatternPhase( CGContextRef c, CGSize phase )/** Color convenience functions. **//* Set the current fill colorspace in the context `c' to `DeviceGray' and* set the components of the current fill color to `(gray, alpha)'. */toolbox CGContextSetGrayFillColor( CGContextRef c, CGFloat gray, CGFloat alpha )/* Set the current stroke colorspace in the context `c' to `DeviceGray' and* set the components of the current stroke color to `(gray, alpha)'. */toolbox CGContextSetGrayStrokeColor( CGContextRef c, CGFloat gray, CGFloat alpha )/* Set the current fill colorspace in the context `c' to `DeviceRGB' and * set the components of the current fill color to `(red, green, blue,* alpha)'. */toolbox CGContextSetRGBFillColor( CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha )/* Set the current stroke colorspace in the context `c' to `DeviceRGB' and * set the components of the current stroke color to `(red, green, blue,* alpha)'. */toolbox CGContextSetRGBStrokeColor( CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha )/* Set the current fill colorspace in the context `c' to `DeviceCMYK' and * set the components of the current fill color to `(cyan, magenta, yellow,* black, alpha)'. */toolbox CGContextSetCMYKFillColor( CGContextRef c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha )/* Set the current stroke colorspace in the context `c' to `DeviceCMYK' and * set the components of the current stroke color to `(cyan, magenta,* yellow, black, alpha)'. */toolbox CGContextSetCMYKStrokeColor( CGContextRef c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha )/** Rendering intent. **//* Set the rendering intent in the current graphics state of context `c' to* `intent'. */toolbox CGContextSetRenderingIntent( CGContextRef c, CGColorRenderingIntent intent )/** Image functions. **//* Draw `image' in the rectangular area specified by `rect' in the context* `c'. The image is scaled, if necessary, to fit into `rect'. */toolbox CGContextDrawImage( CGContextRef c, CGRect rect, CGImageRef image )/* Draw `image' tiled in the context `c'. The image is scaled to the size * specified by `rect' in user space, positioned at the origin of `rect' in * user space, then replicated, stepping the width of `rect' horizontally * and the height of `rect' vertically, to fill the current clip region. * Unlike patterns, the image is tiled in user space, so transformations* applied to the CTM affect the final result. */toolbox CGContextDrawTiledImage( CGContextRef c, CGRect rect, CGImageRef image ) // AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Return the interpolation quality for image rendering of the context `c'. * The interpolation quality is a gstate parameter which controls the level * of interpolation performed when an image is interpolated (for example, * when scaling the image). Note that it is merely a hint to the context:* not all contexts support all interpolation quality levels. */toolbox fn CGContextGetInterpolationQuality( CGContextRef c ) = CGInterpolationQuality/* Set the interpolation quality of the context `c' to `quality'. */toolbox CGContextSetInterpolationQuality( CGContextRef c, CGInterpolationQuality quality )/** Shadow support. **//* Set the shadow parameters in `context'. `offset' specifies a translation * in base-space; `blur' is a non-negative number specifying the amount of * blur; `color' specifies the color of the shadow, which may contain a * non-opaque alpha value. If `color' is NULL, it's equivalent to * specifying a fully transparent color. The shadow is a gstate parameter. * After a shadow is specified, all objects drawn subsequently will be * shadowed. To turn off shadowing, set the shadow color to a fully * transparent color (or pass NULL as the color), or use the standard* gsave/grestore mechanism. */toolbox CGContextSetShadowWithColor( CGContextRef context, CGSize offset, CGFloat blur, CGColorRef color ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/* Equivalent to calling * CGContextSetShadowWithColor(context, offset, blur, color) * where color is black with 1/3 alpha (i.e., RGBA = {0, 0, 0, 1.0/3.0}) in* the DeviceRGB colorspace. */toolbox CGContextSetShadow( CGContextRef context, CGSize offset, CGFloat blur ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/** Gradient and shading functions. **//* Fill the current clipping region of `context' with a linear gradient * from `startPoint' to `endPoint'. The location 0 of `gradient' * corresponds to `startPoint'; the location 1 of `gradient' corresponds to * `endPoint'; colors are linearly interpolated between these two points * based on the values of the gradient's locations. The option flags * control whether the gradient is drawn before the start point or after* the end point. */toolbox CGContextDrawLinearGradient( CGContextRef context, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options )// AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Fill the current clipping region of `context' with a radial gradient * between two circles defined by the center point and radius of each * circle. The location 0 of `gradient' corresponds to a circle centered at * `startCenter' with radius `startRadius'; the location 1 of `gradient' * corresponds to a circle centered at `endCenter' with radius `endRadius'; * colors are linearly interpolated between these two circles based on the * values of the gradient's locations. The option flags control whether the* gradient is drawn before the start circle or after the end circle. */toolbox CGContextDrawRadialGradient( CGContextRef context, CGGradientRef gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options )// AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Fill the current clipping region of `context' with `shading'. */toolbox CGContextDrawShading( CGContextRef c, CGShadingRef shading ) // AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/** Text functions. **//* Set the current character spacing in the context `c' to `spacing'. The * character spacing is added to the displacement between the origin of one* character and the origin of the next. */toolbox CGContextSetCharacterSpacing( CGContextRef c, CGFloat spacing )/* Set the user-space point at which text will be drawn in the context `c'* to `(x, y)'. */toolbox CGContextSetTextPosition( CGContextRef c, CGFloat x, CGFloat y )/* Return the user-space point at which text will be drawn in the context* `c'. */toolbox fn CGContextGetTextPosition( CGContextRef c ) = CGPoint/* Set the text matrix in the context `c' to `t'. */toolbox CGContextSetTextMatrix( CGContextRef c, CGAffineTransform t )/* Return the text matrix in the context `c'. */toolbox fn CGContextGetTextMatrix( CGContextRef c ) = CGAffineTransform/* Set the text drawing mode in the current graphics state of the context* `c' to `mode'. */toolbox CGContextSetTextDrawingMode( CGContextRef c, CGTextDrawingMode mode )/* Set the font in the current graphics state of the context `c' to* `font'. */toolbox CGContextSetFont( CGContextRef c, CGFontRef font )/* Set the font size in the current graphics state of the context `c' to* `size'. */toolbox CGContextSetFontSize( CGContextRef c, CGFloat size )/* Attempts to find the font named `name' and, if successful, sets it as * the font in the current graphics state of `c' and sets the font size in * the current graphics state to `size'. `textEncoding' specifies how to* translate from bytes to glyphs when displaying text. */toolbox CGContextSelectFont( CGContextRef c, pointer name, CGFloat size, CGTextEncoding textEncoding )/* Draw `glyphs', an array of `count' CGGlyphs, at the points specified by * `positions'. Each element of `positions' specifies the position from the* associated glyph; the positions are specified in user space. */toolbox CGContextShowGlyphsAtPositions( CGContextRef context, const CGGlyph *glyphs, const CGPoint *positions, UInt32 count ) // AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/** Text convenience functions. **//* Draw `string', a string of `length' bytes, at the point specified by the * text matrix in the context `c'. Each byte of the string is mapped * through the encoding vector of the current font to obtain the glyph to* display. */toolbox CGContextShowText( CGContextRef c, pointer txtPtr, UInt32 length )/* Draw `string', a string of `length' bytes, at the point `(x, y)', * specified in user space, in the context `c'. Each byte of the string is * mapped through the encoding vector of the current font to obtain the* glyph to display. */toolbox CGContextShowTextAtPoint( CGContextRef c, CGFloat x, CGFloat y, pointer string, UInt32 length )/* Draw the glyphs pointed to by `g', an array of `count' glyphs, at the* point specified by the text matrix in the context `c'. */toolbox CGContextShowGlyphs( CGContextRef c, const CGGlyph *g, UInt32 count )/* Display the glyphs pointed to by `glyphs', an array of `count' glyphs, * at at the point `(x, y)', specified in user space, in the context* `c'. */toolbox CGContextShowGlyphsAtPoint( CGContextRef c, CGFloat x, CGFloat y, const CGGlyph *glyphs, UInt32 count )/* Draw `glyphs', an array of `count' CGGlyphs, at the current point * specified by the text matrix. Each element of `advances' specifies the * offset from the previous glyph's origin to the origin of the associated* glyph; the advances are specified in user space. */toolbox CGContextShowGlyphsWithAdvances( CGContextRef c, const CGGlyph *glyphs, const CGSize *advances, UInt32 count ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/** PDF functions. **//* Draw `page' in the current user space of the context `c'. */toolbox CGContextDrawPDFPage( CGContextRef c, CGPDFPageRef page ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/* DEPRECATED; use the CGPDFPage API instead. * * Draw `page' in `document' in the rectangular area specified by `rect' in * the context `c'. The media box of the page is scaled, if necessary, to* fit into `rect'. */toolbox CGContextDrawPDFDocument( CGContextRef c, CGRect rect, CGPDFDocumentRef document, long page )/** Output page functions. **//* Begin a new page. */toolbox CGContextBeginPage( CGContextRef c, const CGRect *mediaBox )/* End the current page. */toolbox CGContextEndPage( CGContextRef c )/** Context functions. **//* Equivalent to `CFRetain(c)'. */toolbox fn CGContextRetain( CGContextRef c ) = CGContextRef/* Equivalent to `CFRelease(c)'. */toolbox CGContextRelease( CGContextRef c )/* Flush all drawing to the destination. */toolbox CGContextFlush( CGContextRef c )/* Synchronized drawing. */toolbox CGContextSynchronize( CGContextRef c )/** Antialiasing functions. **//* Turn on antialiasing if `shouldAntialias' is true; turn it off* otherwise. This parameter is part of the graphics state. */toolbox CGContextSetShouldAntialias( CGContextRef c, Boolean shouldAntialias )/* Allow antialiasing in context `c' if `allowsAntialiasing' is true; don't * allow it otherwise. This parameter is not part of the graphics state. A * context will perform antialiasing if both `allowsAntialiasing' and the* graphics state parameter `shouldAntialias' are true. */toolbox CGContextSetAllowsAntialiasing( CGContextRef context, Boolean allowsAntialiasing ) // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/** Font smoothing functions. **//* Turn on font smoothing if `shouldSmoothFonts' is true; turn it off * otherwise. This parameter is part of the graphics state. Note that this * doesn't guarantee that font smoothing will occur: not all destination* contexts support font smoothing. */toolbox CGContextSetShouldSmoothFonts( CGContextRef c, Boolean shouldSmoothFonts ) // AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/** Transparency layer support. **//* Begin a transparency layer in `context'. All subsequent drawing * operations until a corresponding `CGContextEndTransparencyLayer' are * composited into a fully transparent backdrop (which is treated as a * separate destination buffer from the context). After the transparency * layer is ended, the result is composited into the context using the * global alpha and shadow state of the context. This operation respects * the clipping region of the context. After a call to this function, all * of the parameters in the graphics state remain unchanged with the * exception of the following: * - The global alpha is set to 1. * - The shadow is turned off. * - The blend mode is set to `kCGBlendModeNormal'. * Ending the transparency layer restores these parameters to the values * they had before `CGContextBeginTransparencyLayer' was called.* Transparency layers may be nested. */toolbox CGContextBeginTransparencyLayer( CGContextRef c, CFDictionaryRef auxiliaryInfo ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/* Begin a transparency layer in `context'. This function is identical to * `CGContextBeginTransparencyLayer' except that the content of the * transparency layer will be bounded by `rect' (specified in user* space). */toolbox CGContextBeginTransparencyLayerWithRect( CGContextRef context, CGRect rect, CFDictionaryRef auxiliaryInfo ) // AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* End a tranparency layer. */toolbox CGContextEndTransparencyLayer( CGContextRef context ) // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/** User space to device space tranformations. **//* Return the affine transform mapping the user space (abstract* coordinates) of `context' to device space (pixels). */toolbox fn CGContextGetUserSpaceToDeviceSpaceTransform( CGContextRef c ) = CGAffineTransform // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform `point' from the user space of `context' to device space. */toolbox fn CGContextConvertPointToDeviceSpace( CGContextRef c, CGPoint point ) = CGPoint // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform `point' from device space to the user space of `context'. */toolbox fn CGContextConvertPointToUserSpace( CGContextRef c, CGPoint point ) = CGPoint // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform `size' from the user space of `context' to device space. */toolbox fn CGContextConvertSizeToDeviceSpace( CGContextRef c, CGSize size ) = CGSize // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform `size' from device space to the user space of `context'. */toolbox fn CGContextConvertSizeToUserSpace( CGContextRef c, CGSize size ) = CGSize // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform `rect' from the user space of `context' to device space. Since * affine transforms do not preserve rectangles in general, this function * returns the smallest rectangle which contains the transformed corner* points of `rect'. */toolbox fn CGContextConvertRectToDeviceSpace( CGContextRef c, CGRect rect ) = CGRect // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform `rect' from device space to the user space of `context'. Since * affine transforms do not preserve rectangles in general, this function * returns the smallest rectangle which contains the transformed corner* points of `rect'. */toolbox fn CGContextConvertRectToUserSpace( CGContextRef c, CGRect rect ) = CGRect // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;#endif// _DEFINEDINCARBON