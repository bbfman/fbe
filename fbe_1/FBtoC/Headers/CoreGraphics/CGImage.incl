/*   Translated to FB using         HeadToHead       by Bernie Wylde         ----------        5 January 2009*//* CoreGraphics - CGImage.h * Copyright (c) 2000-2005 Apple Computer, Inc. * All rights reserved.*/#if ndef _DEFINEDINCARBON#if ndef _kHIViewAttributeSendCommandToUserFocus#define CGImageRef as pointer#endifbegin enum not output_kCGImageAlphaNone_kCGImageAlphaPremultipliedLast /* For example, premultiplied RGBA */_kCGImageAlphaPremultipliedFirst /* For example, premultiplied ARGB */_kCGImageAlphaLast /* For example, non-premultiplied RGBA */_kCGImageAlphaFirst /* For example, non-premultiplied ARGB */_kCGImageAlphaNoneSkipLast /* Equivalent to kCGImageAlphaNone. */_kCGImageAlphaNoneSkipFirst_kCGImageAlphaOnly /* No color data, alpha data only */end enum#define CGImageAlphaInfo as SInt32begin enum_kCGBitmapAlphaInfoMask     = 0x1F _kCGBitmapFloatComponents   = (1 << 8)                             _kCGBitmapByteOrderMask     = 0x7000 _kCGBitmapByteOrderDefault  = (0 << 12) _kCGBitmapByteOrder16Little = (1 << 12) _kCGBitmapByteOrder32Little = (2 << 12) _kCGBitmapByteOrder16Big    = (3 << 12) _kCGBitmapByteOrder32Big    = (4 << 12)end enum#define CGBitmapInfo as UInt32/* Return the CFTypeID for CGImageRefs. */toolbox fn CGImageGetTypeID = CFTypeID// AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* Create an image. */toolbox fn CGImageCreate( UInt32 width, UInt32 height, UInt32 bitsPerComponent, UInt32 bitsPerPixel, UInt32 bytesPerRow, Â     CGColorSpaceRef colorspace, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, Â     Boolean shouldInterpolate, CGColorRenderingIntent intent ) = CGImageRef/* Create an image mask. */toolbox fn CGImageMaskCreate( UInt32 width, UInt32 height, UInt32 bitsPerComponent, UInt32 bitsPerPixel, UInt32 bytesPerRow, Â     CGDataProviderRef provider, const CGFloat *decode, Boolean shouldInterpolate ) = CGImageRef/* Return a copy of `image'. Only the image structure itself is copied; the* underlying data is not. */toolbox fn CGImageCreateCopy( CGImageRef image ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Create an image from `source', a data provider of JPEG-encoded data. */toolbox fn CGImageCreateWithJPEGDataProvider( CGDataProviderRef source, const CGFloat *decode, Boolean shouldInterpolate, CGColorRenderingIntent intent ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;/* Create an image using `source', a data provider for PNG-encoded data. */toolbox fn CGImageCreateWithPNGDataProvider( CGDataProviderRef source, const CGFloat *decode, Boolean shouldInterpolate, CGColorRenderingIntent intent ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* Create an image using the data contained within the subrectangle `rect' * of `image'. * * The new image is created by * 1) adjusting `rect' to integral bounds by calling "CGRectIntegral"; * 2) intersecting the result with a rectangle with origin (0, 0) and * size equal to the size of `image'; * 3) referencing the pixels within the resulting rectangle, treating the * first pixel of the image data as the origin of the image. * If the resulting rectangle is the null rectangle, this function returns * NULL. * * If W and H are the width and height of image, respectively, then the * point (0,0) corresponds to the first pixel of the image data; the point * (W-1, 0) is the last pixel of the first row of the image data; (0, H-1) * is the first pixel of the last row of the image data; and (W-1, H-1) is * the last pixel of the last row of the image data. * * The resulting image retains a reference to the original image, so you* may release the original image after calling this function. */toolbox fn CGImageCreateWithImageInRect( CGImageRef image, CGRect rect ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Create a new image from `image' masked by `mask', which may be an image * mask or an image. * * If `mask' is an image mask, then it indicates which parts of the context * are to be painted with the image when drawn in a context, and which are * to be masked out (left unchanged). The source samples of the image mask * determine which areas are painted, acting as an "inverse alpha": if the * value of a source sample in the image mask is S, then the corresponding * region in `image' is blended with the destination using an alpha of * (1-S). (For example, if S is 1, then the region is not painted, while if * S is 0, the region is fully painted.) * * If `mask' is an image, then it serves as alpha mask for blending the * image onto the destination. The source samples of `mask' determine which * areas are painted: if the value of the source sample in mask is S, then * the corresponding region in image is blended with the destination with * an alpha of S. (For example, if S is 0, then the region is not painted, * while if S is 1, the region is fully painted.) * * The parameter `image' may not be an image mask and may not have an image * mask or masking color associated with it. * * If `mask' is an image, then it must be in the DeviceGray color space, * may not have alpha, and may not itself be masked by an image mask or a* masking color. */toolbox fn CGImageCreateWithMask( CGImageRef image, CGImageRef mask ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Create a new image from `image' masked by `components', an array of 2N * values { min[1], max[1], ... min[N], max[N] } where N is the number of * components in color space of `image'. Any image sample with color value * {c[1], ... c[N]} where min[i] <= c[i] <= max[i] for 1 <= i <= N is * masked out (that is, not painted). * * Each value in `components' must be a valid image sample value: if * `image' has integral pixel components, then each value of must be in the * range [0 .. 2**bitsPerComponent - 1] (where `bitsPerComponent' is the * number of bits/component of `image'); if `image' has floating-point * pixel components, then each value may be any floating-point number which * is a valid color component. * * The parameter `image' may not be an image mask, and may not already have* an image mask or masking color associated with it. */toolbox fn CGImageCreateWithMaskingColors( CGImageRef image, const CGFloat *components ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Create a copy of `image', replacing the image's colorspace with * `colorspace'. Returns NULL if `image' is an image mask, or if the number * of components of `colorspace' isn't the same as the number of components* of the colorspace of `image'. */toolbox fn CGImageCreateCopyWithColorSpace( CGImageRef image, CGColorSpaceRef colorspace ) = CGImageRef// AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;/* Equivalent to `CFRetain(image)'. */toolbox fn CGImageRetain( CGImageRef image ) = CGImageRef/* Equivalent to `CFRelease(image)'. */toolbox CGImageRelease( CGImageRef image )/* Return true if `image' is an image mask, false otherwise. */toolbox fn CGImageIsMask( CGImageRef image ) = Boolean/* Return the width of `image'. */toolbox fn CGImageGetWidth( CGImageRef image ) = UInt32/* Return the height of `image'. */toolbox fn CGImageGetHeight( CGImageRef image ) = UInt32/* Return the number of bits/component of `image'. */toolbox fn CGImageGetBitsPerComponent( CGImageRef image ) = UInt32/* Return the number of bits/pixel of `image'. */toolbox fn CGImageGetBitsPerPixel( CGImageRef image ) = UInt32/* Return the number of bytes/row of `image'. */toolbox fn CGImageGetBytesPerRow( CGImageRef image ) = UInt32/* Return the colorspace of `image', or NULL if `image' is an image* mask. */toolbox fn CGImageGetColorSpace( CGImageRef image ) = CGColorSpaceRef/* Return the alpha info of `image'. */toolbox fn CGImageGetAlphaInfo( CGImageRef image ) = CGImageAlphaInfo/* Return the data provider of `image'. */toolbox fn CGImageGetDataProvider( CGImageRef image ) = CGDataProviderRef/* Return the decode array of `image'. */toolbox fn CGImageGetDecode( CGImageRef image ) = pointer// *CGFloat/* Return the interpolation parameter of `image'. */toolbox fn CGImageGetShouldInterpolate( CGImageRef image ) = Boolean/* Return the rendering intent of `image'. */toolbox fn CGImageGetRenderingIntent( CGImageRef image ) = CGColorRenderingIntent/* Return the bitmap info of `image'. */toolbox fn CGImageGetBitmapInfo( CGImageRef image ) = CGBitmapInfo// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;#endif// _DEFINEDINCARBON