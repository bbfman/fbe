/*   NSLog.incl   Bernie Wylde 20110614   v1.4.5 20170511*/_NSLOG = 1// NSLog.hBeginCDeclaration#define _NSLOG 1extern const NSString *NSLogVers;// sending messagesvoid NSLog( NSString *formatString, ... );void NSLogAlert( NSString *formatString, ... );int printf( const char *format, ... );// clearing the logvoid NSLogClear();// message appearance and formatvoid NSLogSetShowsDate( BOOL flag );void NSLogSetShowsTime( BOOL flag );void NSLogSetShowsAppName( BOOL flag );void NSLogSetShowsProcessID( BOOL flag );void NSLogSetFont( NSString *name, CGFloat size );void NSLogSetTempFont( NSString *name, CGFloat size );NSFont *NSLogFont();void NSLogRestoreDefaultFont();// suppressing log outputvoid NSLogSuppress( BOOL flag );// accessing message textNSString *NSLogString();void NSLogWriteToURL( NSURL *url );void NSLogSave( NSString *message, NSString *filename );// windowvoid NSLogSetTitle( NSString *title );void NSLogSetFrame( NSRect r );NSRect NSLogFrame();void NSLogShow();void NSLogHide();NSPanel *NSLogWindow();void NSLogSetFloatingWindow( BOOL flag );void NSLogSetBecomesKeyOnlyIfNeeded( BOOL flag );void NSLogSetTerminateAppWhenWindowClosed( BOOL flag );void NSLogScrollToTop();void NSLogSetTextWrap( BOOL flag );// buttonsvoid NSLogSettingsButtonSetHidden( BOOL flag );void NSLogWrapTextButtonSetHidden( BOOL flag );void NSLogFindButtonSetHidden( BOOL flag );void NSLogSaveButtonSetHidden( BOOL flag );void NSLogClearButtonSetHidden( BOOL flag );void NSLogButtonsSetHidden( BOOL flag );// consolevoid NSLogSetForwardToConsole( BOOL flag );// begin/end editingvoid NSLogBeginEditing();void NSLogEndEditing();EndC// NSLog.mBeginCFunctionconst NSString *NSLogVers = @"1.4.5";@interface NSLogTextView : NSTextView@end@implementation NSLogTextView- (void)copyAll:(id)sender {    [[NSPasteboard generalPasteboard] clearContents];    [[NSPasteboard generalPasteboard] setString:self.string  forType:NSStringPboardType];}- (NSMenu *)menuForEvent:(NSEvent *)event {    NSMenu *menu = [[NSMenu alloc] initWithTitle:@""];    [menu addItemWithTitle:@"Copy" action:@selector(copy:) keyEquivalent:@""];    [menu addItemWithTitle:@"Copy All" action:@selector(copyAll:) keyEquivalent:@""];    [menu setAllowsContextMenuPlugIns:NO];    return menu;}@end@interface NSLogPanel : NSPanel@end@implementation NSLogPanel- (id)init {     if ( self = [super initWithContentRect:NSMakeRect( 100, 100, 400, 200 ) styleMask:NSTitledWindowMask | NSClosableWindowMask | NSResizableWindowMask backing:NSBackingStoreBuffered defer:NO] ) {     }     return self;}@end#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060@interface NSLogController : NSObject <NSWindowDelegate> {    NSLogPanel *window;    NSScrollView *scrollView;    NSLogTextView *textView;    NSTextFinder *textFinder;    NSPopover *popover;    NSView *settingsView;    NSButton *settingsBtn;    NSButton *wrapBtn;    NSButton *findBtn;    NSButton *saveBtn;    NSButton *clearBtn;    BOOL terminateAppWhenWindowClosed;}@end#else@interface NSLogController : NSObject <NSWindowDelegate> {    NSLogPanel *window;    NSScrollView *scrollView;    NSLogTextView *textView;    NSDrawer *drawer;    NSView *settingsView;    NSButton *settingsBtn;    NSButton *wrapBtn;    NSButton *findBtn;    NSButton *saveBtn;    NSButton *clearBtn;    BOOL terminateAppWhenWindowClosed;}- (void)saveWithMessage:(NSString *)message nameFieldStringValue:(NSString *)filename;@end#endif#define kNSLogApplicationID CFSTR( "com.berniewylde.nslog" )#define kNSLogFontNameKey CFSTR( "FontName" )#define kNSLogFontSizeKey CFSTR( "FontSize" )#define kNSLogWindowBoundsKey @"NSLogWindowBounds"#define kNSLogDefaultFontName @"Menlo-Bold"#define kNSLogDefaultFontSize 11.0#define kNSLogWindowBorderThickness 23enum {    kNSLogDateBtnTag            = 1,    kNSLogTimeBtnTag            = 2,    kNSLogAppNameBtnTag         = 3,    kNSLogProcessIDBtnTag       = 4,    kNSLogConsoleBtnTag         = 5,    kNSLogFloatingBtnTag        = 6};BOOL sNSLogSuppress = NO;BOOL sNSLogAlert = NO;@interface NSLogController()@property (assign, nonatomic) NSLogPanel *window;@property (assign, nonatomic) NSLogTextView *textView;#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060@property (assign, nonatomic) NSTextFinder *textFinder;@property (assign, nonatomic) NSPopover *popover;#else@property (assign, nonatomic) NSDrawer *drawer;#endif@property (assign, nonatomic) NSButton *settingsBtn;@property (assign, nonatomic) NSButton *wrapBtn;@property (assign, nonatomic) NSButton *findBtn;@property (assign, nonatomic) NSButton *saveBtn;@property (assign, nonatomic) NSButton *clearBtn;@property (assign) BOOL terminateAppWhenWindowClosed;@end// private functionsNSLogController *NSLogGetController();void NSLogV2( NSString *formatString, va_list ap, BOOL cr );void NSLogV( NSString *formatString, va_list ap );void NSLogReleaseObject( id obj );@implementation NSLogController@synthesize window;@synthesize textView;#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060@synthesize textFinder;@synthesize popover;#else@synthesize drawer;#endif@synthesize settingsBtn;@synthesize wrapBtn;@synthesize findBtn;@synthesize saveBtn;@synthesize clearBtn;@synthesize terminateAppWhenWindowClosed;#pragma mark - preferences- (void)setPrefsForButton:(NSButton *)btn {    CFBooleanRef flag;    if ( [btn state] == NSOnState ) {        flag = kCFBooleanTrue;    } else {        flag = kCFBooleanFalse;    }    #if !__has_feature(objc_arc)    CFPreferencesSetAppValue( (CFStringRef)[btn title], flag, kNSLogApplicationID );#else    CFPreferencesSetAppValue( (__bridge CFStringRef)[btn title], flag, kNSLogApplicationID );#endif        CFPreferencesAppSynchronize( kNSLogApplicationID );}- (void)setPrefsForButtonWithTag:(NSInteger)tag {    [self setPrefsForButton:[self buttonWithTag:tag]];}- (void)setPrefsForWrapButton {    CFBooleanRef flag;    if ( [wrapBtn state] == NSOnState ) {        flag = kCFBooleanTrue;    } else {        flag = kCFBooleanFalse;    }    // set prefs#if !__has_feature(objc_arc)    CFPreferencesSetAppValue( (CFStringRef)@"Wrap", flag, kNSLogApplicationID );#else    CFPreferencesSetAppValue( (__bridge CFStringRef)@"Wrap", flag, kNSLogApplicationID );#endif    CFPreferencesAppSynchronize( kNSLogApplicationID );}- (void)loadPrefsForButtonWithTag:(NSInteger)tag {    NSButton *btn = [self buttonWithTag:tag];#if !__has_feature(objc_arc)    CFBooleanRef ref = CFPreferencesCopyAppValue( (CFStringRef)[btn title], kNSLogApplicationID );#else    CFBooleanRef ref = CFPreferencesCopyAppValue( (__bridge CFStringRef)[btn title], kNSLogApplicationID );#endif        if ( ref != NULL ) {        if ( ref == kCFBooleanTrue ) {            [btn setState:NSOnState];        } else {            [btn setState:NSOffState];        }        CFRelease( ref );    } else {        switch ( tag ) {            case kNSLogFloatingBtnTag:                [btn setState:NSOnState];                break;            default:                [btn setState:NSOffState];                break;           }    }}- (void)loadPrefsForWrapButton {#if !__has_feature(objc_arc)    CFBooleanRef ref = CFPreferencesCopyAppValue( (CFStringRef)@"Wrap", kNSLogApplicationID );#else    CFBooleanRef ref = CFPreferencesCopyAppValue( (__bridge CFStringRef)@"Wrap", kNSLogApplicationID );#endif    if ( ref != NULL ) {        if ( ref == kCFBooleanTrue ) {            [wrapBtn setState:NSOnState];        } else {            [wrapBtn setState:NSOffState];        }        CFRelease( ref );    } else {        [wrapBtn setState:NSOnState];    }}- (void)loadPrefs {    [self loadPrefsForButtonWithTag:kNSLogDateBtnTag];    [self loadPrefsForButtonWithTag:kNSLogTimeBtnTag];    [self loadPrefsForButtonWithTag:kNSLogAppNameBtnTag];    [self loadPrefsForButtonWithTag:kNSLogProcessIDBtnTag];    [self loadPrefsForButtonWithTag:kNSLogConsoleBtnTag];    [self loadPrefsForButtonWithTag:kNSLogFloatingBtnTag];    [self loadPrefsForWrapButton];}- (NSInteger)sysVersion {    NSDictionary *sv = [NSDictionary dictionaryWithContentsOfFile:@"/System/Library/CoreServices/SystemVersion.plist"];    NSString *string = [sv objectForKey:@"ProductVersion"];    NSArray *array = [string componentsSeparatedByString:@"."];    NSString *versString = [NSString stringWithFormat:@"%@%@",[array objectAtIndex:0],[array objectAtIndex:1]];    return [versString integerValue];}#pragma mark - popover/drawer methods- (void)closePopover {#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    if ( [popover isShown] ) [popover close];#else    if ( [drawer state] == NSDrawerOpenState ) [drawer close];#endif}#pragma mark - window delegate methods- (BOOL)windowShouldClose:(NSNotification *)notification {    [window orderOut:nil];    return terminateAppWhenWindowClosed;}- (void)windowWillClose:(NSNotification *)notification {    if ( terminateAppWhenWindowClosed ) [NSApp terminate:nil];}#pragma mark - button actions- (void)clearBtnAction:(id)sender {    [self closePopover];    textView.string = @"";}#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060- (void)findBtnAction:(id)sender {    [self closePopover];    if ( [[textFinder findBarContainer] isFindBarVisible] ) {        [textFinder performAction:NSTextFinderActionHideFindInterface];    } else {        [textFinder performAction:NSTextFinderActionShowFindInterface];        [window makeKeyAndOrderFront:nil];    }}#endif- (void)saveWithMessage:(NSString *)message nameFieldStringValue:(NSString *)filename {    [window makeKeyAndOrderFront:nil];    NSSavePanel *sp = [NSSavePanel savePanel];    [sp setMessage:message];    [sp setNameFieldStringValue:filename];    [sp beginSheetModalForWindow:window completionHandler:^(NSInteger result) {        if ( result == NSOKButton ) {     //NSFileHandlingPanelOKButton ) {            NSLogWriteToURL( [sp URL] );        }    }];}- (void)saveBtnAction:(id)sender {    [self closePopover];    [self saveWithMessage:@"Save log" nameFieldStringValue:@"Untitled"];}- (void)settingsBtnAction:(id)sender {#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    if ( [popover isShown] ) {        [popover close];    } else {        [popover showRelativeToRect:[sender bounds] ofView:sender preferredEdge:NSMinXEdge];        [window makeKeyAndOrderFront:nil];    }#else    [drawer toggle:nil];#endif}- (void)switchButtonAction:(id)sender {    [self setPrefsForButton:sender];    switch ( [sender tag] ) {        case kNSLogFloatingBtnTag:            [window setFloatingPanel:([[self buttonWithTag:kNSLogFloatingBtnTag] state] == NSOnState)];#if __MAC_OS_X_VERSION_MAX_ALLOWED <= 1060            if ( ![window isFloatingPanel] ) [drawer toggle:nil];// workaround for bug#endif            break;        default:            break;    }}- (NSImage *)imageForResource:(NSString *)name {    NSImage *image = [NSImage imageNamed:name];    if ( image == nil ) {        NSURL *url = [[NSWorkspace sharedWorkspace] URLForApplicationWithBundleIdentifier:@"com.stazsoftware.fbtoc.editor"];        NSBundle *bundle = [NSBundle bundleWithURL:url];        NSString *imagePath = [bundle pathForResource:name ofType:@"png"];#if !__has_feature(objc_arc)        image = [[[NSImage alloc] initWithContentsOfFile:imagePath] autorelease];#else        image = [[NSImage alloc] initWithContentsOfFile:imagePath];#endif    }    return image;}// workaround to refresh text view wrapping- (void)fixTextViewWrapping {     NSRect r = [scrollView frame];     r.size.width++;     [scrollView setFrame:r];     r.size.width--;     [scrollView setFrame:r];     r.origin.x = 0;     r.origin.y = 0;     [textView setFrame:r];}- (void)setTextWrap:(id)sender {    NSTextContainer *textContainer = [textView textContainer];    if ( [sender state] == NSOnState ) {        [textContainer setContainerSize:NSMakeSize([scrollView frame].size.width, FLT_MAX)];        [textContainer setWidthTracksTextView:YES];        [scrollView setHasHorizontalScroller:NO];        [textView setHorizontallyResizable:NO];        [scrollView reflectScrolledClipView:[scrollView contentView]];        [wrapBtn setTitle:[NSString stringWithFormat:@"%C",(unsigned short)10619]];    } else {        [textContainer setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];        [textContainer setWidthTracksTextView:NO];        [scrollView setHasHorizontalScroller:YES];        [textView setHorizontallyResizable:YES];                NSRect r = [[scrollView contentView] documentVisibleRect];        NSPoint pt = r.origin;        [[scrollView contentView] scrollToPoint:NSMakePoint(0,pt.y)];        [scrollView reflectScrolledClipView:[scrollView contentView]];        [self fixTextViewWrapping];        [wrapBtn setTitle:[NSString stringWithFormat:@"%C",(unsigned short)8649]];    }#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    [scrollView flashScrollers];#endif}- (void)wrapButtonAction:(id)sender {    [self closePopover];    [self setTextWrap:sender];    [self setPrefsForWrapButton];}#pragma mark - convenience methods- (NSButton *)buttonWithTag:(NSInteger)tag {    return [settingsView viewWithTag:tag];}- (void)buttonWithTag:(NSInteger)tag setStateWithBool:(BOOL)flag {    NSInteger state = NSOffState;    if ( flag ) state = NSOnState;    [[self buttonWithTag:tag] setState:state];    [self setPrefsForButtonWithTag:tag];}- (void)switchButtonInitWithFrame:(NSRect)rect title:(NSString *)title tag:(NSInteger)tag toolTip:(NSString *)tooltip {    NSButton *btn = [[NSButton alloc ]initWithFrame:rect];    [btn setTitle:title];    [btn setButtonType:NSSwitchButton];    [[btn cell] setControlSize:NSSmallControlSize];    [[btn cell] setFont:[NSFont systemFontOfSize:[NSFont smallSystemFontSize]]];    [btn setTarget:self];    [btn setAction:@selector(switchButtonAction:)];    [btn setAutoresizingMask:NSViewMinYMargin];    [btn setTag:tag];    [btn setToolTip:tooltip];    [settingsView addSubview:btn];    NSLogReleaseObject( btn );}- (void)pauseWithMessage:(NSString *)msg {    NSAlert *alert = [[NSAlert alloc] init];    [[alert window] setTitle:@"NSLog Paused"];    [alert setMessageText:msg];    [alert addButtonWithTitle:@"Continue"];    [alert addButtonWithTitle:@"Stop"];    [alert setInformativeText:@"Stop to terminate this app. Continue to resume."];    NSArray *buttons = [alert buttons];    [[buttons objectAtIndex:1] setKeyEquivalent: @"\033"];    if ( [alert runModal] != NSAlertFirstButtonReturn ) [NSApp terminate:nil];    NSLogReleaseObject( alert );}#pragma mark - init- (id)init {    self = [super init];    if ( ![NSApp mainMenu] ) NSApplicationLoad();     // if app doesn't have Cocoa main menu (Carbon app)        // window    window = [[NSLogPanel alloc] init];    [window setTitle:@"NSLog"];    [window setDelegate:self];    [window setOpaque:NO];    [window setAutorecalculatesContentBorderThickness:YES forEdge:NSMinYEdge];    [window setContentBorderThickness:kNSLogWindowBorderThickness forEdge:NSMinYEdge];    [window setBecomesKeyOnlyIfNeeded:YES];#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    [window setMinSize:NSMakeSize(275, 90)];#else    [window setMinSize:NSMakeSize(275, 202)];#endif    [window setHidesOnDeactivate:NO];    [window setFrameAutosaveName:kNSLogWindowBoundsKey];    // contentView    NSView *contentView = [window contentView];    NSRect frame = [contentView frame];    frame.size.height -= kNSLogWindowBorderThickness;    frame.origin.y += kNSLogWindowBorderThickness;        // scrollView    scrollView = [[NSScrollView alloc] initWithFrame:frame];    NSSize contentSize = [scrollView contentSize];    [scrollView setBorderType:NSNoBorder];    [scrollView setHasVerticalScroller:YES];    [scrollView setAutohidesScrollers:YES];    [scrollView setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];        // textView    NSRect textViewFrame = NSMakeRect( 0, 0, frame.size.width,frame.size.height );    textView = [[NSLogTextView alloc] initWithFrame:textViewFrame];    [textView setMinSize:NSMakeSize(0.0, contentSize.height)];    [textView setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];    [textView setVerticallyResizable:YES];    [textView setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];    [textView setEditable:NO];    #if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    [textView setUsesFindBar:YES];    textFinder = [[NSTextFinder alloc] init];    [textFinder setClient:(id<NSTextFinderClient>)textView];    [textFinder setFindBarContainer:(id<NSTextFinderBarContainer>)scrollView];#endif        NSTextContainer *textContainer = [textView textContainer];    [textContainer setContainerSize:NSMakeSize(contentSize.width, FLT_MAX)];    [textContainer setWidthTracksTextView:YES];    CFStringRef fontName = CFPreferencesCopyAppValue( kNSLogFontNameKey, kNSLogApplicationID );    NSFont *font = nil;    if ( fontName ) {        CFNumberRef number = CFPreferencesCopyAppValue( kNSLogFontSizeKey, kNSLogApplicationID );        CGFloat size;        CFNumberGetValue( number, kCFNumberCGFloatType, &size );        CFRelease( number );        #if !__has_feature(objc_arc)        font = [NSFont fontWithName:(NSString*)fontName size:size];#else        font = [NSFont fontWithName:(__bridge NSString*)fontName size:size];#endif                CFRelease( fontName );    } else {        font = [NSFont fontWithName:(NSString *)kNSLogDefaultFontName size:kNSLogDefaultFontSize];    }    if ( font ) [textView setFont:font];    [contentView addSubview:scrollView];    [scrollView setDocumentView:textView];    NSLogReleaseObject( scrollView );    // settingsBtn    settingsBtn = [[NSButton alloc] initWithFrame:NSMakeRect( 10, 1, 20, 20 )];    [settingsBtn setBordered:NO];    [settingsBtn setImage:[NSImage imageNamed:NSImageNameSmartBadgeTemplate]];    [[settingsBtn cell] setHighlightsBy:NSContentsCellMask];    [settingsBtn setToolTip:@"Settings"];    [settingsBtn setTarget:self];    [settingsBtn setAction:@selector(settingsBtnAction:)];    [contentView addSubview:settingsBtn];    NSLogReleaseObject( settingsBtn );        // wrapBtn    wrapBtn = [[NSButton alloc] initWithFrame:NSMakeRect(35,1,20,20)];    [[wrapBtn cell] setHighlightsBy:NSContentsCellMask];    [wrapBtn setTitle:@""];    [wrapBtn setBordered:NO];    [wrapBtn setFont:[NSFont fontWithName:@"Symbol" size:15]];    [wrapBtn setTitle:[NSString stringWithFormat:@"%C",(unsigned short)10619]];    [wrapBtn setToolTip:@"Wrap/Unwrap text"];    [wrapBtn setTarget:self];    [wrapBtn setAction:@selector(wrapButtonAction:)];    [contentView addSubview:wrapBtn];    NSLogReleaseObject( wrapBtn );    // clearBtn    clearBtn = [[NSButton alloc] initWithFrame:NSMakeRect( frame.size.width - 35, 1, 20, 20 )];    [clearBtn setBordered:NO];    NSImage *trashImage = [NSImage imageNamed:NSImageNameTrashEmpty];    [trashImage setSize:NSMakeSize(18,18)];        if ( [self sysVersion] < 1010 ) {        [clearBtn setImage:trashImage];    } else {                // make OS 10.10 trash icon darker        NSSize trashImageSize = [trashImage size];        NSImage *darkImage = [[NSImage alloc] initWithSize:trashImageSize];        [darkImage lockFocus];        [trashImage drawAtPoint:NSZeroPoint fromRect:NSMakeRect(0,0,trashImageSize.width,trashImageSize.height) operation:NSCompositeSourceOver fraction:1.0];        [[[NSColor blackColor] colorWithAlphaComponent:0.15] set];        NSRectFillUsingOperation(NSMakeRect(0,0,trashImageSize.width,trashImageSize.height), NSCompositeSourceAtop);        [darkImage unlockFocus];        [clearBtn setImage:darkImage];        #if !__has_feature(objc_arc)        [darkImage release];#endif    }        [[clearBtn cell] setHighlightsBy:NSContentsCellMask];    [clearBtn setToolTip:@"Clear log"];    [clearBtn setTarget:self];    [clearBtn setAction:@selector(clearBtnAction:)];    [contentView addSubview:clearBtn];    [clearBtn setAutoresizingMask:NSViewMinXMargin];    NSLogReleaseObject( clearBtn );        // saveBtn    saveBtn = [[NSButton alloc] initWithFrame:NSMakeRect( frame.size.width - 65, 1, 20, 20 )];    [saveBtn setBordered:NO];    NSImage *saveImage = [[NSWorkspace sharedWorkspace] iconForFileType:NSFileTypeForHFSTypeCode(kGenericHardDiskIcon)];    [saveImage setSize:NSMakeSize(15,15)];    [saveBtn setImage:saveImage];    [[saveBtn cell] setHighlightsBy:NSContentsCellMask];    [saveBtn setToolTip:@"Save log to disk"];    [saveBtn setTarget:self];    [saveBtn setAction:@selector(saveBtnAction:)];    [contentView addSubview:saveBtn];    [saveBtn setAutoresizingMask:NSViewMinXMargin];    NSLogReleaseObject( saveBtn );        // findBtn#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    findBtn = [[NSButton alloc] initWithFrame:NSMakeRect( frame.size.width - 95, 1, 20, 20 )];    [findBtn setBordered:NO];    [findBtn setImage:[NSImage imageNamed:NSImageNameRevealFreestandingTemplate]];    [[findBtn cell] setHighlightsBy:NSContentsCellMask];    [findBtn setToolTip:@"Search log"];    [findBtn setTarget:self];    [findBtn setAction:@selector(findBtnAction:)];    [contentView addSubview:findBtn];    [findBtn setAutoresizingMask:NSViewMinXMargin];    NSLogReleaseObject( findBtn );#endif        // drawer or popover#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1060    settingsView = [[NSView alloc] initWithFrame:NSMakeRect(0,0,100,220)];    CGFloat height = [settingsView frame].size.height;    NSViewController*controller = [[NSViewController alloc] init];    [controller setView:settingsView];    NSLogReleaseObject( settingsView );    popover = [[NSPopover alloc] init];    [popover setBehavior:NSPopoverBehaviorTransient];    [popover setAnimates:YES];    [popover setContentViewController:controller];    NSLogReleaseObject( controller );#else    CGFloat height = [window frame].size.height;    drawer = [[NSDrawer alloc] initWithContentSize:NSMakeSize( 90.0, height ) preferredEdge:NSMinXEdge];    [drawer setMinContentSize:NSMakeSize( 90.0, 0.0 )];    [drawer setMaxContentSize:NSMakeSize( 90.0, FLT_MAX )];    [drawer setParentWindow:window];    settingsView = [drawer contentView];#endif    [self switchButtonInitWithFrame:NSMakeRect( 4, height - 20, 47, 16 ) title:@"Date" tag:kNSLogDateBtnTag toolTip:@"Print date before message"];    [self switchButtonInitWithFrame:NSMakeRect( 4, height - 40, 49, 16 ) title:@"Time" tag:kNSLogTimeBtnTag toolTip:@"Print time before message"];    [self switchButtonInitWithFrame:NSMakeRect( 4, height - 60, 77, 16 ) title:@"App name" tag:kNSLogAppNameBtnTag toolTip:@"Print app name before message"];    [self switchButtonInitWithFrame:NSMakeRect( 4, height - 80, 85, 16 ) title:@"Process ID" tag:kNSLogProcessIDBtnTag toolTip:@"Print app process ID before message"];        NSBox *separator1 = [[NSBox alloc] initWithFrame:NSMakeRect( 2, height - 88, 85, 1 )];    [separator1 setBoxType:NSBoxCustom];    [separator1 setBorderType:NSLineBorder];    [settingsView addSubview:separator1];    [separator1 setAutoresizingMask:NSViewMinYMargin];    NSLogReleaseObject( separator1 );        [self switchButtonInitWithFrame:NSMakeRect( 4, height - 110, 85, 16 ) title:@"Console" tag:kNSLogConsoleBtnTag toolTip:@"Forward messages to Console.app"];        NSBox *separator2 = [[NSBox alloc] initWithFrame:NSMakeRect( 2, height - 118, 85, 1 )];    [separator2 setBoxType:NSBoxCustom];    [separator2 setBorderType:NSLineBorder];    [settingsView addSubview:separator2];    [separator2 setAutoresizingMask:NSViewMinYMargin];    NSLogReleaseObject( separator2 );        [self switchButtonInitWithFrame:NSMakeRect( 4, height - 140, 65, 16 ) title:@"Floating" tag:kNSLogFloatingBtnTag toolTip:@"Make NSLog window floating window"];        NSText *label = [[NSText alloc] initWithFrame:NSMakeRect( 0, height - 280, 100, 100 )];    [label setEditable:NO];    [label setSelectable:NO];    [label setFont:[NSFont systemFontOfSize:[NSFont systemFontSizeForControlSize:NSMiniControlSize]]];    NSString *versText = [NSString stringWithFormat:@"NSLog v%@\r\u2022\rBernie Wylde", NSLogVers];    [label setString:versText];    [label setAlignment:NSCenterTextAlignment];    [label setDrawsBackground:NO];    [label setAutoresizingMask:NSViewMinYMargin];    [settingsView addSubview:label];    NSLogReleaseObject( label );        [self loadPrefs];    [self setTextWrap:wrapBtn];    return self;}@end#pragma mark - private functionsNSLogController *NSLogGetController(){    if ( sNSLogSuppress ) return nil;    static NSLogController *sNSLogController;    if ( sNSLogController == nil ) sNSLogController = [[NSLogController alloc] init];    return sNSLogController;}void NSLogV2( NSString *formatString, va_list ap, BOOL cr ){    NSLogController *controller = NSLogGetController();    if ( controller != nil ) {        NSMutableString *temp = [NSMutableString stringWithCapacity:0];        BOOL dateFlag = [[controller buttonWithTag:kNSLogDateBtnTag] state] == NSOnState;        BOOL timeFlag = [[controller buttonWithTag:kNSLogTimeBtnTag] state] == NSOnState;        if ( dateFlag || timeFlag ) {            NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];            NSMutableString *format = [[NSMutableString alloc] initWithCapacity:0];            if ( dateFlag ) {                [format appendString:@"yyyy-MM-dd"];                if ( timeFlag ) [format appendString:@" "];            }            if ( timeFlag ) [format appendString:@"HH:mm:ss.SSS"];            [dateFormatter setDateFormat:format];            NSLogReleaseObject( format );            [temp appendString:[dateFormatter stringFromDate:[NSDate date]]];            NSLogReleaseObject( dateFormatter );        }                if ( [[controller buttonWithTag:kNSLogAppNameBtnTag] state] == NSOnState ) {            if ( [temp length] > 0 ) [temp appendString:@" "];            [temp appendString:[[NSProcessInfo processInfo] processName]];        }                if ( [[controller buttonWithTag:kNSLogProcessIDBtnTag] state] == NSOnState ) {            if ( [temp length] > 0 ) [temp appendString:@" "];            [temp appendFormat:@"[%d]",[[NSProcessInfo processInfo] processIdentifier]];        }                if ( [temp length] > 0 ) [temp appendString:@": "];                [temp appendString:(NSString *)formatString];        if ( cr ) [temp appendString:@"\n"];                va_list apCopy;        va_copy(apCopy, ap);        NSString *string = [[NSString alloc] initWithFormat:temp arguments:apCopy];        va_end(apCopy);                NSLogTextView *textView = [controller textView];        NSTextStorage *textStorage = [textView textStorage];        [textStorage replaceCharactersInRange:NSMakeRange([textStorage length], 0) withString:string];        [textView scrollRangeToVisible:NSMakeRange( [[textView string] length], 0 )];                NSLogShow();        if ( [[controller buttonWithTag:kNSLogConsoleBtnTag] state] == NSOnState ) NSLogv( formatString, ap );                // alert        if ( sNSLogAlert ) {            [controller pauseWithMessage:string];            sNSLogAlert = NO;        }                NSLogReleaseObject( string );    } else {       NSLogv( formatString, ap );    }}void NSLogV( NSString *formatString, va_list ap ){ NSLogV2( formatString, ap, YES ); }void NSLogSetButtonState( NSInteger tag, BOOL flag ){ [NSLogGetController() buttonWithTag:tag setStateWithBool:flag]; }void NSLogReleaseObject( id obj ){#if !__has_feature(objc_arc)    [obj release];#endif}#pragma mark - sending messagesvoid NSLog( NSString *formatString, ... ){#if !__has_feature(objc_arc)    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];#endif    va_list ap;    va_start( ap, formatString );    NSLogV( formatString, ap );    va_end( ap );#if !__has_feature(objc_arc)    [pool drain];#endif}void NSLogAlert( NSString *formatString, ... ){#if !__has_feature(objc_arc)    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];#endif    va_list ap;    va_start( ap, formatString );    sNSLogAlert = YES;    NSLogV( formatString, ap );    va_end( ap );#if !__has_feature(objc_arc)    [pool drain];#endif}int printf( const char *format, ... ){    va_list ap;    va_start( ap, format );    NSString *string = [NSString stringWithCString:format encoding:NSMacOSRomanStringEncoding];    NSLogV2( string, ap, NO );    int result = vprintf( format, ap );    va_end( ap );    return result;}#pragma mark - clearing the logvoid NSLogClear(){ [NSLogGetController() clearBtnAction:nil]; }#pragma mark - message appearance and formatvoid NSLogSetShowsDate( BOOL flag ){ NSLogSetButtonState( kNSLogDateBtnTag, flag ); }void NSLogSetShowsTime( BOOL flag ){ NSLogSetButtonState( kNSLogTimeBtnTag, flag ); }void NSLogSetShowsAppName( BOOL flag ){ NSLogSetButtonState( kNSLogAppNameBtnTag, flag ); }void NSLogSetShowsProcessID( BOOL flag ){ NSLogSetButtonState( kNSLogProcessIDBtnTag, flag ); }void NSLogSetFont( NSString *name, CGFloat size ){    NSLogController *controller = NSLogGetController();    NSLogTextView *textView = [controller textView];    if ( name == nil ) name = [[textView font] fontName];    NSFont *font = [NSFont fontWithName:name size:size];    if ( font ) {        [textView setFont:font];            #if !__has_feature(objc_arc)        CFPreferencesSetAppValue( kNSLogFontNameKey, (CFStringRef)name, kNSLogApplicationID );#else        CFPreferencesSetAppValue( kNSLogFontNameKey, (__bridge CFStringRef)name, kNSLogApplicationID );#endif                    CFNumberRef number = CFNumberCreate( kCFAllocatorDefault, kCFNumberCGFloatType, &size );        CFPreferencesSetAppValue( kNSLogFontSizeKey, number, kNSLogApplicationID );        CFRelease( number );        CFPreferencesAppSynchronize( kNSLogApplicationID );    }}void NSLogSetTempFont( NSString *name, CGFloat size ){    NSLogController *controller = NSLogGetController();    NSLogTextView *textView = [controller textView];    if ( name == nil ) name = [[textView font] fontName];    NSFont *font = [NSFont fontWithName:name size:size];    if ( font ) [textView setFont:font];}NSFont *NSLogFont(){ return [[NSLogGetController() textView] font]; }void NSLogRestoreDefaultFont(){ NSLogSetFont( (NSString *)kNSLogDefaultFontName, kNSLogDefaultFontSize ); }#pragma mark - suppressing log outputvoid NSLogSuppress( BOOL flag ){ sNSLogSuppress = flag; }#pragma mark - accessing message textNSString *NSLogString(){ return [[NSLogGetController() textView] string]; }void NSLogWriteToURL( NSURL *url ){ [[[NSLogGetController() textView] string]  writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil]; }void NSLogSave( NSString *message, NSString *filename ){ [NSLogGetController() saveWithMessage:message nameFieldStringValue:filename]; }#pragma mark - windowvoid NSLogSetTitle( NSString *title ){ [[NSLogGetController() window] setTitle:title]; }void NSLogSetFrame( NSRect r ){ [[NSLogGetController() window] setFrame:r display:YES]; }NSRect NSLogFrame(){ return [[NSLogGetController() window] frame]; }void NSLogShow(){    NSLogController *controller = NSLogGetController();    NSLogPanel *controllerWindow = [controller window];    if ( ![controllerWindow isVisible] ) {        [controllerWindow orderFront:nil];        [controllerWindow setFloatingPanel:([[controller buttonWithTag:kNSLogFloatingBtnTag] state] == NSOnState)];    }}void NSLogHide(){ [[NSLogGetController() window] orderOut:nil]; }NSPanel *NSLogWindow(){ return [NSLogGetController() window]; }void NSLogSetFloatingWindow( BOOL flag ){    NSLogSetButtonState( kNSLogFloatingBtnTag, flag );    [[NSLogGetController() window] setFloatingPanel:flag];}void NSLogSetBecomesKeyOnlyIfNeeded( BOOL flag ){ [[NSLogGetController() window] setBecomesKeyOnlyIfNeeded:flag]; }void NSLogSetTerminateAppWhenWindowClosed( BOOL flag ){ [NSLogGetController() setTerminateAppWhenWindowClosed:flag]; }void NSLogScrollToTop(){ [[NSLogGetController() textView] scrollToBeginningOfDocument:nil]; }void NSLogSetTextWrap( BOOL flag ){     NSLogController *controller = NSLogGetController();     [[controller wrapBtn] setState:flag];     [controller setTextWrap:[controller wrapBtn]];}#pragma mark - buttonsvoid NSLogSettingsButtonSetHidden( BOOL flag ){ [[NSLogGetController() settingsBtn] setHidden:flag]; }void NSLogWrapTextButtonSetHidden( BOOL flag ){ [[NSLogGetController() wrapBtn] setHidden:flag]; }void NSLogFindButtonSetHidden( BOOL flag ){ [[NSLogGetController() findBtn] setHidden:flag]; }void NSLogSaveButtonSetHidden( BOOL flag ){ [[NSLogGetController() saveBtn] setHidden:flag]; }void NSLogClearButtonSetHidden( BOOL flag ){ [[NSLogGetController() clearBtn] setHidden:flag]; }void NSLogButtonsSetHidden( BOOL flag ){     NSLogSettingsButtonSetHidden( flag );     NSLogWrapTextButtonSetHidden( flag );     NSLogFindButtonSetHidden( flag );     NSLogSaveButtonSetHidden( flag );     NSLogClearButtonSetHidden( flag );}#pragma mark - consolevoid NSLogSetForwardToConsole( BOOL flag ){ NSLogSetButtonState( kNSLogConsoleBtnTag, flag ); }void NSLogBeginEditing(){ [[[NSLogGetController() textView] textStorage] beginEditing]; }void NSLogEndEditing(){     NSLogTextView *textView = [NSLogGetController() textView];     [[textView textStorage] endEditing];     [textView scrollRangeToVisible:NSMakeRange( [[textView string] length], 0 )];}EndC// FutureBasicBeginCDeclarationvoid nsLog( CFStringRef format, ... );void nsLogV( CFStringRef format, va_list ap );void nsLogAlert( CFStringRef format, ... );void nsLogAlertV( CFStringRef format, va_list ap );#define nsLogSetFont( name, size ) NSLogSetFont( (NSString *)name, size )#define nsLogSetTempFont( name, size ) NSLogSetTempFont( (NSString *)name, size )#define nsLogString() (CFStringRef)NSLogString()#define nsLogWriteToURL( url ) NSLogWriteToURL( (NSURL *)url )#define nsLogSave( message, filename ) NSLogSave( (NSString *)message, (NSString *)filename )#define nsLogSetTitle( title ) NSLogSetTitle( (NSString *)title )#define nsLogSetFrame( r ) NSLogSetFrame( NSRectFromCGRect(r) )#define nsLogFrame() NSRectToCGRect(NSLogFrame())#define nsLogWindow() NSLogWindow()EndCBeginCFunctionvoid nsLog( CFStringRef format, ... ){     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];     va_list ap;     va_start( ap, format );     NSLogV( (NSString *)format, ap );     va_end( ap );     [pool drain];}void nsLogV( CFStringRef format, va_list ap ){ NSLogV( (NSString *)format, ap ); }void nsLogAlert( CFStringRef format, ... ){     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];     va_list ap;     va_start( ap, format );     sNSLogAlert = YES;     NSLogV( (NSString *)format, ap );     va_end( ap );     [pool drain];}void nsLogAlertV( CFStringRef format, va_list ap ){     sNSLogAlert = YES;     NSLogV( (NSString *)format, ap );}EndCsystem CFStringRef NSLogVers/*You may have noticed that some of the following toolbox declarationshave 'ns' prefix, whereas others have 'NS".It's important that they remain as is, so please don't change them.*/// sending messagestoolbox nsLog( CFStringRef format, ... )toolbox nsLogV( CFStringRef format, ptr ap )toolbox nsLogAlert( CFStringRef format, ... )toolbox nsLogAlertV( CFStringRef format, ptr ap )// clear log windowtoolbox NSLogClear// message formattoolbox NSLogSetShowsDate( Boolean flag )toolbox NSLogSetShowsTime( Boolean flag )toolbox NSLogSetShowsAppName( Boolean flag )toolbox NSLogSetShowsProcessID( Boolean flag )toolbox nsLogSetFont( CFStringRef name, CGFloat size )toolbox nsLogSetTempFont( CFStringRef name, CGFloat size )toolbox NSLogRestoreDefaultFont// message texttoolbox fn nsLogString = CFStringReftoolbox nsLogWriteToURL( CFURLRef url )toolbox nsLogSave( CFStringRef message, CFStringRef filename )// suppress outputtoolbox NSLogSuppress( Boolean flag )// log windowtoolbox nsLogSetTitle( CFStringRef title )toolbox nsLogSetFrame( CGRect r )toolbox fn nsLogFrame = CGRecttoolbox NSLogShowtoolbox NSLogHidetoolbox NSLogSetFloatingWindow( Boolean flag )toolbox fn nsLogWindow = ptrtoolbox NSLogSetBecomesKeyOnlyIfNeeded( Boolean flag )toolbox NSLogSetTerminateAppWhenWindowClosed( Boolean flag )toolbox NSLogScrollToToptoolbox NSLogSetTextWrap( Boolean flag )// buttonstoolbox NSLogSettingsButtonSetHidden( Boolean flag )toolbox NSLogWrapTextButtonSetHidden( Boolean flag )toolbox NSLogFindButtonSetHidden( Boolean flag )toolbox NSLogSaveButtonSetHidden( Boolean flag )toolbox NSLogClearButtonSetHidden( Boolean flag )toolbox NSLogButtonsSetHidden( Boolean flag )// consoletoolbox NSLogSetForwardToConsole( Boolean flag )// begin/end editingtoolbox NSLogBeginEditingtoolbox NSLogEndEditing