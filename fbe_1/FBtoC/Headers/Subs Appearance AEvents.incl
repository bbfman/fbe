/*last mod rp 20080203*/BeginCFunction#ifndef DECARBONATEEndCbegin globalsdim gFBAEType  as ResTypedim gFBAEEvent& // as ^AEDesc // keep type-identifier suffix for some existing examples that need itdim gFBAEReply as .AEDescdim gFBAEError as OSErrend globals//    User Apple Event Vectorlocal fn FBAEUserAppleEvent( theAEvent as ^AEDesc, replyEvent as ^AEDesc, handlerRefCon as long ) '~'1gFBAEError = 0gFBAEType  = handlerRefCongFBAEEvent = theAEventgFBAEReply = replyEvent//if gOnAppleEvent& then call AppleEventend fn = gFBAEError//   Add User Apple Event Vectorlocal modelocal fn FBInstallUserAppleEvent( aeClass as ResType, aeType as ResType )'~'1dim as long tempdim as SRefCon  handlerRefcontemp = aeTypehandlerRefcon = tempend fn = fn FBInstallAEHandler( aeClass, aeType, @fn FBAEUserAppleEvent, handlerRefcon, _false)local fn FBAEerror( where as long, err as OSStatus )#if ndef _LP64if err then beep #endif /* ndef _LP64 */ end fn//  GETPROCESSINFO indx,var$[,varPSN]// now FBGetProcessInfo somewhere in FBtoC runtime//   Send an Apple Eventlocal modedim as OSErr  osErrdim curPSN      as ProcessSerialNumberdim thisPSN     as ProcessSerialNumberdim processInfo as ProcessInfoRecdim processName as Str63dim myAEDesc    as AEDescdim ae          as AEDescdim @ same      as Booleanlocal fn FBSendAppleEvent( aeClass as ResType, aeType as ResType, msgPtr as ptr, msgLen as long, toName as Str255 )'~'1if aeClass == 0 then aeClass = _kRequiredEventClassif aeType == 0  then aeType  = _"TEXT"fn GetCurrentProcess( curPSN ) // "can't" failprocessInfo.processInfoLength = sizeof( ProcessInfoRec )processInfo.processName       = (ptr)@processName#if ndef _LP64processInfo.processAppSpec    = 0#endif /* ndef _LP64 */thisPSN.highLongOfPSN = 0 : thisPSN.lowLongOfPSN = _kNoProcessdoosErr = fn GetNextProcess( thisPSN )if osErr then exit fnosErr = fn SameProcess( curPSN, thisPSN, same )if osErr then fn FBAEerror( 1, osErr ): exit fnlong if ( same == _false ) // don't send to selfosErr = fn GetProcessInformation( thisPSN, processInfo )if osErr then fn FBAEerror(2, osErr): exit fnlong if ( toName[0] == 0 or toName == processName ) // send to all or thisPSNosErr = fn AECreateDesc( _"psn ", thisPSN, sizeof( thisPSN ), myAEDesc )if osErr then fn FBAEerror( 3, osErr ): exit fnosErr  = fn AECreateAppleEvent( aeClass, aeType, myAEDesc, _kAutoGenerateReturnID, _kAnyTransactionID, ae )fn AEDisposeDesc( myAEDesc )if osErr then fn FBAEerror( 4, osErr ): exit fn // failed to create appleEventlong if msgPtrosErr = fn AEPutParamPtr( ae, _keyDirectObject, aeType, #msgPtr, msgLen )long if osErrfn AEDisposeDesc( ae )fn FBAEerror( 5, osErr )exit fnend ifend iffn AESend( ae, #_nil, _kAENoReply + _kAEneverInteract, 0,_kAEDefaultTimeout,0,0 )'ARG Date { 9/10/03 }//if osErr then fn FBAEerror( 6, osErr ): exit fn ' get -600 AESend process not found in OS X, but event _is_ sent OKfn AEDisposeDesc( ae )end ifend ifuntil 0end fn/*localdim aeDesc  as AEDescdim theSize as longdim osErr   as OSErrruntime FBGetAEMsgString'~'1gFBStr&.nil` = 0long if gFBAEEventosErr = fn AEGetParamDesc( gFBAEEvent, _keyDirectObject, _"TEXT", aeDesc )long if osErr == _noErr#if CarbonLib // aeDesc.dataHandle is now opaque AEDataStoragetheSize = fn AEGetDescDataSize( aeDesc )long if theSizeif theSize > 255 then theSize = 255osErr = fn AEGetDescData( aeDesc, gFBStr&+1, theSize )gFBStr&.nil` = theSizeend if#elsetheSize = fn GetHandleSize( aeDesc.dataHandle )long if theSizeif theSize > 255 then theSize = 255BlockMove [aeDesc.dataHandle], gFBStr&+1, theSizegFBStr&.nil` = theSizeend if#endifend ifosErr = fn AEDisposeDesc( aeDesc )end ifend fn = gFBStr&*/local fn FBRemoveAppleEvent( aeClass as ResType, aeType as ResType )'~'1end fn = fn AERemoveEventHandler( aeClass, aeType, 0, _false )#if 1 BeginCFunction#endifEndC