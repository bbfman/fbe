// rp 20080120include "Tlbx Icons.incl"_kFBtoCAppSignature = _"FB>C"local modedim @ port as CGrafPtrdim @ w    as WindowReflocal fn SetButtonFocus( btnID as long )'~'1GetPort( @port )w = fn GetWindowFromPort( port )long if ( w )fn SetKeyboardFocus( w, button&( btnID ), _kControlEditTextPart ) end ifend fnlocal fn DrawOneControlAndValidateRect( c as ControlRef )'~'1dim @ port    as CGrafPtrdim w         as WindowRefdim r         as Rectdim portOK    as BooleanGetPort( @port )portOK = _zTrue // was ( gFBBadPort != port )  {21/6/07} RPif portOK then portOK = fn IsValidPort( port )long if portOKw = fn GetWindowFromPort( port )DrawOneControl( c )fn GetControlBounds( c, @r )if w then fn ValidWindowRect( w, r )end ifend fn// helpers// embed one control in another, given their FB button ID numberslocal fn EmbedButton( childID as long, parentsID as long )'~'1dim as OSErr err err = fn EmbedControl(  button&( childID ), button&( parentsID ) )long if errfn RuntimeErrMsg( "EmbedButton error " + str$( err ) + " for button" + str$( childID ) + " in" + str$( parentsID ) )end ifend fn// a wrapper for SetControlData, with btnID, then redraw controllocal fn SetButtonData( btnID as long, part as short, tagName as ResType, size as long, @dPtr as ptr )'~'1dim c     as ControlRefc = button&( btnID )long if cfn SetControlData( c, part, tagName, size, #dPtr )fn DrawOneControlAndValidateRect( c )end ifend fn// set control's text to s, then redraw itlocal fn SetButtonTextString( btnID as long, s as str255 )'~'1dim c     as ControlRefc = button&( btnID )long if cfn SetControlData( c, _kControlEditTextPart, _kControlEditTextTextTag, s[0], s[1] ) fn DrawOneControlAndValidateRect( c )end ifend fn// get up to 255 chars of control's text.   myString = fn ButtonTextString( btnID )local fn ButtonTextString( btnID as long ) as Str255'~'1dim c        as ControlRefdim @ actual as longdim s        as str255s[0] = 0c = button&( btnID )long if cfn GetControlData( c, _kControlEditTextPart, _kControlEditTextTextTag, 255, s[1], actual ) if actual < 255 then s[0] = actual else s[0] = 255end ifend fn = s#if 1// _kFBMenuCF// AppThings.ctoolbox MenuSetTitle( SInt16 menuID, CFStringRef title )toolbox fn MenuCopyTitle( SInt16 menuID ) = CFStringReftoolbox MenuItemSetText( SInt16 menuID, MenuItemIndex item, CFStringRef string )toolbox fn MenuItemCopyText( SInt16 menuID, MenuItemIndex item ) = CFStringRef#endif#if 1// kCFAppWndBtn// AppThings.c//toolbox WindowSetTitle( SInt32 wndNum, CFStringRef title )// 20170923 bw - moved to Rntm Appearance.incl so it can be shared by Carbon and CocoaUI windowstoolbox fn WindowCopyTitle( SInt32 wndNum ) = CFStringReftoolbox ButtonSetText( SInt32 btnNum, CFStringRef string )toolbox fn ButtonCopyText( SInt32 btnNum ) = CFStringRef#endif// just a wrapper for GetControlData, with btnIDlocal fn GetButtonData( btnID as long, part as short, tagName as ResType, maxSize as long, @dPtr as ptr, @actSize as ^long )'~'1dim c     as ControlRefc = button&( btnID )long if cfn GetControlData( c, part, tagName, maxSize, #dPtr, #actSize )end ifend fn// just a wrapper for GetControlDataSize, with btnID.   actSize = fn ButtonDataSize(btnID,part,tagName)local fn ButtonDataSize( btnID as long, part as short, tagName as ResType)'~'1dim c         as ControlRefdim @ actSize as long actSize = 0c = button&( btnID )long if cfn GetControlDataSize( c, part, tagName, @actSize )end ifend fn = actSize// set button's text selection and redrawlocal fn SetButtonTextSelection( btnID as long, selStart as short, selEnd as short )'~'1dim c         as ControlRefdim selection as ControlEditTextSelectionRecc = button&( btnID )long if cselection.selStart = selStartselection.selEnd   = selEndfn SetControlData( c, 0, _kControlEditTextSelectionTag, sizeof( selection ), @selection )fn DrawOneControlAndValidateRect( c )end ifend fn// get button's text selectionlocal fn GetButtonTextSelection( btnID as long, @selStart as ^short, @selEnd as ^short )'~'1dim c     as ControlRefdim selection as ControlEditTextSelectionRecdim @ actual  as longc = button&( btnID )long if clong if selStartlong if selEndfn GetControlData( c, 0, _kControlEditTextSelectionTag, sizeof( selection ), @selection, @actual )selStart.nil% = selection.selStartselEnd.nil%   = selection.selEndend ifend ifend ifend fn/*begin record ControlFontStyleRecdim flags     as shortdim font      as shortdim size      as shortdim style     as shortdim mode      as shortdim just      as shortdim foreColor as RGBColordim backColor as RGBColorend record_kControlUseFontMask_kControlUseFaceMask_kControlUseSizeMask_kControlUseForeColorMask_kControlUseBackColorMask_kControlUseModeMask_kControlUseJustMask*/local fn SetButtonFontStyle( btnID as long, @cfs as ^ControlFontStyleRec )'~'1dim c     as ControlRefc = button&( btnID )long if cfn SetControlFontStyle( c, #cfs )end ifend fnlocal modelocal fn BtnRect( @rPtr as ^Rect, btnNum as long )'~'1fn GetControlBounds( button&( btnNum ), =rPtr )end fnlocal fn FindFBBtnControl( w as WindowRef, butNum as long ) as ControlRef'~'1dim as ControlID    cIDdim as ControlRef   @ c : c = 0cID.signature = _kFBtoCAppSignaturecID.id = butNumcall GetControlByID( w, @cID, @c )end fn = c// whichSubClass parm ignoredlocal fn FBFindEF( efNum as long, subclassUnused as long, w as WindowRef ) as ControlRef'~'1if ( w == 0 ) then get window window( _outputWnd ), w end fn = fn FindFBBtnControl( w, efNum )