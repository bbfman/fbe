/*          -- returns the rectangle of an image fileSpecDEF GetImageSpecRect(fs as ^fsspec , rectPtr as ^rect)          -- converts an image fileSpec to a picture handlepictHandle = USR ImageSpecToPictHandle(fs as ^fsspec)          -- draws an image fileSpec at coordinates 0 , 0 in the current portDEF DrawImageSpec(fs as ^FSSpec)          -- creates a gworld and draws an image fileSpec into it.           -- returns the gworld handle. gworld matches current port          -- you must dispose of gworld when finishedUSR DrawImageSpecToGworld(fs as ^FSSpec)          -- starts with an image fileSpec, draws it into a gworld,          -- uses copybits to convert it into a transparent picture. disposes of gworld. pictHandle = USR ImageSpecToTransparentPictHandle ( fs as ^fsSpec )*//*localdim AS HANDLE                  @myPict dim as GraphicsImportComponent  @grphImpCompdim as FSSpec                   myFileSpecdim as ComponentResult          crsltdim as OSERR                    errruntime usr IMAGEFILETOPICT(fName$,vRef%)'~'myPict = 0long if fn FBMakeFSSpec(vRef%,0,fName$,myFileSpec) = _noErrlong if fn GetGraphicsImporterForFile(myFileSpec, grphImpComp) = _noErrcrslt = FN GraphicsImportGetAsPicture(grphImpComp,myPict)err   = fn CloseComponent(grphImpComp)end ifend ifend fn = myPict*//*     DEF DRAWIMAGEFILE(fName$,vRef%)     Note: Before calling this DEF, you must set up the correct           port with SETPORT, SETGWORLD, WINDOW OUTPUT, etc.*//*localdim AS HANDLE                   @myPict dim as GraphicsImportComponent  @grphImpCompdim as FSSpec                   myFileSpecdim as ComponentResult          crsltdim as OSERR                    errruntime DEF DRAWIMAGEFILE(fName$,vRef%)'~'long if fn FBMakeFSSpec(vRef%,0,fName$,myFileSpec) = _noErrlong if fn GetGraphicsImporterForFile(myFileSpec, grphImpComp) = _noErrcrslt = fn GraphicsImportDraw(grphImpComp)err   = fn CloseComponent(grphImpComp)end ifend ifend fn*//*     DEF GETIMAGEFILERECT(fName$,vRef%,myRect)     This routine returns the rectangle of an image file*//*localdim AS HANDLE                  @myPict dim as GraphicsImportComponent  @grphImpCompdim as FSSpec                   myFileSpecdim as ComponentResult          crsltdim as OSERR                    errruntime DEF GETIMAGEFILERECT(fName$,vRef%,@rectPtr&)'~'long if fn FBMakeFSSpec(vRef%,0,fName$,myFileSpec) = _noErrlong if fn GetGraphicsImporterForFile(myFileSpec, grphImpComp) = _noErrcrslt = fn GraphicsImportGetBoundsRect(grphImpComp, #rectPtr&)err   = fn CloseComponent(grphImpComp)call offsetrect(#rectPtr&,-rectPtr&.left%,-rectPtr&.top%)end ifend ifend fn*//*     cResult = USR CONVERTIMAGEFILE(srcName$,srcRef%,destName$,destRef%,newType&,newCreator&)     This routine returns the rectangle of an image file*//*localdim AS HANDLE                   @myPict dim as GraphicsImportComponent  @grphImpCompdim as FSSpec                   srcSpec,destSpecdim as ComponentResult          crslt, ignoredim as OSERR                    errdim @myScriptTag%dim @newType&dim as boolean                  showDialogdim &runtime usr ConvertImageFile(srcName as str255,srcRef,destName as str255,destRef, newTypeIn&, newCreator& ) // RP 4 Feb 02'~'1crslt = fn FBMakeFSSpec(srcRef,0,srcName, srcSpec)if crslt then exit fnshowDialog = ( destName[0] == 0 ) if showDialog then destName = srcName + " copy"err = fn FBMakeFSSpec(destRef,0,destName, destSpec)if crslt != _noErr and crslt != _fnfErr then exit fncrslt = fn GetGraphicsImporterForFile(srcSpec, grphImpComp)long if crslt == _noErrkill destName, destReflong if showDialogcrslt = fn GraphicsImportDoExportImageFileDialog(grphImpComp,destSpec,"Save image as…",0,newType&,destSpec,myScriptTag%)xelsecrslt = fn GraphicsImportSaveAsPicture(grphImpComp,destSpec,_smSystemScript)end ifignore = fn CloseComponent(grphImpComp)end ifend fn = crslt*//*     cResult = USR SaveImageFileAsPICT(srcName$,srcRef%,destName$,destRef%)     Save Src image to PICT file*//*localdim as GraphicsImportComponent  @grphImpCompdim as FSSpec                   srcSpec,destSpecdim as ComponentResult          crslt, ignoreruntime USR SaveImageFileAsPICT(srcName as str255, srcRef, destName as str255, destRef) // RP 4 Feb 02'~'1crslt = fn FBMakeFSSpec(srcRef,0,srcName, srcSpec)if crslt then exit fncrslt = fn FBMakeFSSpec(destRef,0,destName, destSpec)if crslt != _noErr and crslt != _fnfErr then exit fncrslt = fn GetGraphicsImporterForFile(srcSpec, grphImpComp)long if crslt == _noErrkill destName, destRefcrslt  = fn GraphicsImportSaveAsPicture(grphImpComp,destSpec,_smSystemScript)ignore = fn CloseComponent(grphImpComp)end ifend fn = crslt*//*     DEF GetImageSpecRect(fs as ^FSSpec,myRect)     This routine returns the rectangle of an image file*/localdim as GraphicsImportComponent  @grphImpComplocal fn GetImageSpecRect( fs as ^fsspec, rectPtr as ^rect )'~'dim r as rectlong if fn GetGraphicsImporterForFile(#fs, @grphImpComp) = _noErrfn GraphicsImportGetBoundsRect(grphImpComp, r)fn CloseComponent(grphImpComp)OffsetRect(r,-r.left,-r.top)fn copyrect( r , #rectPtr)xelsefn SetRect ( #rectPtr , 0 , 0 , 0 , 0 )// need some way to tell of failureend ifend fnlocaldim AS HANDLE                  @myPict dim as GraphicsImportComponent  @grphImpComplocal fn ImageSpecToPictHandle(fs as ^fsspec) as Handle'~'myPict = 0long if fn GetGraphicsImporterForFile(#fs, @grphImpComp) = _noErrlong if FN GraphicsImportGetAsPicture(grphImpComp , myPict)myPict = 0end iffn CloseComponent(grphImpComp)end ifend fn = myPictlocaldim as GraphicsImportComponent  @grphImpComplocal fn DrawImageSpec(fs as ^FSSpec)'~'long if fn GetGraphicsImporterForFile(#fs, grphImpComp) = _noErrfn GraphicsImportDraw(grphImpComp)fn CloseComponent(grphImpComp)end ifend fnlocal dim as ptr @ gW , currGW , currDevdim as rect rlocal fn DrawImageSpecToGworld(fs as ^FSSpec) as CGrafPtr'~'9fn GETIMAGESPECRECT(fs , r)gW = 0long if fn EmptyRect ( r ) == _falseOffsetRect ( r , -r.left , -r.top )long if fn NewGWorld( gW , 0 , r , 0 , 0 ,0 ) == _noErrGetGWorld ( currGW , currDev )SetGWorld( gW , 0 )EraseRect ( r )fn DRAWIMAGESPEC( fs )end ifend ifEND FN = gW/*     a graphic file [of any type] is converted     to a picture handle. in this case, i am using     getpict. i may change this to use a param     that allows transparency instead.*//*runtime usr ImageSpecToTransparentPictHandle ( fs as ^fsSpec )'~'9dim as ptr       @ gW , currGW , currDevdim as rect       rdim as handle     pHdim as CGrafPtr  @ portGetGWorld ( currGW , currDev )gW = usr DrawImageSpecToGworld( fs )long if gWdef GetImageSpecRect( fs , r )GetPort( port )ph = fn OpenPicture ( r )CopyBits( #port+2, #port+2, r, r, _srcOr, 0 )ClosePicture()end ifSetGWorld ( currGW , currDev )DisposeGWorld ( gw )end fn = pH*/