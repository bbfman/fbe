/*PollTime1.  IntroductionPollTime is a passive timer for controlling some action thatyou want your program to perform at regular intervals. 'Passive'means that the action taken when the timed interval expires is explicitly written in your program. Unlike On Timer.., PollTimer does not initiate any action itself, or call any part of your program. The onlything that happens on 'firing' of the timer is that fn PollTime returnsthe value _zTrue instead of _false.One use for PollTime might be to control the intervals at whicha progress bar is updated while a long calculation is being done:fn SetupPollTime( 100, _false ) // initialise, and set the timer to fire every 100 mswhile ( myCalculationNotFinished ) // your calculation code goes here  long if fn PollTime   // your code to update a progress bar goes here...   //... and will be executed 10 times per second  end ifwend2.  Setting upBefore calling PollTime, initialise the timer and its interval: fn SetupPollTime( myInterval, _false )A positive value of myInterval is taken to be ms. A negative value of myInterval is negated and taken to be 탎. These two calls have the same effect: fn SetupPollTime( 100, _false ) // 100 ms fn SetupPollTime( -100000, _false ) // 100000 탎 = 100 msThe theoretical range of intervals extends from 1 탎 to 2147483647 ms (just over 24 days).You can call SetupPollTime more than once in your program, either to resetthe timer or to set a different interval. The timer always starts immediately at the call to SetupPollTime.Important note: If you forget to call SetupPollTime at least once, PollTime will crash.3.  Polling to find if the interval has expiredOnce the timer has been set up, your program can call PollTime to find if the timer has 'fired'.  PollTime returns _false (0) if the interval has not yet expired, and _zTrue (-1) if it has expired. In the latter case, the timer is automatically reset, ready for the next interval.4.  What's special about PollTime?When the interval has not expired, PollTime returns (with the value _false) *very* quickly. On a 466 MHz G4, the code snippet:  long if ( fn PollTime )   // do nothing  end ifexecutes in only 44 ns. You can therefore poll the timer at a high rate(millions of times per second) without slowing things down. This is much faster than alternative timers such as GetDateTime, TickCount or Microseconds, which are dismally slow in OS X.The timer obtained by [_time] is faster than PollTime, but is not availablein Carbon, and its usefulness is limited by a fixed resolution of 1 s.5.  How accurate is PollTime?PollTime uses the processor's time base registers, which form the most precise and accurate timer possible on a Mac. In practice, the accuracy of the interval depends on how often you test fn PollTime. In a tight 'spin-loop':  fn SetupPollTime( myInterval, _false )  do  until ( fn PollTime ) // wait until timer firesyou are likely to be polling at many MHz, and so the accuracy will be better than 1 탎.In OS X, other processes, especially those that use the disk (for instance Sherlock indexing) may cause quite large interruptions which will worsen the accuracy.6.  PollTime looks like a neat method to implement a delay, right?Not really. An occasional short delay is no problem:  fn SetupPollTime2( 30, _false )  do  until ( fn PollTime )But a long delay such as:  fn SetupPollTime2( 30000, _false )  do  until ( fn PollTime )will cause the CPU to glow cherry red, spool up the cooling fans,and spray molten copper or liquid sodium around the innards of the computer :-) A 'busy wait' or spin-loop like this is Bad Form. Use FB's delay statement instead, which makes your app sleep peacefully while giving time to other processes.7.  What about drift-free timing?Normally you pass _false as the second parameter to SetupPollTime   fn SetupPollTime( myInterval, _false ).For drift-free timing, pass _zTrue:  fn SetupPollTime( myInterval, _zTrue )In most uses of PollTime, drift-free timing offers no advantage. If you are contemplating drift-free timing, make sure that you understand these scenarios: 1  fn SetupPollTime( 500, _false ) // 500 ms, not drift-free 2  Oops, your program for some reason fails to call PollTime for (say) 4.6 s. 3  When your program returns to life, the first call to fn PollTime returns _zTrue    because the 500 ms interval has expired. 4  Subsequent calls to fn PollTime return _false until 500 ms after the time at     step 3.  PollTime retained no memory of the original set-up time,     and did not attempt to compensate for lost intervals. 1  fn SetupPollTime( 500, _zTrue ) // 500 ms drift-free 2  Oops, your program for some reason fails to call PollTime for (say) 4.6 s. 3  When your program returns to life, the first call to fn PollTime returns _zTrue    because the 500 ms interval has expired. 4  The next 8 calls to fn PollTime also return _zTrue, while PollTime 'catches up'     on the lost time. 5  Subsequent calls to fn PollTime return _false until 5 s after the time at step 1;    the 10th drift-free interval expires exactly 5 s after set-up.8.  To add a second independent timer, put  _usePollTime2 = 1 // any value whatsoeverin your source before the include statement:  include "Subs PollTime.Incl"Then use it like this:  fn SetupPollTime2( myInterval, _false )  long if ( fn PollTime2 )   ...   end ifRobert P.  30 June 2002Modified   7 July 2003   protected from the debugger (which otherwise freezes on a call to PollTime)          16 Sept 2004   added an optional second timer          22 Sept 2007   FBtoC compatibility          20091212       uses BeginCxxx / EndC*/ toolbox fn UpTime() = UInt64 // returns 'AbsoluteTime', i.e. PPC processor timeBeginCFunctionAbsoluteTime sPollNextTime;Duration     sPollInterval;FBBoolean    sPollDriftFree;endClocal fn SetupPollTime( interval as Duration, driftFree as Boolean )'~'1beginCCodesPollDriftFree = driftFree;sPollInterval = interval;sPollNextTime = AddDurationToAbsolute( interval, UpTime() );endCend fnlocal fn PollTime'~'1beginCCodeAbsoluteTime now = UpTime();if ( UnsignedWideToUInt64( now ) > UnsignedWideToUInt64( sPollNextTime ) ){ if ( sPollDriftFree ) { now = sPollNextTime; }sPollNextTime = AddDurationToAbsolute( sPollInterval, now );return -1; }endCend fn = 0 // default return 0//#if def _usePollTime2BeginCFunctionAbsoluteTime sPollNextTime2;Duration     sPollInterval2;FBBoolean    sPollDriftFree2;endClocal fn SetupPollTime2( interval as Duration, driftFree as Boolean )'~'1beginCCodesPollDriftFree2 = driftFree;sPollInterval2 = interval;sPollNextTime2 = AddDurationToAbsolute( interval, UpTime() );endCend fnlocal fn PollTime2'~'1beginCCodeAbsoluteTime now = UpTime();if ( UnsignedWideToUInt64( now ) > UnsignedWideToUInt64( sPollNextTime2 ) ){ if ( sPollDriftFree2 ) { now = sPollNextTime2; }sPollNextTime2 = AddDurationToAbsolute( sPollInterval2, now );return -1; }endCend fn = 0 // default return 0//#endif // def _usePollTime2