// parm mods    15 August 2007    bw//-----------------------------------------------------------------------////                                                                       ////   FB^3 Sound routines syntax and functionaly compatable with FB II    ////                                                                       ////   SOUND "resName"                                                     ////   SOUND %resID                                                        ////   SOUND &Handle&                                                      ////   SOUND END                                                           ////   x = SOUND%                                                          ////                                                                       ////-----------------------------------------------------------------------////include "Tlbx Sound.incl"begin globalsdim gFBSndHndl as Handle to SndListResourcedim gFBSndCmd as SndCommanddim gFBSndChanPtr as SndChannelPtr#if ndef _DEFINEDINCRUNTIMEdim gFBSndBusy as Boolean // volatile in *c runtime#endifend globalslocal fn FBSndProc( unusedChandPtr as SndChannelPtr, unusedSndCmd as ^SndCommand )'~'1gFBSndBusy = _falseend fn////  FB^3: SOUND END//local fn FBSoundEnd'~'1long if gFBSndHndlfn SndDisposeChannel( gFBSndChanPtr, _zTrue )end ifgFBSndBusy = _false// Sound Doneend fn////  play sound in gFBSndChanPtr&//local fn FBPlaySoundHandle'~'1long if gFBSndHndlgFBSndChanPtr = 0fn SndNewChannel( @gFBSndChanPtr, _SampledSynth, 0, (ptr)@fn FBSndProc )fn SndPlay( gFBSndChanPtr, gFBSndHndl, _zTrue)gFBSndCmd.cmd = 13gFBSndBusy = _zTruefn SndDoCommand( gFBSndChanPtr, gFBSndCmd, 0 )end ifend fn//  SOUND %id  // Type 3//  SOUND &Hndl& // Type 2//  SOUND "name" // Type 1local fn FBSoundType1( unusedSoundType&, soundPtr as ptr)'~'1dim tempString as str255while SOUND%// Wait til last sound completedelay 17wendSOUND end// Dispose if neededgFBSndHndl = 0// No Handleblockmove soundPtr, @tempString, 256gFBSndHndl = fn GetNamedResource( _"snd ", tempString)fn FBPlaySoundHandleend fnlocal fn FBSound( SoundType&, soundRef as long )'~'1dim as short resNumwhile SOUND%// Wait til last sound completedelay 17wendSOUND end// Dispose if neededgFBSndHndl = 0// No Handleselect  SoundType&case 1:case 2: gFBSndHndl = soundReffn FBPlaySoundHandlecase 3: resNum = soundRef : gFBSndHndl = fn GetResource( _"snd ", resNum )fn FBPlaySoundHandleend selectend fn////  SOUND StringExpression//local fn FBSoundStrExpr( @soundPtr as ptr )'~'1dim as Str255 tempStringwhile SOUND%// Wait til last sound completedelay 17wendSOUND endselectcase {soundPtr} == 0x0300 + _"%"gFBSndHndl = fn GetResource( _"snd ", {soundPtr+2} )case {soundPtr} == 0x0500 + _"&"gFBSndHndl = [soundPtr + 2]case elseBlockMove soundPtr, @tempString, 8gFBSndHndl = fn GetNamedResource( _"snd ", tempString )end selectfn FBPlaySoundHandleend fn//  SOUND frequency,Duration[,volume[,async]]//  frequency    Required     actual frequency in Hz//  Duration     Required     0 to 255 in 1/60 second steps...//  Volume       Optional     0 to 127               Default 127//  Async        Optional     0=Sync else Async      Default 0local fn SoundFreqDur( freq&, dur&, vol&, async& )'~'1dim as OSErr err dim mySndCmd as SndCommandlong if gFBSndChanPtrmySndCmd.cmd = _quietCmdfn SndDoImmediate( gFBSndChanPtr, mySndCmd )fn SndDisposeChannel( gFBSndChanPtr, _zTrue )end ifgFBSndChanPtr = 0err = fn SndNewChannel( @gFBSndChanPtr, _squarewaveSynth, 0, proc "FBSndProc" )long if errexit fnend ifgFBSndCmd.cmd = _ampcmdgFBSndCmd.param1 = (vol& << 1)//convert 0-127 to 0-255gFBSndCmd.param2 = 0//not usedfn SndDoCommand( gFBSndChanPtr, gFBSndCmd, async& )long if freq& < 0//midi note valuefreq& = -freq&xelsefreq& = 60.0 + int((log(freq&) - 5.56691)/ 0.057762265)end ifgFBSndCmd.cmd = _freqDurationCmdgFBSndCmd.param1 = dur& * 33//convert tks to half millisecondsgFBSndCmd.param2  = freq&err = fn SndDoCommand( gFBSndChanPtr, gFBSndCmd, async& )long if errexit fnend ifgFBSndCmd.cmd = _callbackcmdgFBSndBusy = _zTrue// Sound Busyerr = fn SndDoCommand( gFBSndChanPtr, gFBSndCmd, async& )long if errexit fnend iflong if async& == _falsedodelay 17until gFBSndBusy == _falseend ifend fn