/*   20091001   Bernie Wylde*//* CFStream.h Copyright (c) 2000-2009, Apple Inc. All rights reserved.*/include "Tlbx CFRunLoop.incl"include "Tlbx CFSocket.incl"#if ndef _DEFINEDINCARBONbegin enum_kCFStreamStatusNotOpen  = 0_kCFStreamStatusOpening/* open is in-progress */_kCFStreamStatusOpen_kCFStreamStatusReading_kCFStreamStatusWriting_kCFStreamStatusAtEnd /* no further bytes can be read/written */_kCFStreamStatusClosed_kCFStreamStatusErrorend enum#define CFStreamStatus as CFIndexbegin enum_kCFStreamEventNone              = 0_kCFStreamEventOpenCompleted     = 1_kCFStreamEventHasBytesAvailable = 2_kCFStreamEventCanAcceptBytes    = 4_kCFStreamEventErrorOccurred     = 8_kCFStreamEventEndEncountered    = 16end enum#define CFStreamEventType as CFOptionFlagsbegin record CFStreamClientContextdim as CFIndex     versiondim as pointer     infodim as pointer     retaindim as pointer     releasedim as CFStringRef copyDescriptionend record#define CFReadStreamRef as pointer#define CFWriteStreamRef as pointer#define CFReadStreamClientCallBack as pointer#define CFWriteStreamClientCallBack as pointertoolbox fn CFReadStreamGetTypeID() = CFTypeIDtoolbox fn CFWriteStreamGetTypeID() = CFTypeID/* Memory streams *//* Value will be a CFData containing all bytes thusfar written; used to recover the data written to a memory write stream. */system CFStringRef kCFStreamPropertyDataWritten/* Pass kCFAllocatorNull for bytesDeallocator to prevent CFReadStream from deallocating bytes; otherwise, CFReadStream will deallocate bytes when the stream is destroyed */toolbox fn CFReadStreamCreateWithBytesNoCopy( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator ) = CFReadStreamRef/* The stream writes into the buffer given; when bufferCapacity is exhausted, the stream is exhausted (status becomes kCFStreamStatusAtEnd) */toolbox fn CFWriteStreamCreateWithBuffer( CFAllocatorRef alloc, UInt8 *buffer, CFIndex bufferCapacity ) = CFWriteStreamRef/* New buffers are allocated from bufferAllocator as bytes are written to the stream. At any point, you can recover the bytes thusfar written by asking for the property kCFStreamPropertyDataWritten, above */toolbox fn CFWriteStreamCreateWithAllocatedBuffers( CFAllocatorRef alloc, CFAllocatorRef bufferAllocator ) = CFWriteStreamRef/* File streams */toolbox fn CFReadStreamCreateWithFile( CFAllocatorRef alloc, CFURLRef fileURL ) = CFReadStreamReftoolbox fn CFWriteStreamCreateWithFile( CFAllocatorRef alloc, CFURLRef fileURL ) = CFWriteStreamReftoolbox CFStreamCreateBoundPair( CFAllocatorRef alloc, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream, CFIndex transferBufferSize )/* Property for file write streams; value should be a CFBoolean. Set to TRUE to append to a file, rather than to replace its contents */system CFStringRef kCFStreamPropertyAppendToFile/* Socket stream properties *//* Value will be a CFData containing the native handle */system CFStringRef kCFStreamPropertySocketNativeHandle/* Value will be a CFString, or NULL if unknown */system CFStringRef kCFStreamPropertySocketRemoteHostName/* Value will be a CFNumber, or NULL if unknown */system CFStringRef kCFStreamPropertySocketRemotePortNumber/* Socket streams; the returned streams are paired such that they use the same socket; pass NULL if you want only the read stream or the write stream */toolbox CFStreamCreatePairWithSocket( CFAllocatorRef alloc, CFSocketNativeHandle sock, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream )toolbox CFStreamCreatePairWithSocketToHost( CFAllocatorRef alloc, CFStringRef host, UInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream )toolbox CFStreamCreatePairWithPeerSocketSignature( CFAllocatorRef alloc, const CFSocketSignature *signature, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream )/* Returns the current state of the stream */toolbox fn CFReadStreamGetStatus( CFReadStreamRef stream ) = CFStreamStatustoolbox fn CFWriteStreamGetStatus( CFWriteStreamRef stream ) = CFStreamStatus/* Returns NULL if no error has occurred; otherwise returns the error. */toolbox fn CFReadStreamCopyError( CFReadStreamRef stream ) = CFErrorRef//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;toolbox fn CFWriteStreamCopyError( CFWriteStreamRef stream ) = CFErrorRef//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Returns success/failure. Opening a stream causes it to reserve all the system resources it requires. If the stream can open non-blocking, this will always  return TRUE; listen to the run loop source to find out when the open completes and whether it was successful, or poll using CFRead/WriteStreamGetStatus(), waiting for a status of kCFStreamStatusOpen or kCFStreamStatusError. */toolbox fn CFReadStreamOpen( CFReadStreamRef stream ) = Booleantoolbox fn CFWriteStreamOpen( CFWriteStreamRef stream ) = Boolean/* Terminates the flow of bytes; releases any system resources required by the  stream. The stream may not fail to close. You may call CFStreamClose() to effectively abort a stream. */toolbox CFReadStreamClose( CFReadStreamRef stream )toolbox CFWriteStreamClose( CFWriteStreamRef stream )/* Whether there is data currently available for reading; returns TRUE if it's impossible to tell without trying */toolbox fn CFReadStreamHasBytesAvailable( CFReadStreamRef stream ) = Boolean/* Returns the number of bytes read, or -1 if an error occurs preventing any  bytes from being read, or 0 if the stream's end was encountered.  It is an error to try and read from a stream that hasn't been opened first.  This call will block until at least one byte is available; it will NOT block until the entire buffer can be filled. To avoid blocking, either poll using CFReadStreamHasBytesAvailable() or use the run loop and listen for the kCFStreamCanRead event for notification of data available. */toolbox fn CFReadStreamRead( CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength ) = CFIndex/* Returns a pointer to an internal buffer if possible (setting *numBytesRead to the length of the returned buffer), otherwise returns NULL; guaranteed  to return in O(1). Bytes returned in the buffer are considered read from  the stream; if maxBytesToRead is greater than 0, not more than maxBytesToRead will be returned. If maxBytesToRead is less than or equal to zero, as many bytes as are readily available will be returned. The returned buffer is good only  until the next stream operation called on the stream. Caller should neither  change the contents of the returned buffer nor attempt to deallocate the buffer;it is still owned by the stream. */toolbox fn CFReadStreamGetBuffer( CFReadStreamRef stream, CFIndex maxBytesToRead, CFIndex *numBytesRead ) = pointer/* Whether the stream can currently be written to without blocking;returns TRUE if it's impossible to tell without trying */toolbox fn CFWriteStreamCanAcceptBytes( CFWriteStreamRef stream ) = Boolean/* Returns the number of bytes successfully written, -1 if an error has occurred, or 0 if the stream has been filled to capacity (for fixed-length streams). If the stream is not full, this call will block until at least one byte is written. To avoid blocking, either poll via CFWriteStreamCanAcceptBytesor use the run loop and listen for the kCFStreamCanWrite event. */toolbox fn CFWriteStreamWrite( CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength ) = CFIndex/* Particular streams can name properties and assign meanings to them; you access these properties through the following calls. A property is any interesting information about the stream other than the data being transmitted itself. Examples include the headers from an HTTP transmission, or the expected  number of bytes, or permission information, etc. Properties that can be set configure the behavior of the stream, and may only be settable at particular times (like before the stream has been opened). See the documentation for particular properties to determine their get- and set-ability. */toolbox fn CFReadStreamCopyProperty( CFReadStreamRef stream, CFStringRef propertyName ) = CFTypeReftoolbox fn CFWriteStreamCopyProperty( CFWriteStreamRef stream, CFStringRef propertyName ) = CFTypeRef/* Returns TRUE if the stream recognizes and accepts the given property-value pair; FALSE otherwise. */toolbox fn CFReadStreamSetProperty( CFReadStreamRef stream, CFStringRef propertyName, CFTypeRef propertyValue ) = Booleantoolbox fn CFWriteStreamSetProperty( CFWriteStreamRef stream, CFStringRef propertyName, CFTypeRef propertyValue ) = Boolean/* Asynchronous processing - If you wish to neither poll nor block, you may register  a client to hear about interesting events that occur on a stream. Only one client per stream is allowed; registering a new client replaces the previous one. Once you have set a client, you need to schedule a run loop on which that client can be notified. You may schedule multiple run loops (for instance, if you are  using a thread pool). The client callback will be triggered via one of the scheduled run loops; It is the caller's responsibility to ensure that at least one of the  scheduled run loops is being run. NOTE: Unlike other CoreFoundation APIs, pasing a NULL clientContext here will remove the client. If you do not care about the client context (i.e. your only concern is that your callback be called), you should pass in a valid context where every entry is 0 or NULL.*/toolbox fn CFReadStreamSetClient( CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext ) = Booleantoolbox fn CFWriteStreamSetClient( CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext ) = Booleantoolbox CFReadStreamScheduleWithRunLoop( CFReadStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode )toolbox CFWriteStreamScheduleWithRunLoop( CFWriteStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode )toolbox CFReadStreamUnscheduleFromRunLoop( CFReadStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode )toolbox CFWriteStreamUnscheduleFromRunLoop( CFWriteStreamRef stream, CFRunLoopRef runLoop, CFStringRef runLoopMode )/* The following API is deprecated starting in 10.5; please use CFRead/WriteStreamCopyError(), above, instead */begin enum_kCFStreamErrorDomainCustom      = -1 /* custom to the kind of stream in question */_kCFStreamErrorDomainPOSIX       = 1 /* POSIX errno; interpret using <sys/errno.h> */_kCFStreamErrorDomainMacOSStatus /* OSStatus type from Carbon APIs; interpret using <MacTypes.h> */end enum#define CFStreamErrorDomain as CFIndexbegin record CFStreamErrordim as CFIndex  domaindim as SInt32   errorend recordtoolbox fn CFReadStreamGetError( CFReadStreamRef stream ) = CFStreamErrortoolbox fn CFWriteStreamGetError( CFWriteStreamRef stream ) = CFStreamError#endif// ndef _DEFINEDINCARBON