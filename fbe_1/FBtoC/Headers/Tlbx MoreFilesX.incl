/*toolbox header for the file manager v.1.1Change: #define QElemPtr as Pointer to QElemto:     #define QElemPtr as Pointer                    Alain   ( 29/11/03 }*/include "Tlbx CarbonEvents.incl"#if ndef _DEFINEDINCARBONbegin record widedim hi as SInt32dim lo as UInt32end recordbegin enum_kUTCDefaultOptions = 0end enum// 64 Bit Clock Typedefs begin record UTCDateTimedim highSeconds as UInt16dim lowSeconds  as UInt32dim fraction    as UInt16end record#define UTCDateTimePtr    as pointer //.UTCDateTime#define UTCDateTimeHandle as Handle //..UTCDateTimebegin record LocalDateTimedim highSeconds as UInt16dim lowSeconds  as UInt32dim fraction    as UInt16end record#define LocalDateTimePtr    as pointer // .LocalDateTime#define LocalDateTimeHandle as Handle // ..LocalDateTimetoolbox fn ConvertUTCToLocalTime( UInt32 utcSeconds, UInt32 * localSeconds) = OSStatustoolbox fn ConvertLocalTimeToUTC( UInt32 localSeconds, UInt32 * utcSeconds) = OSStatustoolbox fn ConvertUTCToLocalDateTime( const UTCDateTime * utcDateTime, LocalDateTime * localDateTime) = OSStatustoolbox fn ConvertLocalToUTCDateTime( const LocalDateTime * localDateTime, UTCDateTime * utcDateTime) = OSStatustoolbox fn GetUTCDateTime( UTCDateTime * utcDateTime, OptionBits options) = OSStatustoolbox fn SetUTCDateTime( const UTCDateTime * utcDateTime, OptionBits options) = OSStatustoolbox fn GetLocalDateTime( LocalDateTime * localDateTime, OptionBits options) = OSStatustoolbox fn SetLocalDateTime( const LocalDateTime * localDateTime, OptionBits options) = OSStatusbegin enum_kIsOnDesk      = 0x0001// Files and folders (System 6) _kColor         = 0x000E// Files and folders // bit 0x0020 was_kRequireSwitchLaunch but is now reserved for future use_kIsShared      = 0x0040// Files only (Applications only) // If clear the application needs to write to // its resource fork and therefore cannot be // shared on a server _kHasNoINITs    = 0x0080// Files only (Extensions/Control Panels only) // This file contains no INIT resource _kHasBeenInited = 0x0100// Files only // Clear if the file contains desktop database // resources ('BNDL' 'FREF' 'open' 'kind'...) // that have not been added yet. Set only by the Finder // Reserved for folders - make sure this bit is cleared for folders // bit 0x0200 was the letter bit for AOCE but is now reserved for future use _kHasCustomIcon = 0x0400// Files and folders _kIsStationery  = 0x0800// Files only _kNameLocked    = 0x1000// Files and folders _kHasBundle     = 0x2000// Files only _kIsInvisible   = 0x4000// Files and folders _kIsAlias       = 0x8000// Files only end enumbegin enum_kExtendedFlagsAreInvalid    = 0x8000// If set the other extended flags are ignored _kExtendedFlagHasCustomBadge = 0x0100// Set if the file or folder has a badge resource _kExtendedFlagHasRoutingInfo = 0x0004// Set if the file contains routing info resource end enumbegin record FileInfodim fileType      as OSType// The type of the file dim fileCreator   as OSType// The file's creator dim finderFlags   as UInt16// ex: kHasBundle, kIsInvisible... dim location      as Point// File's location in the folder If set to {0, 0}, the Finder will place the item automatically dim reservedField as UInt16// (set to 0) end recordbegin record FolderInfodim windowBounds  as Rect// The position and dimension of the folder's window dim finderFlags   as UInt16// ex. kIsInvisible, kNameLocked, etc.dim location      as Point// Folder's location in the parent folder If set to {0, 0}, the Finder will place the item automatically dim reservedField as UInt16// (set to 0) end recordbegin record ExtendedFileInfodim reserved1[3]        as SInt16// Reserved (set to 0) dim extendedFinderFlags as UInt16// Extended flags (custom badge, routing info...) dim reserved2           as SInt16// Reserved (set to 0). Comment ID if high-bit is clear dim putAwayFolderID     as SInt32// Put away folder ID end recordbegin record ExtendedFolderInfodim scrollPosition      as Point// Scroll position (for icon views) dim reserved1           as SInt32// Reserved (set to 0) dim extendedFinderFlags as UInt16// Extended flags (custom badge, routing info...) dim reserved2           as SInt16// Reserved (set to 0). Comment ID if high-bit is clear dim putAwayFolderID     as SInt32// Put away folder ID end recordbegin record QElemdim qLink    as Pointer// TO QElemdim qType    as shortdim qData[1] as shortend record#define QElemPtr as Pointer// To QElembegin record HFileInfodim qLink         as QElemPtr// queue link in headerdim qType         as short// type byte for safety checkdim ioTrap        as short// FS: the Trapdim ioCmdAddr     as pointer// FS: address to dispatch todim ioCompletion  as pointer// IOCompletionUPP completion routine addr (0 for synch calls)dim ioResult      as OSErr// result codedim ioNamePtr     as pointer// ptr to Vol:FileName stringdim ioVRefNum     as short// volume refnum (DrvNum for Eject and MountVol)dim ioFRefNum     as shortdim ioFVersNum    as SInt8dim filler1       as SInt8dim ioFDirIndex   as shortdim ioFlAttrib    as SInt8dim ioACUser      as SInt8dim ioFlFndrInfo  as FInfodim ioDirID       as longdim ioFlStBlk     as unsigned shortdim ioFlLgLen     as longdim ioFlPyLen     as longdim ioFlRStBlk    as unsigned shortdim ioFlRLgLen    as longdim ioFlRPyLen    as longdim ioFlCrDat     as unsigned longdim ioFlMdDat     as unsigned longdim ioFlBkDat     as unsigned longdim ioFlXFndrInfo as FXInfodim ioFlParID     as longdim ioFlClpSiz    as longend recordbegin record DirInfodim qLink        as QElemPtr// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as pointer// IOCompletionUPP completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioFRefNum    as shortdim ioFVersNum   as SInt8dim filler1      as SInt8dim ioFDirIndex  as shortdim ioFlAttrib   as SInt8dim ioACUser     as SInt8dim ioDrUsrWds   as DInfodim ioDrDirID    as longdim ioDrNmFls    as unsigned shortdim filler3[8]   as SInt16dim ioDrCrDat    as unsigned longdim ioDrMdDat    as unsigned longdim ioDrBkDat    as unsigned longdim ioDrFndrInfo as DXInfodim ioDrParID    as longend recordbegin record CInfoPBRecbegin uniondim hFileInfo as HFileInfodim dirInfo   as DirInfoend unionend record_bSupportsAsyncRequests        = 3// asynchronous requests to this volume are handled correctly at any time_bSupportsTrashVolumeCache     = 2begin enum// vMExtendedAttributes (GetVolParms) bit position constants_bIsEjectable               = 0// volume is in an ejectable disk drive_bSupportsHFSPlusAPIs       = 1// volume supports HFS Plus APIs directly (not through compatibility layer)_bSupportsFSCatalogSearch   = 2// volume supports FSCatalogSearch_bSupportsFSExchangeObjects = 3// volume supports FSExchangeObjects_bSupports2TBFiles          = 4// volume supports supports 2 terabyte files_bSupportsLongNames         = 5// volume supports file/directory/volume names longer than 31 characters_bSupportsMultiScriptNames  = 6// volume supports file/directory/volume names with characters from multiple script systems_bSupportsNamedForks        = 7// volume supports forks beyond the data and resource forks_bSupportsSubtreeIterators  = 8// volume supports recursive iterators not at the volume root_bL2PCanMapFileBlocks       = 9// volume supports Lg2Phys SPI correctlyend enumbegin enum// vMExtendedAttributes (GetVolParms) bit position constants_bParentModDateChanges   = 10// Changing a file or folder causes its parent's mod date to change_bAncestorModDateChanges = 11// Changing a file or folder causes all ancestor mod dates to changeend enumbegin enum// vMExtendedAttributes (GetVolParms)_bit position constants_bSupportsSymbolicLinks = 13// volume supports the creation and use of symbolic links (Mac OS X only)_bIsAutoMounted         = 14// volume was mounted automatically (Mac OS X only)_bAllowCDiDataHandler   = 17// allow QuickTime's CDi data handler to examine this volumeend enumbegin enum_kioACUserNoSeeFolderBit       = 0// Set if user does not have See Folder privileges_kioACUserNoSeeFolderMask      = 0x01_kioACUserNoSeeFilesBit        = 1// Set if user does not have See Files privileges_kioACUserNoSeeFilesMask       = 0x02_kioACUserNoMakeChangesBit     = 2// Set if user does not have Make Changes privileges_kioACUserNoMakeChangesMask    = 0x04_kioACUserNotOwnerBit          = 7// Set if user is not owner of the directory_kioACUserNotOwnerMask         = 0x80end enum// Folder and File values of access privileges in ioACAccessbegin enum_kioACAccessOwnerBit           = 31// User is owner of directory_kioACAccessOwnerMask          = 0x80000000_kioACAccessBlankAccessBit     = 28// Directory has blank access privileges_kioACAccessBlankAccessMask    = 0x10000000_kioACAccessUserWriteBit       = 26// User has write privileges_kioACAccessUserWriteMask      = 0x04000000_kioACAccessUserReadBit        = 25// User has read privileges_kioACAccessUserReadMask       = 0x02000000_kioACAccessUserSearchBit      = 24// User has search privileges_kioACAccessUserSearchMask     = 0x01000000_kioACAccessEveryoneWriteBit   = 18// Everyone has write privileges_kioACAccessEveryoneWriteMask  = 0x00040000_kioACAccessEveryoneReadBit    = 17// Everyone has read privileges_kioACAccessEveryoneReadMask   = 0x00020000_kioACAccessEveryoneSearchBit  = 16// Everyone has search privileges_kioACAccessEveryoneSearchMask = 0x00010000_kioACAccessGroupWriteBit      = 10// Group has write privileges_kioACAccessGroupWriteMask     = 0x00000400_kioACAccessGroupReadBit       = 9// Group has read privileges_kioACAccessGroupReadMask      = 0x00000200_kioACAccessGroupSearchBit     = 8// Group has search privileges_kioACAccessGroupSearchMask    = 0x00000100_kioACAccessOwnerWriteBit      = 2// Owner has write privileges_kioACAccessOwnerWriteMask     = 0x00000004_kioACAccessOwnerReadBit       = 1// Owner has read privileges_kioACAccessOwnerReadMask      = 0x00000002_kioACAccessOwnerSearchBit     = 0// Owner has search privileges_kioACAccessOwnerSearchMask    = 0x00000001_kfullPrivileges               = 0x00070007// all privileges for everybody and owner_kownerPrivileges              = 0x00000007// all privileges for owner onlyend enumbegin record IOParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioRefNum     as short// refNum for I/O operationdim ioVersNum    as SInt8// version numberdim ioPermssn    as SInt8// Open: permissions (byte)dim ioMisc       as pointer// Rename: new name (GetEOF,SetEOF: logical end of file) (Open: optional ptr to buffer) (SetFileType: new type)dim ioBuffer     as pointer// data buffer Ptrdim ioReqCount   as long// requested byte count; also = ioNewDirIDdim ioActCount   as long// actual byte count completeddim ioPosMode    as short// initial file positioningdim ioPosOffset  as long// file position offsetend recordbegin record FileParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as  pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioFRefNum    as short// reference numberdim ioFVersNum   as SInt8// version numberdim filler1      as SInt8dim ioFDirIndex  as short// GetFInfo directory indexdim ioFlAttrib   as SInt8// GetFInfo: in-use bit=7, lock bit=0dim ioFlVersNum  as SInt8// file version numberdim ioFlFndrInfo as FInfo// user infodim ioFlNum      as unsigned long// GetFInfo: file number; TF- ioDirIDdim ioFlStBlk    as unsigned short// start file block (0 if none)dim ioFlLgLen    as long// logical length (EOF)dim ioFlPyLen    as long// physical lengthdim ioFlRStBlk   as unsigned short// start block rsrc forkdim ioFlRLgLen   as long// file logical length rsrc forkdim ioFlRPyLen   as long// file physical length rsrc forkdim ioFlCrDat    as unsigned long// file creation date& time (32 bits in secs)dim ioFlMdDat    as unsigned long// last modified date and timeend recordbegin record VolumeParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim filler2      as longdim ioVolIndex   as short// volume index numberdim ioVCrDate    as unsigned long// creation date and timedim ioVLsBkUp    as unsigned long// last backup date and timedim ioVAtrb      as unsigned short// volume attribdim ioVNmFls     as unsigned short// number of files in directorydim ioVDirSt     as unsigned short// start block of file directorydim ioVBlLn      as short// GetVolInfo: length of dir in blocksdim ioVNmAlBlks  as unsigned short// for compatibilty ioVNmAlBlks * ioVAlBlkSiz <= 2 GBdim ioVAlBlkSiz  as unsigned long// for compatibilty ioVAlBlkSiz is <= $0000FE00 (65,024)dim ioVClpSiz    as unsigned long// GetVolInfo: bytes to allocate at a timedim ioAlBlSt     as unsigned short// starting disk(512-byte) block in block mapdim ioVNxtFNum   as unsigned long// GetVolInfo: next free file numberdim ioVFrBlk     as unsigned short// GetVolInfo: # free alloc blks for this volend recordbegin record CntrlParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioCRefNum    as short// refNum for I/O operationdim csCode       as short// word for control status codedim csParam[10]  as short// operation-defined parametersend recordbegin record SlotDevParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioSRefNum    as shortdim ioSVersNum   as SInt8dim ioSPermssn   as SInt8dim ioSMix       as pointerdim ioSFlags     as shortdim ioSlot       as SInt8dim ioID         as SInt8end recordbegin record MultiDevParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioMRefNum    as shortdim ioMVersNum   as SInt8dim ioMPermssn   as SInt8dim ioMMix       as pointerdim ioMFlags     as shortdim ioSEBlkPtr   as pointerend recordbegin record ParamBlockRecbegin uniondim ioParam       as IOParamdim fileParam     as FileParamdim volumeParam   as VolumeParamdim cntrlParam    as CntrlParamdim slotDevParam  as SlotDevParamdim multiDevParam as MultiDevParamend unionend recordbegin record DTPBRecdim qLink         as pointer// queue link in headerdim qType         as short// type byte for safety checkdim ioTrap        as short// FS: the Trapdim ioCmdAddr     as pointer// FS: address to dispatch todim ioCompletion  as Proc// completion routine addr (0 for synch calls)dim ioResult      as OSErr// result codedim ioNamePtr     as pointer// ptr to Vol:FileName stringdim ioVRefNum     as short// volume refnum (DrvNum for Eject and MountVol)dim ioDTRefNum    as short// desktop refnumdim ioIndex       as shortdim ioTagInfo     as longdim ioDTBuffer    as pointerdim ioDTReqCount  as longdim ioDTActCount  as longdim ioFiller1     as SInt8dim ioIconType    as UInt8dim ioFiller2     as shortdim ioDirID       as longdim ioFileCreator as OSTypedim ioFileType    as OSTypedim ioFiller3     as longdim ioDTLgLen     as longdim ioDTPyLen     as longdim ioFiller4[13] as shortdim ioAPPLParID   as longend recordbegin record HIOParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioRefNum     as shortdim ioVersNum    as SInt8dim ioPermssn    as SInt8dim ioMisc       as pointerdim ioBuffer     as pointerdim ioReqCount   as longdim ioActCount   as longdim ioPosMode    as shortdim ioPosOffset  as longend recordbegin record HFileParamdim qLink        as pointerdim qType        as shortdim ioTrap       as shortdim ioCmdAddr    as pointerdim ioCompletion as Procdim ioResult     as OSErrdim ioNamePtr    as pointerdim ioVRefNum    as shortdim ioFRefNum    as shortdim ioFVersNum   as SInt8dim filler1      as SInt8dim ioFDirIndex  as shortdim ioFlAttrib   as SInt8dim ioFlVersNum  as SInt8dim ioFlFndrInfo as FInfodim ioDirID      as longdim ioFlStBlk    as unsigned shortdim ioFlLgLen    as longdim ioFlPyLen    as longdim ioFlRStBlk   as unsigned shortdim ioFlRLgLen   as longdim ioFlRPyLen   as longdim ioFlCrDat    as unsigned longdim ioFlMdDat    as unsigned longend recordbegin record HVolumeParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety dim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address dim ioCompletion as Proc// completion routine addrdim ioResult     as OSErr// result codedim ioNamePtr    as pointerdim ioVRefNum    as shortdim filler2      as longdim ioVolIndex   as shortdim ioVCrDate    as unsigned longdim ioVLsMod     as unsigned longdim ioVAtrb      as shortdim ioVNmFls     as unsigned shortdim ioVBitMap    as unsigned shortdim ioAllocPtr   as unsigned shortdim ioVNmAlBlks  as unsigned shortdim ioVAlBlkSiz  as unsigned longdim ioVClpSiz    as unsigned longdim ioAlBlSt     as unsigned shortdim ioVNxtCNID   as unsigned longdim ioVFrBlk     as unsigned shortdim ioVSigWord   as unsigned shortdim ioVDrvInfo   as shortdim ioVDRefNum   as shortdim ioVFSID      as shortdim ioVBkUp      as unsigned longdim ioVSeqNum    as shortdim ioVWrCnt     as unsigned longdim ioVFilCnt    as unsigned longdim ioVDirCnt    as unsigned longdim ioVFndrInfo[7] as longend recordbegin record XIOParamdim qLink        as pointerdim qType        as shortdim ioTrap       as shortdim ioCmdAddr    as pointerdim ioCompletion as Procdim ioResult     as OSErrdim ioNamePtr    as pointerdim ioVRefNum    as shortdim ioRefNum     as shortdim ioVersNum    as SInt8dim ioPermssn    as SInt8dim ioMisc       as pointerdim ioBuffer     as pointerdim ioReqCount   as longdim ioActCount   as longdim ioPosMode    as shortdim ioWPosOffset as wideend recordbegin record XVolumeParamdim qLink          as pointerdim qType          as shortdim ioTrap         as shortdim ioCmdAddr      as pointerdim ioCompletion   as Procdim ioResult       as OSErrdim ioNamePtr      as pointerdim ioVRefNum      as shortdim ioXVersion     as unsigned longdim ioVolIndex     as shortdim ioVCrDate      as unsigned longdim ioVLsMod       as unsigned longdim ioVAtrb        as shortdim ioVNmFls       as unsigned shortdim ioVBitMap      as unsigned shortdim ioAllocPtr     as unsigned shortdim ioVNmAlBlks    as unsigned shortdim ioVAlBlkSiz    as unsigned longdim ioVClpSiz      as unsigned longdim ioAlBlSt       as unsigned shortdim ioVNxtCNID     as unsigned longdim ioVFrBlk       as unsigned shortdim ioVSigWord     as unsigned shortdim ioVDrvInfo     as shortdim ioVDRefNum     as shortdim ioVFSID        as shortdim ioVBkUp        as unsigned longdim ioVSeqNum      as shortdim ioVWrCnt       as unsigned longdim ioVFilCnt      as unsigned longdim ioVDirCnt      as unsigned longdim ioVFndrInfo[7] as longdim ioVTotalBytes  as UInt64// total number of bytes on volumedim ioVFreeBytes   as UInt64// number of free bytes on volumeend recordbegin record AccessParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety cDheckdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum DrvNum for Eject and MountVol)dim filler3      as shortdim ioDenyModes  as short// access rights datadim filler4      as shortdim filler5      as SInt8dim ioACUser     as SInt8// access rights for directory onlydim filler6      as longdim ioACOwnerID  as long// owner IDdim ioACGroupID  as long// group IDdim ioACAccess   as long// access rightsdim ioDirID      as longend recordbegin record ObjParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName stringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim filler7      as shortdim ioObjType    as short// function codedim ioObjNamePtr as pointer// ptr to returned creator/group namedim ioObjID      as long// creator/group IDend recordbegin record CopyParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety checkdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dispatch todim ioCompletion as Proc// completion routine addr (0 for synch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName sDim  as tringdim ioVRefNum    as short// volume refnum (DrvNum for Eject and MountVol)dim ioDstVRefNum as short// destination vol identifierdim filler8      as shortdim ioNewName    as pointer// ptr to destination pthnamedim ioCopyName   as pointer// ptr to optional namedim ioNewDirID   as long// destination dDim  as irectory IDdim filler14     as longdim filler15     as longdim ioDirID      as longend recordbegin record WDParamdim qLink        as pointer// queue link in headerdim qType        as short// type byte for safety cDim  as heckdim ioTrap       as short// FS: the Trapdim ioCmdAddr    as pointer// FS: address to dDim  as ispatch todim ioCompletion as Proc// completion routine addr (0 for sDim  as ynch calls)dim ioResult     as OSErr// result codedim ioNamePtr    as pointer// ptr to Vol:FileName sDim  as tringdim ioVRefNum    as short// volume refnum (Dim  as DrvNum for Eject and MountVol)dim ioWDCreated  as shortdim ioWDIndex    as shortdim ioWDProcID   as longdim ioWDVRefNum  as shortdim filler10     as shortdim filler11     as longdim filler12     as longdim filler13     as longdim ioWDDirID    as longend recordbegin record FIDParamdim qLink         as pointer// queue link in headerdim qType         as short// type byte for safety cDim  as heckdim ioTrap        as short// FS: the Trapdim ioCmdAddr     as pointer// FS: address to dDim  as ispatch todim ioCompletion  as Proc// completion routine addr (0 for sDim  as ynch calls)dim ioResult      as OSErr// result codedim ioNamePtr     as pointer// ptr to Vol:FileName sDim  as tringdim ioVRefNum     as short// volume refnum (Dim  as DrvNum for Eject and MountVol)dim filler14      as longdim ioDestNamePtr as pointer// dest file namedim filler15      as longdim ioDestDirID   as long// dest file's dDim  as irectory iddim filler16      as longdim filler17      as longdim ioSrcDirID    as long// source file's dDim  as irectory iddim filler18      as shortdim ioFileID      as long// file IDend recordbegin record ForeignPrivParamdim qLink                 as pointer// queue link in headerdim qType                 as short// type byte for safety cDim  as heckdim ioTrap                as short// FS: the Trapdim ioCmdAddr             as pointer// FS: address to dDim  as ispatch todim ioCompletion          as Proc// completion routine addr (0 for sDim  as ynch calls)dim ioResult              as OSErr// result codedim ioNamePtr             as pointer// ptr to Vol:FileName sDim  as tringdim ioVRefNum             as short// volume refnum (Dim  as DrvNum for Eject and MountVol)dim ioFiller21            as longdim ioFiller22            as longdim ioForeignPrivBuffer   as pointerdim ioForeignPrivActCount as longdim ioForeignPrivReqCount as longdim ioFiller23            as longdim ioForeignPrivDirID    as longdim ioForeignPrivInfo1    as longdim ioForeignPrivInfo2    as longdim ioForeignPrivInfo3    as longdim ioForeignPrivInfo4    as longend recordbegin record CatPositionRecdim initialize as longdim priv[5]    as shortend recordbegin record CSParamdim qLink           as pointer// queue link in headerdim qType           as short// type byte for safety cDim  as heckdim ioTrap          as short// FS: the Trapdim ioCmdAddr       as pointer// FS: address to dDim  as ispatch todim ioCompletion    as Proc// completion routine addr (0 for sDim  as ynch calls)dim ioResult        as OSErr// result codedim ioNamePtr       as pointer// ptr to Vol:FileName sDim  as tringdim ioVRefNum       as short// volume refnum (Dim  as DrvNum for Eject and MountVol)dim ioMatchPtr      as pointer'FSSpecPtr// match arraydim ioReqMatchCount as long// maximum allowable mDim  as atchesdim ioActMatchCount as long// actual match count *Dim  as /dim ioSearchBits    as long// search criteria sDim  as electordim ioSearchInfo1   as pointer'CInfoPBPtr// search values and rDim  as ange lower boundsdim ioSearchInfo2   as pointer'CInfoPBPtr// search values and rDim  as ange upper boundsdim ioSearchTime    as long// length of time to rDim  as un searchdim ioCatPosition   as CatPositionRec// current position in tDim  as he catalogdim ioOptBuffer     as pointer// optional pDim  as erformance enhancement bufferdim ioOptBufSize    as long// size of buffer pDim  as ointed to by ioOptBufferend recordbegin record WDPBRecdim qLink        as pointerdim qType        as shortdim ioTrap       as shortdim ioCmdAddr    as pointerdim ioCompletion as Procdim ioResult     as OSErrdim ioNamePtr    as pointerdim ioVRefNum    as shortdim filler1      as short dim ioWDIndex    as short dim ioWDProcID   as long dim ioWDVRefNum  as short dim filler2[6]   as short dim ioWDDirID    as long end recordbegin record FCBPBRecdim qLink        as pointerdim qType        as shortdim ioTrap       as shortdim ioCmdAddr    as pointerdim ioCompletion as Procdim ioResult     as OSErrdim ioNamePtr    as pointerdim ioVRefNum    as shortdim ioRefNum     as short dim filler       as short dim ioFCBIndx    as short dim filler1      as short dim ioFCBFlNm    as long dim ioFCBFlags   as short dim ioFCBStBlk   as unsigned short dim ioFCBEOF     as long dim ioFCBPLen    as long dim ioFCBCrPs    as long dim ioFCBVRefNum as short dim ioFCBClpSiz  as long dim ioFCBParID   as long end recordbegin record HParamBlockRecbegin uniondim ioParam          as HIOParamdim fileParam        as HFileParamdim volumeParam      as HVolumeParamdim accessParam      as AccessParamdim objParam         as ObjParamdim copyParam        as CopyParamdim wdParam          as WDParamdim fidParam         as FIDParamdim csParam          as CSParamdim foreignPrivParam as ForeignPrivParamend unionend record#define HParmBlkPtr as pointer'.HParamBlockRecbegin record CMovePBRecdim qLink        as pointerdim qType        as shortdim ioTrap       as shortdim ioCmdAddr    as pointerdim ioCompletion as Procdim ioResult     as OSErrdim ioNamePtr    as pointerdim ioVRefNum    as shortdim filler1      as longdim ioNewName    as pointerdim filler2      as longdim ioNewDirID   as longdim filler3[1]   as longdim ioDirID      as longend recordbegin record UniversalFMPBbegin uniondim PB    as ParamBlockRecdim ciPB  as CInfoPBRecdim dtPB  as DTPBRecdim hPB   as HParamBlockRecdim cmPB  as CMovePBRecdim wdPB  as WDPBRecdim fcbPB as FCBPBRecdim xPB   as XVolumeParamend unionend recordbegin record HFSUniStr255dim as UInt16   length /* number of unicode characters */dim as UniChar  unicode[254]  /* unicode characters */end recordbegin record UnicodeMapping  dim unicodeEncoding as TextEncoding  dim otherEncoding   as TextEncoding  dim mappingVersion  as Sint32 'as UnicodeMapVersionend record#define FSVolumeInfoBitmap as UInt32begin enum_kFSVolInfoNone         = 0x0000_kFSVolInfoCreateDate   = 0x0001_kFSVolInfoModDate      = 0x0002_kFSVolInfoBackupDate   = 0x0004_kFSVolInfoCheckedDate  = 0x0008_kFSVolInfoFileCount    = 0x0010_kFSVolInfoDirCount     = 0x0020_kFSVolInfoSizes        = 0x0040// totalBytes and freeBytes_kFSVolInfoBlocks       = 0x0080// blockSize, totalBlocks, freeBlocks_kFSVolInfoNextAlloc    = 0x0100_kFSVolInfoRsrcClump    = 0x0200_kFSVolInfoDataClump    = 0x0400_kFSVolInfoNextID       = 0x0800_kFSVolInfoFinderInfo   = 0x1000_kFSVolInfoFlags        = 0x2000_kFSVolInfoFSInfo       = 0x4000// filesystemID, signature_kFSVolInfoDriveInfo    = 0x8000// driveNumber, driverRefNum_kFSVolInfoGettableInfo = 0xFFFF// This seems like it is here just for completeness_kFSVolInfoSettableInfo = 0x3004// backup date, Finder info, flagsend enumbegin enum_kFSCatInfoNone         = 0x00000000_kFSCatInfoTextEncoding = 0x00000001_kFSCatInfoNodeFlags    = 0x00000002// Locked (bit 0) and directory (bit 4) only_kFSCatInfoVolume       = 0x00000004_kFSCatInfoParentDirID  = 0x00000008_kFSCatInfoNodeID       = 0x00000010_kFSCatInfoCreateDate   = 0x00000020_kFSCatInfoContentMod   = 0x00000040_kFSCatInfoAttrMod      = 0x00000080_kFSCatInfoAccessDate   = 0x00000100_kFSCatInfoBackupDate   = 0x00000200_kFSCatInfoPermissions  = 0x00000400// Should this be finer granularity?_kFSCatInfoFinderInfo   = 0x00000800_kFSCatInfoFinderXInfo  = 0x00001000_kFSCatInfoValence      = 0x00002000// Folders only, zero for files_kFSCatInfoDataSizes    = 0x00004000// Data fork logical and physical size_kFSCatInfoRsrcSizes    = 0x00008000// Resource fork logical and physical size_kFSCatInfoSharingFlags = 0x00010000// sharingFlags: kioFlAttribMountedBit, kioFlAttribSharePointBit_kFSCatInfoUserPrivs    = 0x00020000// userPrivileges_kFSCatInfoUserAccess   = 0x00080000// (OS X only)_kFSCatInfoAllDates     = 0x000003E0_kFSCatInfoGettableInfo = 0x0003FFFF_kFSCatInfoSettableInfo = 0x00001FE3// flags, dates, permissions, Finder info, text encoding_kFSCatInfoReserved     = 0xFFFC0000// bits that are currently reservedend enumbegin enum  _kFSNodeLockedBit       = 0// Set if file or directory is locked   _kFSNodeLockedMask      = 0x0001  _kFSNodeResOpenBit      = 2// Set if the resource fork is open   _kFSNodeResOpenMask     = 0x0004  _kFSNodeDataOpenBit     = 3// Set if the data fork is open   _kFSNodeDataOpenMask    = 0x0008  _kFSNodeIsDirectoryBit  = 4// Set if the object is a directory   _kFSNodeIsDirectoryMask = 0x0010  _kFSNodeCopyProtectBit  = 6  _kFSNodeCopyProtectMask = 0x0040  _kFSNodeForkOpenBit     = 7// Set if the file or directory has any open fork   _kFSNodeForkOpenMask    = 0x0080end enumbegin enum  _kFSIterateFlat     = 0// Immediate children of container only   _kFSIterateSubtree  = 1// Entire subtree rooted at container   _kFSIterateDelete   = 2  _kFSIterateReserved = 0xFFFFFFFCend enum_errFSNoMoreItems  = -1417begin enum// ioPosMode flags _pleaseCacheBit  = 4// please cache this request _pleaseCacheMask = 0x0010//_noCacheBit      = 5// please don't cache this request _noCacheMask     = 0x0020_rdVerifyBit     = 6// read verify mode _rdVerifyMask    = 0x0040//_rdVerify        = 64// old name of rdVerifyMask _forceReadBit    = 6_forceReadMask   = 0x0040_newLineBit      = 7// newline mode _newLineMask     = 0x0080_newLineCharMask = 0xFF00// newline character end enumbegin enum_kHFSMaxVolumeNameChars   = 27_kHFSMaxFileNameChars     = 31_kHFSPlusMaxFileNameChars = 255end enumbegin enum_kFSVolFlagDefaultVolumeBit   = 5// Set if the volume is the default volume _kFSVolFlagDefaultVolumeMask  = 0x0020_kFSVolFlagFilesOpenBit       = 6// Set if there are open files or iterators _kFSVolFlagFilesOpenMask      = 0x0040_kFSVolFlagHardwareLockedBit  = 7// Set if volume is locked by a hardware setting _kFSVolFlagHardwareLockedMask = 0x0080_kFSVolFlagSoftwareLockedBit  = 15// Set if volume is locked by software _kFSVolFlagSoftwareLockedMask = 0x8000end enum#define FNMessage as UInt32begin enum_kFNDirectoryModifiedMessage = 1end enum _kNilOptions = 0#define FSCatalogInfoBitmap as UInt32#define FSVolumeRefNum      as SInt16#define FSIterator          as pointer#define FSIteratorFlags     as long begin record FSPermissionInfodim as UInt32              userIDdim as UInt32              groupIDdim as UInt8               reserved1dim as UInt8               userAccessdim as UInt16              modedim as pointer             fileSec // FSFileSecurityRefend record_correctFSCatalogInfo = 0#if _correctFSCatalogInfo == 0 // FB innovationbegin record FinderInfoFBbegin uniondim file   as FileInfodim folder as FolderInfoend unionend recordbegin record ExtendedFinderInfoFBbegin uniondim file   as ExtendedFileInfodim folder as ExtendedFolderInfoend unionend record#endif // _correctFSCatalogInfobegin record FSCatalogInfodim nodeFlags        as UInt16 // node flagsdim volume           as FSVolumeRefNum // object volume refdim parentDirID      as UInt32 // parent directory IDdim nodeID           as UInt32 // file/directory IDdim sharingFlags     as UInt8 // kioFlAttribMountedBit and kioFlAttribSharePointBitdim userPrivileges   as UInt8 // user effective AFP privileges (same as ioACUser)dim reserved1        as UInt8dim reserved2        as UInt8dim createDate       as UTCDateTime // date and time of creationdim contentModDate   as UTCDateTime // date and time of last fork modificationdim attributeModDate as UTCDateTime // date and time of last attribute modificationdim accessDate       as UTCDateTime // date and time of last access (for Mac OS X)dim backupDate       as UTCDateTime // date and time of last backup#if def _LP64dim permissions      as FSPermissionInfo // permissions as FSPermissionInfo#elsedim permissions[3]   as UInt32 // permissions as FSPermissionInfo#endif#if _correctFSCatalogInfo // same as Files.hdim finderInfo[15]    as UInt8 // Finder information part 1 as FileInfo or FolderInfodim extFinderInfo[15] as UInt8 // Finder information part 2 as ExtendedFileInfo or ExtendedFolderInfo#else // useful FB innovationdim finderInfo       as FinderInfoFBdim extFinderInfo    as ExtendedFinderInfoFB#endifdim dataLogicalSize  as UInt64 // files onlydim dataPhysicalSize as UInt64 // files onlydim rsrcLogicalSize  as UInt64 // files onlydim rsrcPhysicalSize as UInt64 // files onlydim valence          as UInt32 // folders onlydim textEncodingHint as TextEncodingend recordbegin record FSVolumeInfo// Dates -- zero means "never" or "unknown" dim createDate     as UTCDateTime  dim modifyDate     as UTCDateTime  dim backupDate     as UTCDateTime  dim checkedDate    as UTCDateTime  // File/Folder counts -- return zero if unknown dim fileCount      as UInt32 // total files on volume dim folderCount    as UInt32 // total folders on volume // Note: no root directory counts dim totalBytes     as UInt64 // total number of bytes on volume dim freeBytes      as UInt64 // number of free bytes on volume // HFS and HFS Plus specific.  Set fields to zero if not appropriate dim blockSize      as UInt32 // size (in bytes) of allocation blocks dim totalBlocks    as UInt32 // number of allocation blocks in volume dim freeBlocks     as UInt32 // number of unused allocation blocks dim nextAllocation as UInt32 // start of next allocation search dim rsrcClumpSize  as UInt32 // default resource fork clump size dim dataClumpSize  as UInt32 // default data fork clump size dim nextCatalogID  as UInt32 // next unused catalog node ID еее OYG еее need to make HFSVolumes.h work Should be HFSCatalogNodeID*/dim finderInfo[31] as UInt8 // information used by Finder // Identifying information dim flags          as UInt16 // ioVAtrb dim filesystemID   as UInt16 // ioVFSID dim signature      as UInt16 // ioVSigWord, unique within an FSID dim driveNumber    as UInt16 // ioVDrvInfo dim driverRefNum   as short // ioVDRefNum end recordbegin record FSRefParamdim qLink            as pointer// queue link in headerdim qType            as short// type byte for safety checkdim ioTrap           as short// FS: the Trapdim ioCmdAddr        as pointer// FS: address to dispatch todim ioCompletion     as Proc// completion routine addr (0 for synch calls)dim ioResult         as OSErr// result codedim ioNamePtr        as pointer// ptr to Vol:FileName stringdim ioVRefNum        as short// volume refnum (DrvNum for Eject and MountVol)dim reserved1        as SInt16// was ioRefNumdim reserved2        as UInt8// was ioVersNumdim reserved3        as UInt8// was ioPermssndim ref              as pointer'FSRef// Input ref the target of the calldim whichInfo        as FSCatalogInfoBitmap dim catInfo          as pointer'FSCatalogInfodim nameLength       as UniCharCount// input name length for create/renamedim name             as pointer'UniChar// input name for create/renamedim ioDirID          as long dim spec             as pointer'FSSpec dim parentRef        as pointer'FSRef// ref of directory to move another ref todim newRef           as pointer'FSRef// Output refdim textEncodingHint as TextEncoding// for Rename, MakeFSRefUnicodedim outName          as pointer'HFSUniStr255// Output name for GetCatalogInfoend record// local defines begin record GetVolParmsInfoBufferdim vMVersion            as short// version numberdim vMAttrib             as long// bit vector of attributes (see vMAttrib constants)dim vMLocalHand          as Handle// handle to private datadim vMServerAdr          as long// AppleTalk server address or zero// vMVersion 1 GetVolParmsInfoBuffer ends heredim vMVolumeGrade        as long// approx. speed rating or zero if unrateddim vMForeignPrivID      as short// foreign privilege model supported or zero if none// vMVersion 2 GetVolParmsInfoBuffer ends heredim vMExtendedAttributes as long// extended attribute bits (see vMExtendedAttributes constants)// vMVersion 3 GetVolParmsInfoBuffer ends heredim vMDeviceID           as pointer// device id name for interoperability with IOKit// vMVersion 4 GetVolParmsInfoBuffer ends hereend recordbegin record FSForkInfodim flags           as SInt8// copy of FCB flagsdim permissions     as SInt8dim volume          as FSVolumeRefNumdim reserved2       as UInt32dim nodeID          as UInt32// file or directory IDdim forkID          as UInt32// fork IDdim currentPosition as UInt64dim logicalEOF      as UInt64dim physicalEOF     as UInt64dim process         as UInt64// should be ProcessSerialNumberend recordtoolbox fn FSOpenIterator( const FSRef * container, FSIteratorFlags iteratorFlags, FSIterator * iterator) = OSErrtoolbox fn FSGetCatalogInfoBulk( FSIterator iter,long maxObjs,long * actualObjs,Boolean * contChanged,FSCatalogInfoBitmap whichInfo, FSCatalogInfo * catInfos,FSRef * refs,FSSpec * specs,HFSUniStr255 * names) = OSErr#define UnicodeToTextInfo as pointertoolbox fn ConvertFromUnicodeToPString( UnicodeToTextInfo   iUnicodeToTextInfo, UInt32 iUnicodeLen, const UniChar pointer, Str255 oPascalStr) = OSStatustoolbox fn CreateUnicodeToTextInfo( pointer iUnicodeMapping,  UnicodeToTextInfo * oUnicodeToTextInfo) = OSStatustoolbox fn DisposeUnicodeToTextInfo( UnicodeToTextInfo * ioUnicodeToTextInfo) = OSStatustoolbox fn FSGetForkSize( SInt16 forkRefNum, SInt64 *  forkSize) = OSErrtoolbox fn FSSetForkPosition( SInt16 forkRefNum, UInt16 positionMode,SInt32 positionOffset ) = OSErrtoolbox fn FSReadFork( SInt16 forkRefNum, UInt16 positionMode, SInt32 positionOffset, ByteCount requestCount, pointer buffer, ByteCount * actualCount) = OSErrtoolbox fn FSSetForkSize( SInt16 forkRefNum, UInt16 positionMode, SInt32 positionOffset ) = OSErrtoolbox fn FSWriteFork( SInt16 forkRefNum, UInt16 positionMode, SInt32 positionOffset, ByteCount requestCount, const pointer buffer, ByteCount * actualCount) = OSErrtoolbox fn PBHGetVolParmsSync( HParmBlkPtr paramBlock ) = OSErrtoolbox fn FSGetCatalogInfo( FSRef * ref, FSCatalogInfoBitmap whichInfo, FSCatalogInfo * catalogInfo, HFSUniStr255 * outName, FSSpec * fsSpec, FSRef * parentRef ) = OSErrtoolbox fn FSGetVolumeInfo( FSVolumeRefNum volume,ItemCount volumeIndex, FSVolumeRefNum * actualVolume, FSVolumeInfoBitmap whichInfo, FSVolumeInfo * info, HFSUniStr255 * volumeName,FSRef * rootDirectory ) = OSErrtoolbox fn PBMakeFSRefSync( FSRefParam * paramBlock) = OSErr//Toolbox Fn FSRefMakePath( FSRef * ref,UInt8 * path, UInt32 maxPathSize ) = OSStatustoolbox fn FSPathMakeRef( UInt8 * path, FSRef * ref, Boolean * isDirectory ) = OSStatustoolbox fn FSIterateForks( FSRef * ref,CatPositionRec * forkIterator,HFSUniStr255 * forkName,SInt64 * forkSize,UInt64 * forkPhysicalSize) = OSErrtoolbox fn FNNotify( const FSRef * ref, FNMessage message, UInt32 flags) = OSStatustoolbox fn FSSetCatalogInfo( FSRef * ref,FSCatalogInfoBitmap whichInfo,FSCatalogInfo * catalogInfo) = OSErr toolbox fn PBMakeFSRefUnicodeSync( FSRefParam * paramBlock ) = OSErr `0x707A, 0xA260toolbox fn FSRenameUnicode( const FSRef * ref, UniCharCount nameLength, const UniChar * name, TextEncoding textEncodingHint, FSRef * newRef) = OSErrtoolbox fn FSMoveObject( const FSRef * ref, const FSRef * destDirectory, FSRef * newRef) = OSErrtoolbox fn FSDeleteObject( const FSRef * ref) = OSErrtoolbox fn FSCloseIterator( FSIterator iterator) = OSErrtoolbox fn PBHGetDirAccessSync( HParmBlkPtr paramBlock) = OSErr toolbox fn PBHSetDirAccessSync( HParmBlkPtr paramBlock) = OSErrtoolbox fn PBGetVolMountInfoSize( pointer paramBlock) = OSErr toolbox fn PBGetVolMountInfo( pointer paramBlock) = OSErrtoolbox fn PBVolumeMount( pointer paramBlock) = OSErrtoolbox fn PBHMapIDSync( HParmBlkPtr paramBlock) = OSErrtoolbox fn PBHMapNameSync( HParmBlkPtr paramBlock) = OSErrtoolbox fn PBHCopyFileSync( HParmBlkPtr paramBlock) = OSErrtoolbox fn PBHMoveRenameSync( HParmBlkPtr paramBlock) = OSErrtoolbox fn PBResolveFileIDRefSync( HParmBlkPtr paramBlock) = OSErrtoolbox fn PBCreateFileIDRefSync( HParmBlkPtr paramBlock) = OSErr toolbox fn HGetVol( StringPtr volName,short * vRefNum,long * dirID) = OSErrtoolbox fn HSetVol( str63 volName,short vRefNum,long dirID) = OSErrtoolbox fn FSExchangeObjects( FSRef * ref,FSRef * destRef) = OSErr toolbox fn FSGetForkCBInfo( SInt16 desiredRefNum, FSVolumeRefNum volume, SInt16 * iterator, SInt16 * actualRefNum, FSForkInfo * forkInfo, FSRef * ref, HFSUniStr255 * outForkName) = OSErrbegin enum_kTextEncodingMultiRun = 0x0FFF// Multi-encoding text with external run info_kTextEncodingUnknown  = 0xFFFF// Unknown or unspecifiedend enumbegin enum_kTextScriptDontCare   = -128_kTextLanguageDontCare = -128_kTextRegionDontCare   = -128end enum#define TextEncodingFormat as UInt32begin enum// Default TextEncodingFormat for any TextEncodingBase_kTextEncodingDefaultFormat = 0// Formats for Unicode & ISO 10646_kUnicode16BitFormat        = 0_kUnicodeUTF7Format         = 1_kUnicodeUTF8Format         = 2_kUnicode32BitFormat        = 3end enum// TextEncodingVariant type & values#define TextEncodingVariant as UInt32// Default TextEncodingVariant, for any TextEncodingBasebegin enum_kTextEncodingDefaultVariant = 0end enum// Variants of kTextEncodingMacRomanbegin enum_kMacRomanDefaultVariant      = 0// meta value, maps to 1 or 2 depending on System_kMacRomanCurrencySignVariant = 1// Mac OS version < 8.5, 0xDB is CURRENCY SIGN_kMacRomanEuroSignVariant     = 2// Mac OS version >= 8.5, 0xDB is EURO SIGNend enum// Variants of kTextEncodingMacCyrillic (for TEC 1.5 and later)begin enum_kMacCyrillicDefaultVariant     = 0// meta value, maps to 1, 2, or 3 depending on System_kMacCyrillicCurrSignStdVariant = 1// Mac OS < 9.0 (RU,BG), 0xFF = CURRENCY SIGN, 0xA2/0xB6 = CENT / PARTIAL DIFF._kMacCyrillicCurrSignUkrVariant = 2// Mac OS < 9.0 (UA,LangKit), 0xFF = CURRENCY SIGN, 0xA2/0xB6 = GHE WITH UPTURN_kMacCyrillicEuroSignVariant    = 3// Mac OS >= 9.0, 0xFF is EURO SIGN, 0xA2/0xB6 = GHE WITH UPTURNend enum// Variants of kTextEncodingMacIcelandicbegin enum_kMacIcelandicStdDefaultVariant  = 0// meta value, maps to 2 or 4 depending on System_kMacIcelandicTTDefaultVariant   = 1// meta value, maps to 3 or 5 depending on System// The following are for Mac OS version < 8.5, 0xDB is CURRENCY SIGN_kMacIcelandicStdCurrSignVariant = 2// 0xBB/0xBC are fem./masc. ordinal indicators_kMacIcelandicTTCurrSignVariant  = 3// 0xBB/0xBC are fi/fl ligatures// The following are for Mac OS version >= 8.5, 0xDB is EURO SIGN_kMacIcelandicStdEuroSignVariant = 4// 0xBB/0xBC are fem./masc. ordinal indicators_kMacIcelandicTTEuroSignVariant  = 5// 0xBB/0xBC are fi/fl ligaturesend enum// Variants of kTextEncodingMacCroatianbegin enum_kMacCroatianDefaultVariant      = 0// meta value, maps to 1 or 2 depending on System_kMacCroatianCurrencySignVariant = 1// Mac OS version < 8.5, 0xDB is CURRENCY SIGN_kMacCroatianEuroSignVariant     = 2// Mac OS version >= 8.5, 0xDB is EURO SIGNend enum// Variants of kTextEncodingMacRomanianbegin enum_kMacRomanianDefaultVariant      = 0// meta value, maps to 1 or 2 depending on System_kMacRomanianCurrencySignVariant = 1// Mac OS version < 8.5, 0xDB is CURRENCY SIGN_kMacRomanianEuroSignVariant     = 2// Mac OS version >= 8.5, 0xDB is EURO SIGNend enum// Variants of kTextEncodingMacJapanesebegin enum_kMacJapaneseStandardVariant        = 0_kMacJapaneseStdNoVerticalsVariant  = 1_kMacJapaneseBasicVariant           = 2_kMacJapanesePostScriptScrnVariant  = 3_kMacJapanesePostScriptPrintVariant = 4_kMacJapaneseVertAtKuPlusTenVariant = 5end enum// Variants of kTextEncodingMacArabicbegin enum_kMacArabicStandardVariant = 0// 0xC0 is 8-spoke asterisk, 0x2A & 0xAA are asterisk (e.g. Cairo)_kMacArabicTrueTypeVariant = 1// 0xC0 is asterisk, 0x2A & 0xAA are multiply signs (e.g. Baghdad)_kMacArabicThuluthVariant  = 2// 0xC0 is Arabic five-point star, 0x2A & 0xAA are multiply signs_kMacArabicAlBayanVariant  = 3// 8-spoke asterisk, multiply sign, Koranic ligatures & parensend enum// Variants of kTextEncodingMacFarsibegin enum_kMacFarsiStandardVariant = 0// 0xC0 is 8-spoke asterisk, 0x2A & 0xAA are asterisk (e.g. Tehran)_kMacFarsiTrueTypeVariant = 1// asterisk, multiply signs, Koranic ligatures, geometric shapesend enum// Variants of kTextEncodingMacHebrewbegin enum_kMacHebrewStandardVariant    = 0_kMacHebrewFigureSpaceVariant = 1end enum// Variants of kTextEncodingMacVT100begin enum_kMacVT100DefaultVariant      = 0// meta value, maps to 1 or 2 depending on System_kMacVT100CurrencySignVariant = 1// Mac OS version < 8.5, 0xDB is CURRENCY SIGN_kMacVT100EuroSignVariant     = 2// Mac OS version >= 8.5, 0xDB is EURO SIGNend enum// Variants of Unicode & ISO 10646 encodingsbegin enum_kUnicodeNoSubset               = 0_kUnicodeCanonicalDecompVariant = 2// canonical decomposition; excludes composed charactersend enum// Variants of Big-5 encodingbegin enum_kBig5BasicVariant    = 0_kBig5StandardVariant = 1// 0xC6A1-0xC7FC: kana, Cyrillic, enclosed numerics_kBig5ETenVariant     = 2// adds kana, Cyrillic, radicals, etc with hi bytes C6-C8,F9end enum// Variants of MacRomanLatin1begin enum_kMacRomanLatin1DefaultVariant   = 0// meta value, maps to others depending on System_kMacRomanLatin1StandardVariant  = 2// permuted MacRoman, EuroSignVariant_kMacRomanLatin1TurkishVariant   = 6// permuted MacTurkish_kMacRomanLatin1CroatianVariant  = 8// permuted MacCroatian, EuroSignVariant_kMacRomanLatin1IcelandicVariant = 11// permuted MacIcelandic, StdEuroSignVariant_kMacRomanLatin1RomanianVariant  = 14// permuted MacRomanian, EuroSignVariantend enum// Unicode variants not yet supported (and not fully defined)begin enum_kUnicodeNoCompatibilityVariant = 1_kUnicodeNoComposedVariant      = 3_kUnicodeNoCorporateVariant     = 4end enum// The following are older names for backward compatibilitybegin enum_kMacRomanStandardVariant           = 0_kMacIcelandicStandardVariant       = 0_kMacIcelandicTrueTypeVariant       = 1_kJapaneseStandardVariant           = 0_kJapaneseStdNoVerticalsVariant     = 1_kJapaneseBasicVariant              = 2_kJapanesePostScriptScrnVariant     = 3_kJapanesePostScriptPrintVariant    = 4_kJapaneseVertAtKuPlusTenVariant    = 5_kJapaneseStdNoOneByteKanaVariant   = 6// replaced by kJapaneseNoOneByteKanaOption_kJapaneseBasicNoOneByteKanaVariant = 7// replaced by kJapaneseNoOneByteKanaOption_kHebrewStandardVariant             = 0_kHebrewFigureSpaceVariant          = 1_kUnicodeMaxDecomposedVariant       = 2// replaced by kUnicodeCanonicalDecompVariant// The following Japanese variant options were never supported and are now deprecated._kJapaneseNoOneByteKanaOption       = 0x20// replaced by UnicodeConverter option kUnicodeNoHalfwidthCharsBit_kJapaneseUseAsciiBackslashOption   = 0x40// replaced by UnicodeConverter option kUnicodeForceASCIIRangeBitend enum#define TextEncodingBase as UInt32begin enum// Mac OS encodings_kTextEncodingMacRoman           = 0_kTextEncodingMacJapanese        = 1_kTextEncodingMacChineseTrad     = 2_kTextEncodingMacKorean          = 3_kTextEncodingMacArabic          = 4_kTextEncodingMacHebrew          = 5_kTextEncodingMacGreek           = 6_kTextEncodingMacCyrillic        = 7_kTextEncodingMacDevanagari      = 9_kTextEncodingMacGurmukhi        = 10_kTextEncodingMacGujarati        = 11_kTextEncodingMacOriya           = 12_kTextEncodingMacBengali         = 13_kTextEncodingMacTamil           = 14_kTextEncodingMacTelugu          = 15_kTextEncodingMacKannada         = 16_kTextEncodingMacMalayalam       = 17_kTextEncodingMacSinhalese       = 18_kTextEncodingMacBurmese         = 19_kTextEncodingMacKhmer           = 20_kTextEncodingMacThai            = 21_kTextEncodingMacLaotian         = 22_kTextEncodingMacGeorgian        = 23_kTextEncodingMacArmenian        = 24_kTextEncodingMacChineseSimp     = 25_kTextEncodingMacTibetan         = 26_kTextEncodingMacMongolian       = 27_kTextEncodingMacEthiopic        = 28_kTextEncodingMacCentralEurRoman = 29_kTextEncodingMacVietnamese      = 30_kTextEncodingMacExtArabic       = 31// The following use script code 0, smRoman_kTextEncodingMacSymbol          = 33_kTextEncodingMacDingbats        = 34_kTextEncodingMacTurkish         = 35_kTextEncodingMacCroatian        = 36_kTextEncodingMacIcelandic       = 37_kTextEncodingMacRomanian        = 38_kTextEncodingMacCeltic          = 39_kTextEncodingMacGaelic          = 40_kTextEncodingMacKeyboardGlyphs  = 41end enum// The following are older names for backward compatibilitybegin enum_kTextEncodingMacTradChinese  = _kTextEncodingMacChineseTrad_kTextEncodingMacRSymbol      = 8_kTextEncodingMacSimpChinese  = _kTextEncodingMacChineseSimp_kTextEncodingMacGeez         = _kTextEncodingMacEthiopic_kTextEncodingMacEastEurRoman = _kTextEncodingMacCentralEurRoman_kTextEncodingMacUninterp     = 32end enum/* Beginning in Mac OS 8.5, the following meta-value is used to indicate Unicode in some parts of the Mac OS which previously only expected a Mac OS script code. In some of these places, only 7 bits are available to indicate encoding (script code), so kTextEncodingUnicodeDefault cannot be used. For example, kTextEncodingMacUnicode can be used to indicate Unicode in the 7-bit script code field of a Unicode input method's ComponentDescription.componentFlags field; it can also be used to indicate Unicode in the 16-bit script code field of an AppleEvent's typeIntlWritingCode text tag.*/begin enum_kTextEncodingMacUnicode = 0x7E// Meta-value, Unicode as a Mac encodingend enum// Variant Mac OS encodings that use script codes other than 0begin enum// The following use script code 4, smArabic_kTextEncodingMacFarsi     = 0x8C// Like MacArabic but uses Farsi digits// The following use script code 7, smCyrillic_kTextEncodingMacUkrainian = 0x98// Meta-value in TEC 1.5 & later; maps to kTextEncodingMacCyrillic variant // The following use script code 28, smEthiopic_kTextEncodingMacInuit     = 0xEC// The following use script code 32, smUnimplemented_kTextEncodingMacVT100     = 0xFC// VT100/102 font from Comm Toolbox: Latin-1 repertoire + box drawing etcend enum// Special Mac OS encodingsbegin enum_kTextEncodingMacHFS = 0xFF// Meta-value, should never appear in a table.end enum// Unicode & ISO UCS encodings begin at 0x100begin enum_kTextEncodingUnicodeDefault = 0x0100// Meta-value, should never appear in a table._kTextEncodingUnicodeV11     = 0x0101_kTextEncodingISO106461993   = 0x0101// Code points identical to Unicode 1.1_kTextEncodingUnicodeV20     = 0x0103// New location for Korean Hangul_kTextEncodingUnicodeV21     = 0x0103// We treat both Unicode 2.0 and Unicode 2.1 as 2.1_kTextEncodingUnicodeV30     = 0x0104_kTextEncodingUnicodeV31     = 0x0105// Adds characters requiring surrogate pairs in UTF-16_kTextEncodingUnicodeV32     = 0x0106end enum// ISO 8-bit and 7-bit encodings begin at 0x200begin enum_kTextEncodingISOLatin1        = 0x0201// ISO 8859-1_kTextEncodingISOLatin2        = 0x0202// ISO 8859-2_kTextEncodingISOLatin3        = 0x0203// ISO 8859-3_kTextEncodingISOLatin4        = 0x0204// ISO 8859-4_kTextEncodingISOLatinCyrillic = 0x0205// ISO 8859-5_kTextEncodingISOLatinArabic   = 0x0206// ISO 8859-6, = ASMO 708, =DOS CP 708_kTextEncodingISOLatinGreek    = 0x0207// ISO 8859-7_kTextEncodingISOLatinHebrew   = 0x0208// ISO 8859-8_kTextEncodingISOLatin5        = 0x0209// ISO 8859-9_kTextEncodingISOLatin6        = 0x020A// ISO 8859-10 _kTextEncodingISOLatin7        = 0x020D// ISO 8859-13, Baltic Rim _kTextEncodingISOLatin8        = 0x020E// ISO 8859-14, Celtic _kTextEncodingISOLatin9        = 0x020F// ISO 8859-15, 8859-1 changed for EURO & CP1252 letters end enum// MS-DOS & Windows encodings begin at 0x400begin enum_kTextEncodingDOSLatinUS         = 0x0400// code page 437_kTextEncodingDOSGreek           = 0x0405// code page 737 (formerly code page 437G)_kTextEncodingDOSBalticRim       = 0x0406// code page 775_kTextEncodingDOSLatin1          = 0x0410// code page 850, "Multilingual"_kTextEncodingDOSGreek1          = 0x0411// code page 851_kTextEncodingDOSLatin2          = 0x0412// code page 852, Slavic_kTextEncodingDOSCyrillic        = 0x0413// code page 855, IBM Cyrillic_kTextEncodingDOSTurkish         = 0x0414// code page 857, IBM Turkish_kTextEncodingDOSPortuguese      = 0x0415// code page 860_kTextEncodingDOSIcelandic       = 0x0416// code page 861_kTextEncodingDOSHebrew          = 0x0417// code page 862_kTextEncodingDOSCanadianFrench  = 0x0418// code page 863_kTextEncodingDOSArabic          = 0x0419// code page 864_kTextEncodingDOSNordic          = 0x041A// code page 865_kTextEncodingDOSRussian         = 0x041B// code page 866_kTextEncodingDOSGreek2          = 0x041C// code page 869, IBM Modern Greek_kTextEncodingDOSThai            = 0x041D// code page 874, also for Windows_kTextEncodingDOSJapanese        = 0x0420// code page 932, also for Windows; Shift-JIS with additions_kTextEncodingDOSChineseSimplif  = 0x0421// code page 936, also for Windows; was EUC-CN, now GBK (EUC-CN extended)_kTextEncodingDOSKorean          = 0x0422// code page 949, also for Windows; Unified Hangul Code (EUC-KR extended)_kTextEncodingDOSChineseTrad     = 0x0423// code page 950, also for Windows; Big-5_kTextEncodingWindowsLatin1      = 0x0500// code page 1252_kTextEncodingWindowsANSI        = 0x0500// code page 1252 (alternate name)_kTextEncodingWindowsLatin2      = 0x0501// code page 1250, Central Europe_kTextEncodingWindowsCyrillic    = 0x0502// code page 1251, Slavic Cyrillic_kTextEncodingWindowsGreek       = 0x0503// code page 1253_kTextEncodingWindowsLatin5      = 0x0504// code page 1254, Turkish_kTextEncodingWindowsHebrew      = 0x0505// code page 1255_kTextEncodingWindowsArabic      = 0x0506// code page 1256_kTextEncodingWindowsBalticRim   = 0x0507// code page 1257_kTextEncodingWindowsVietnamese  = 0x0508// code page 1258_kTextEncodingWindowsKoreanJohab = 0x0510// code page 1361, for Windows NTend enum// Various national standards begin at 0x600begin enum_kTextEncodingUSASCII         = 0x0600_kTextEncodingJISX020176      = 0x0620// JIS Roman and 1-byte katakana (halfwidth)_kTextEncodingJISX020883      = 0x0621_kTextEncodingJISX020890      = 0x0622_kTextEncodingJISX021290      = 0x0623_kTextEncodingJISC622678      = 0x0624_kTextEncodingShiftJISX021300 = 0x0628// Shift-JIS format encoding of JIS X0213 planes 1 and 2_kTextEncodingGB231280        = 0x0630_kTextEncodingGBK95           = 0x0631// annex to GB 13000-93; for Windows 95; EUC-CN extended_kTextEncodingGB180302000     = 0x0632_kTextEncodingKSC560187       = 0x0640// same as KSC 5601-92 without Johab annex_kTextEncodingKSC560192Johab  = 0x0641// KSC 5601-92 Johab annex_kTextEncodingCNS1164392P1    = 0x0651// CNS 11643-1992 plane 1_kTextEncodingCNS1164392P2    = 0x0652// CNS 11643-1992 plane 2_kTextEncodingCNS1164392P3    = 0x0653// CNS 11643-1992 plane 3 (was plane 14 in 1986 version)end enum// ISO 2022 collections begin at 0x800begin enum_kTextEncodingISO2022JP    = 0x0820// RFC 1468_kTextEncodingISO2022JP2   = 0x0821// RFC 1554_kTextEncodingISO2022JP1   = 0x0822// RFC 2237_kTextEncodingISO2022JP3   = 0x0823// JIS X0213_kTextEncodingISO2022CN    = 0x0830_kTextEncodingISO2022CNEXT = 0x0831_kTextEncodingISO2022KR    = 0x0840end enum// EUC collections begin at 0x900begin enum_kTextEncodingEUCJP = 0x0920// ISO 646, 1-byte katakana, JIS 208, JIS 212_kTextEncodingEUCCN = 0x0930// ISO 646, GB 2312-80_kTextEncodingEUCTW = 0x0931// ISO 646, CNS 11643-1992 Planes 1-16_kTextEncodingEUCKR = 0x0940// ISO 646, KS C 5601-1987end enum// Misc standards begin at 0xA00begin enum_kTextEncodingShiftJIS       = 0x0A01// plain Shift-JIS_kTextEncodingKOI8R          = 0x0A02// Russian internet standard_kTextEncodingBig5           = 0x0A03// Big-5 (has variants)_kTextEncodingMacRomanLatin1 = 0x0A04// Mac OS Roman permuted to align with ISO Latin-1_kTextEncodingHZGB2312       = 0x0A05// HZ (RFC 1842, for Chinese mail & news)_kTextEncodingBig5HKSCS1999  = 0x0A06// Big-5 with Hong Kong special char set supplementend enum// Other platform encodingsbegin enum_kTextEncodingNextStepLatin = 0x0B01// NextStep encodingend enum// EBCDIC & IBM host encodings begin at 0xC00begin enum_kTextEncodingEBCDICUS    = 0x0C01// basic EBCDIC-US_kTextEncodingEBCDICCP037 = 0x0C02// code page 037, extended EBCDIC (Latin-1 set) for US,Canada...end enum#define UnicodeMapVersion as SInt32begin enum_kUnicodeUseLatestMapping  = -1_kUnicodeUseHFSPlusMapping = 4end enum//#define RegionCode as SInt16toolbox fn UpgradeScriptInfoToTextEncoding (ScriptCode iTextScriptID,LangCode iTextLanguageID,RegionCode iRegionID,str255 iTextFontname,TextEncoding * oEncoding) = OSStatustoolbox fn CreateTextEncoding (TextEncodingBase encodingBase,TextEncodingVariant encodingVariant,TextEncodingFormat encodingFormat) = TextEncodingtoolbox fn GetTextEncodingBase (TextEncoding encoding) = TextEncodingBasebegin enum_kUnicodeUseFallbacksBit       = 0_kUnicodeKeepInfoBit           = 1_kUnicodeDirectionalityBits    = 2_kUnicodeVerticalFormBit       = 4_kUnicodeLooseMappingsBit      = 5_kUnicodeStringUnterminatedBit = 6_kUnicodeTextRunBit            = 7_kUnicodeKeepSameEncodingBit   = 8_kUnicodeForceASCIIRangeBit    = 9_kUnicodeNoHalfwidthCharsBit   = 10_kUnicodeTextRunHeuristicsBit  = 11end enumbegin enum_kUnicodeUseFallbacksMask       = 1<<_kUnicodeUseFallbacksBit_kUnicodeKeepInfoMask           = 1<<_kUnicodeKeepInfoBit_kUnicodeDirectionalityMask     = 3<<_kUnicodeDirectionalityBits_kUnicodeVerticalFormMask       = 1<<_kUnicodeVerticalFormBit_kUnicodeLooseMappingsMask      = 1<<_kUnicodeLooseMappingsBit_kUnicodeStringUnterminatedMask = 1<<_kUnicodeStringUnterminatedBit_kUnicodeTextRunMask            = 1<<_kUnicodeTextRunBit_kUnicodeKeepSameEncodingMask   = 1<<_kUnicodeKeepSameEncodingBit_kUnicodeForceASCIIRangeMask    = 1<<_kUnicodeForceASCIIRangeBit_kUnicodeNoHalfwidthCharsMask   = 1<<_kUnicodeNoHalfwidthCharsBit_kUnicodeTextRunHeuristicsMask  = 1<<_kUnicodeTextRunHeuristicsBitend enum#define TextToUnicodeInfo as pointertoolbox fn ConvertFromUnicodeToText( UnicodeToTextInfo iUniToTxtInfo,┬                                             ByteCount iUniLen,┬                                               UniChar iUniCharArrayPtr,┬                                            OptionBits iCntrlFlags,┬                                             ItemCount iOffset,┬                                            ByteOffset iOffsetArrayPtr,┬                                           ItemCount * oOffset,┬                                            ByteOffset oOffsetArrayPtr,┬                                             ByteCount iOutBufLen,┬                                           ByteCount * oInRead,┬                                           ByteCount * oOutLen,┬                                              pointer oOutStr) = OSStatustoolbox fn ConvertFromTextToUnicode( TextToUnicodeInfo iTxtToUniInfo,┬                                             ByteCount iSrcLen,┬                                               pointer iSrcStr,┬                                            OptionBits iCntrlFlags,┬                                             ItemCount iOffset,┬                                            ByteOffset iOffsetArrayPtr,┬                                           ItemCount * oOffset,┬                                            ByteOffset oOffsetArrayPtr,┬                                             ByteCount iOBufLen,┬                                           ByteCount * oSrcRead,┬                                           ByteCount * oUniLen,┬                                              UniChar  oUnicodeArrayPtr) = OSStatustoolbox fn CreateTextToUnicodeInfo( pointer iUnicodeMapping ,TextToUnicodeInfo * oTextToUnicodeInfo) = OSStatustoolbox fn DisposeTextToUnicodeInfo( TextToUnicodeInfo * ioTextToUnicodeInfo) = OSStatustoolbox fn CreateTextToUnicodeInfoByEncoding( TextEncoding iEncoding, TextToUnicodeInfo *oTextToUnicodeInfo ) = OSStatustoolbox fn ConvertFromPStringToUnicode( TextToUnicodeInfo iTextToUnicodeInfo, Str255 iPascalStr, ByteCount iOutputBufLen, ByteCount *oUnicodeLen, UniChar *oUnicodeStr ) = OSStatus#endiftoolbox fn FSGetDataForkName( HFSUniStr255 * dataForkName ) = OSErrtoolbox fn FSGetResourceForkName( HFSUniStr255 * resourceForkName ) = OSErrtoolbox fn FSCreateResourceFile(┬const FSRef * ╩╩╩╩╩╩╩╩╩parentRef,┬UniCharCount ╩╩╩╩╩╩╩╩╩╩nameLength,┬const UniChar * ╩╩╩╩╩╩╩name,┬FSCatalogInfoBitmap ╩╩╩whichInfo,┬const FSCatalogInfo * ╩catalogInfo,┬UniCharCount ╩╩╩╩╩╩╩╩╩╩forkNameLength,┬const UniChar * ╩╩╩╩╩╩╩forkName,┬FSRef * ╩╩╩╩╩╩╩╩╩╩╩╩╩╩╩newRef,┬FSSpec * ╩╩╩╩╩╩╩╩╩╩╩╩╩╩newSpec) = OSErrtoolbox fn FSOpenResourceFile(┬const FSRef * ╩╩╩ref,┬UniCharCount ╩╩╩╩forkNameLength,┬const UniChar * ╩forkName,┬SInt8 ╩╩╩╩╩╩╩╩╩╩╩permissions,┬SInt16 * ╩╩╩╩╩╩╩╩refNum) = OSErrtoolbox fn FSOpenResFile( const FSRef * ref, SInt8 permission ) = SInt16toolbox fn FSResourceFileAlreadyOpen( const FSRef * resourceFileRef, Boolean * inChain, SInt16 * refNum ) = Booleantoolbox fn FSCreateFileUnicode( const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo, FSRef *newRef, FSSpec *newSpec ) = OSErrtoolbox fn FSMakeFSRefUnicode( const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, TextEncoding textEncodingHint, FSRef *newRef ) = OSErrtoolbox fn FSOpenFork( const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName, SInt8 permissions, SInt16 *forkRefNum ) = OSErrtoolbox fn FSCloseFork( SInt16 forkRefNum ) = OSErr