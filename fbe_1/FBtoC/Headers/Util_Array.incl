/*  Util_Array.incl  Bernie Wylde 20170414  1.0.1*/BeginCDeclarationCFMutableArrayRef ArrayWithCapacity( UInt32 numItems );CFArrayRef ArrayWithContentsOfURL( CFURLRef url );CFArrayRef ArrayWithObject( CFTypeRef obj );CFArrayRef ArrayWithObjects( CFTypeRef obj, ... );CFTypeRef ArrayFirstObject( CFArrayRef array );CFTypeRef ArrayLastObject( CFArrayRef array );Boolean ArrayWriteToURL( CFArrayRef array, CFURLRef url, Boolean atomically );EndCBeginCFunctionCFMutableArrayRef ArrayWithCapacity( UInt32 numItems ){ return (CFMutableArrayRef)[NSMutableArray arrayWithCapacity:numItems]; }CFArrayRef ArrayWithContentsOfURL( CFURLRef url ){ return (CFArrayRef)[NSMutableArray arrayWithContentsOfURL:(NSURL *)url]; }CFArrayRef ArrayWithObject( CFTypeRef obj ){ return (CFArrayRef)[NSArray arrayWithObject:(id)obj]; }CFArrayRef ArrayWithObjects( CFTypeRef obj, ... ){     va_list ap;     va_start( ap, obj );     NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];     while ( obj ) {          [array addObject:obj];          obj = va_arg( ap, id );     }     va_end( ap );     return (CFArrayRef)array;}CFTypeRef ArrayFirstObject( CFArrayRef array ){ #if __MAC_OS_X_VERSION_MAX_ALLOWED > 1080     return (CFTypeRef)[(NSArray *)array firstObject];#else     return (CFTypeRef)[(NSArray *)array objectAtIndex:0];#endif}CFTypeRef ArrayLastObject( CFArrayRef array ){ return (CFTypeRef)[(NSArray *)array lastObject]; }Boolean ArrayWriteToURL( CFArrayRef array, CFURLRef url, Boolean atomically ){ return [(NSArray *)array writeToURL:(NSURL *)url atomically:atomically]; }EndC/*  ArrayWithCapacity( numItems )  Creates and returns an autoreleased CFMutableArray object with enough allocated memory to initially hold a given number of objects  Params:    numItems - The initial capacity of the new array  Return value: A new CFMutableArray object with enough allocated memory to hold numItems objects*/toolbox fn ArrayWithCapacity( UInt32 numItems ) = CFMutableArrayRef/*  ArrayWithContentsOfURL( url )  Creates and returns an autoreleased array containing the contents specified by a given URL  Params:    url - The location of a file containing a string representation of an array  Return value: An array containing the contents specified by url. Returns nil if the location can’t be opened or if the contents of the location can’t be parsed into an array*/toolbox fn ArrayWithContentsOfURL( CFURLRef url ) = CFArrayRef/*  ArrayWithObject( obj )  Creates and returns an autoreleased array containing a given object  Params:    obj - An object  Return value: An array containing the single element (obj)*/toolbox fn ArrayWithObject( CFTypeRef obj ) = CFArrayRef/*  ArrayWithObjects( obj, ... )  Creates and returns an autoreleased array containing the objects in the argument list  Params:    obj - The first object for the array  Return value: An autoreleased array containing the objects in the argument list*/toolbox fn ArrayWithObjects( CFTypeRef obj, ... ) = CFArrayRef/*  ArrayFirstObject( array )     // macOS 10.9  The first object in the array*/toolbox fn ArrayFirstObject( CFArrayRef array ) = CFTypeRef/*  ArrayLastObject( array )  The last object in the array*/toolbox fn ArrayLastObject( CFArrayRef array ) = CFTypeRef/*  ArrayWriteToURL( array, url, atomically )  Writes the contents of the array to the location specified by a given URL  Params:    array - The array to write    url   - The location at which to write the array    atomically - If YES, the array is written to an auxiliary location, and then the auxiliary location is renamed to url.                 If NO, the array is written directly to url.                 The YES option guarantees that url, if it exists at all, won’t be corrupted even if the system should crash during writing  Return value: true if the location is written successfully, otherwise false*/toolbox fn ArrayWriteToURL( CFArrayRef array, CFURLRef url, Boolean atomically ) = Boolean