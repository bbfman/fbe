/*   CFPrefs.incl   by Robert Purves & Bernie Wylde,   May 2005   FBtoC mods: 18 July 2007  bw   Changes 20081204  bw     - CFPrefsSynchronize changed to CFPrefsAppSynchronize     - Two new functions CFPrefsCopyAppValue & CFPrefsSetAppValue*/include "Tlbx CFPreferences.incl"begin globalsdim as CFStringRef   sCFPrefsApplicationIDend globalslocal fn CFPrefsSetApplicationID( appID as CFStringRef )'~'1if ( sCFPrefsApplicationID == 0 ) then sCFPrefsApplicationID = appIDend fnlocal fn CFPrefsGetApplicationID as CFStringRef'~'1if ( sCFPrefsApplicationID == 0 ) then fn CFPrefsSetApplicationID( kCFPreferencesCurrentApplication )end fn = sCFPrefsApplicationID// write to disk now; not normally necessarylocal fn CFPrefsAppSynchronize as Boolean '~'1end fn = fn CFPreferencesAppSynchronize( fn CFPrefsGetApplicationID() )local fn CFPrefsCopyAppValue( key as Str255 ) as CFTypeRef'~'1dim as CFTypeRef     typeRef : typeRef = 0dim as CFStringRef   keyStrkeyStr = fn CFStringCreateWithPascalString( 0, key, _kCFStringEncodingMacRoman )long if ( keyStr )typeRef = fn CFPreferencesCopyAppValue( keyStr, fn CFPrefsGetApplicationID() )CFRelease( keyStr )end ifend fn = typeReflocal fn CFPrefsSetAppValue( key as Str255, value as CFTypeRef )'~'1dim as CFStringRef   keyStrkeyStr = fn CFStringCreateWithPascalString( 0, key, _kCFStringEncodingMacRoman )long if ( keyStr )CFPreferencesSetAppValue( keyStr, value, fn CFPrefsGetApplicationID() )CFRelease( keyStr ) //  rp 20090907end ifend fnlocal fn CFPrefsGetBool( key as Str255, @value as ^Boolean, default as Boolean )'~'1dim as CFStringRef   keyStrdim as Boolean       fromPrefs : fromPrefs = _falsekeyStr = fn CFStringCreateWithPascalString( 0, key, _kCFStringEncodingMacRoman )long if ( keyStr )value.nil` = fn CFPreferencesGetAppBooleanValue( keyStr, fn CFPrefsGetApplicationID(), @fromPrefs )CFRelease( keyStr )end ifif ( fromPrefs == _false ) then value.nil` = defaultend fn = fromPrefslocal fn CFPrefsSetBool( key as Str255, value as Boolean )'~'1long if ( value )fn CFPrefsSetAppValue( key, kCFBooleanTrue )xelsefn CFPrefsSetAppValue( key, kCFBooleanFalse )end ifend fnlocal fn CFPrefsGetLong( key as Str255, @value as ^long, default as long )'~'1dim as CFStringRef   keyStrdim as Boolean       fromPrefs : fromPrefs = _falsekeyStr = fn CFStringCreateWithPascalString( 0, key, _kCFStringEncodingMacRoman )long if ( keyStr )value.nil& = fn CFPreferencesGetAppIntegerValue( keyStr, fn CFPrefsGetApplicationID(), @fromPrefs )CFRelease( keyStr )end ifif ( fromPrefs == _false ) then value.nil& = defaultend fn = fromPrefslocal fn CFPrefsSetLong( key as Str255, setVal as long )'~'1dim as CFNumberRef   valueRefvalueRef = fn CFNumberCreate( _nil, _kCFNumberIntType, @setVal )long if ( valueRef )fn CFPrefsSetAppValue( key, valueRef )CFRelease( valueRef )end ifend fnlocal fn CFPrefsGetDbl( key as Str255, @value as ^double, default as double )'~'1dim as CFNumberRef   valueRefdim as Boolean       fromPrefs : fromPrefs = _falsevalueRef = fn CFPrefsCopyAppValue( key )long if ( valueRef )long if (fn CFGetTypeID( valueRef ) == fn CFNumberGetTypeID() )fromPrefs = fn CFNumberGetValue( valueRef, _kCFNumberFloat64Type, #value )end ifCFRelease( valueRef )end ifif ( fromPrefs == _false ) then value.nil# = defaultend fn = fromPrefslocal fn CFPrefsSetDbl( key as Str255, setVal as double )'~'1dim as CFNumberRef   valueRefvalueRef = fn CFNumberCreate( _nil, _kCFNumberFloat64Type, @setVal )long if ( valueRef )fn CFPrefsSetAppValue( key, valueRef )CFRelease( valueRef )end ifend fnlocal fn CFPrefsGetPString( key as Str255, @s as ^Str255, default as Str255 )'~'1dim as CFStringRef   stringdim as Boolean       fromPrefs : fromPrefs = _falsestring = fn CFPrefsCopyAppValue( key )long if ( string )long if (fn CFGetTypeID( string ) == fn CFStringGetTypeID() )fromPrefs = fn CFStringGetPascalString( string, s, 256, _kCFStringEncodingMacRoman )end ifCFRelease( string )end ifif ( fromPrefs == _false ) then s.nil$ = defaultend fn = fromPrefslocal fn CFPrefsSetPString( key as Str255, s as Str255 )'~'1dim as CFStringRef   stringstring = fn CFStringCreateWithPascalString( 0, s, _kCFStringEncodingMacRoman )long if ( string )fn CFPrefsSetAppValue( key, string )CFRelease( string )end ifend fnlocal fn CFPrefsGetRect( key as Str255, r as ^Rect, default as ^Rect )'~'1dim as Str255    sdim as long      charPosdim as Boolean   fromPrefsfromPrefs = fn CFPrefsGetPString( key, @s, "" )long if ( fromPrefs )charPos = 0r.top = val&( mid$( s, charPos ) )charPos = instr( charPos, s, "," ) + 1r.left = val&( mid$( s, charPos ) )charPos = instr( charPos, s, "," ) + 1r.bottom = val&( mid$( s, charPos ) )charPos = instr( charPos, s, "," ) + 1r.right = val&( mid$( s, charPos ) )end ifif ( fromPrefs == _false ) then BlockMove( default, r, sizeof(Rect) )end fn = fromPrefslocal fn CFPrefsSetRect( key as Str255, r as ^Rect )'~'1dim as Str255   ss = str$( r.top ) + "," + str$( r.left ) + "," + str$( r.bottom ) + "," + str$( r.right )fn CFPrefsSetPString( key, s )end fn// CFPrefsGetBytes takes no default parameter.local fn CFPrefsGetBytes( key as Str255, p as pointer, maxSize as long )'~'1dim as CFDataRef     dataRefdim as CFIndex       sizedim as Boolean       fromPrefs : fromPrefs = _falsedataRef = fn CFPrefsCopyAppValue( key )long if ( dataRef )long if ( fn CFGetTypeID( dataRef) == fn CFDataGetTypeID() )size = fn CFDataGetLength( dataRef )long if ( size <= maxSize )CFDataGetBytes( dataRef, fn CFRangeMake( 0, size ), p )fromPrefs = _trueend ifend ifCFRelease( dataRef )end ifend fn = fromPrefslocal fn CFPrefsSetBytes( key as Str255, p as pointer, size as long )'~'1dim as CFDataRef   dataRefdataRef = fn CFDataCreate( 0, p, size )long if ( dataRef )fn CFPrefsSetAppValue( key, dataRef )CFRelease( dataRef )end ifend fn// CFPrefsGetHandle takes no default parameter.// It provides a new Handle (containing the pref data) or 0 on failure.// The caller is responsiblefor disposing of the Handle.local fn CFPrefsGetHandle( key as Str255, @value as ^Handle )'~'1dim as CFDataRef   dataRefdim as CFIndex     sizedim as Handle      hdim as Boolean     fromPrefs : fromPrefs = _falsedataRef = fn CFPrefsCopyAppValue( key )long if ( dataRef )long if (fn CFGetTypeID( dataRef) == fn CFDataGetTypeID() )size = fn CFDataGetLength( dataRef )h = fn NewHandle( size )long if ( h )CFDataGetBytes( dataRef, fn CFRangeMake( 0, size ), [h] )fromPrefs = _truevalue.nil& = hend ifend ifCFRelease( dataRef )end ifif ( fromPrefs == _false ) then value.nil& = 0end fn = fromPrefs// the Handle is unchanged by CFPrefsSetHandle()local fn CFPrefsSetHandle( key as Str255, h as Handle )'~'1dim as pointer   p : p = [h]fn CFPrefsSetBytes( key, p, fn GetHandleSize( h ) )end fnlocal fn CFPrefsGetDate( key as Str255, @value as ^double, default as double )'~'1dim as CFDateRef   dateRefdim as Boolean     fromPrefs : fromPrefs = _falsedateRef = fn CFPrefsCopyAppValue( key )long if ( dateRef )long if (fn CFGetTypeID( dateRef ) == fn CFDateGetTypeID() )value.nil# = fn CFDateGetAbsoluteTime( dateRef )fromPrefs = _trueend ifCFRelease( dateRef )end ifif ( fromPrefs == _false ) then value.nil# = defaultend fn = fromPrefslocal fn CFPrefsSetDate( key as Str255, value as double )'~'1dim as CFDateRef   dateRefdateRef = fn CFDateCreate( 0, value )long if ( dateRef )fn CFPrefsSetAppValue( key, dateRef )CFRelease( dateRef )end ifend fn