/*  CFUN.incl  Bernie Wylde   December 2006    [updated 20090628]  Apple reference:  A CFUserNotification object presents a simple dialog on the screen and optionally receives feedback from the user.   The contents of the dialog can include a header, a message, an icon, up to eight text fields, a pop-up button,   up to eight radio buttons or checkboxes, and up to three ordinary buttons. Use CFUserNotification in processes that   do not otherwise have user interfaces, but may need occasional interaction with the user.  http://developer.apple.com/documentation/CoreFoundation/Reference/CFUserNotificationRef/Reference/reference.html*/include "Tlbx CFUserNotification.incl"include "Util_FileDirectory.incl"'~Private_kCFUNMaxCheckBoxes       = 8_kCFUNMaxSecureTextFields = 8_kCFUNMaxPopUpTitles      = 256_kCFUNProgressIndicatorIndeterminate = -1// indeterminate_kCFUNProgressIndicatorNoAnimation   = -2// indeterminate, no animation// flag related constants_kCFUNResponseButtonBits = 0x3_kCFUNCheckBoxBits       = 0xFF00_kCFUNPopUpSelectionBits = 0xFF000000_kCFUNPopUpSelectionMask = 0xFFFFFFFF - _kCFUNPopUpSelectionBitsbegin record CFUNInfodim as CFUserNotificationRef    refdim as CFMutableDictionaryRef   dictdim as CFMutableDictionaryRef   responseDictdim as CFOptionFlags            flagsdim as CFOptionFlags            responseFlagsdim as CFRunLoopSourceRef       runLoopSourceRefend recordlocal fn CFUN( un as ^CFUNInfo, set as Boolean )'~'1begin globalsdim as CFUNInfo   sCFUNInfoend globalslong if ( set )BlockMove( un, @sCFUNInfo, sizeof( CFUNInfo ) )xelselong if ( sCFUNInfo.dict == 0 )sCFUNInfo.dict = fn CFDictionaryCreateMutable( 0, 0, @kCFCopyStringDictionaryKeyCallBacks, @kCFTypeDictionaryValueCallBacks )end ifBlockMove( @sCFUNInfo, un, sizeof( CFUNInfo ) )end ifend fnlocal modelocal fn CFUNGetInfo( un as ^CFUNInfo )'~'1fn CFUN( #un, _false )end fnlocal modelocal fn CFUNSetInfo( un as ^CFUNInfo )'~'1fn CFUN( #un, _zTrue )end fnlocal modelocal fn CFUNSetDictValue( key as CFStringRef, string as CFStringRef )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )CFDictionarySetValue( un.dict, key, string )fn CFUNSetInfo( @un )end fnlocal modelocal fn CFUNPadArray( array as CFMutableArrayRef, index as CFIndex )'~'1dim as CFIndex   countcount = fn CFArrayGetCount( array )while ( index >= count )CFArrayAppendValue( array, fn CFSTR( "" ) )count++wendend fnlocal modelocal fn CFUNSetArrayValue( key as CFStringRef, index as CFIndex, string as CFStringRef, size as CFIndex )'~'1dim as CFUNInfo            undim as CFMutableArrayRef   arraylong if ( index < size || size == 0 )fn CFUNGetInfo( @un )array = (CFMutableArrayRef)fn CFDictionaryGetValue( un.dict, key )long if ( array == 0 )array = fn CFArrayCreateMutable( 0, size, @kCFTypeArrayCallBacks )CFDictionarySetValue( un.dict, key, array )CFRelease( array )end iffn CFUNPadArray( array, index )CFArraySetValueAtIndex( array, index, string )CFDictionarySetValue( un.dict, key, array )fn CFUNSetInfo( @un )end ifend fn'~User'~   ¥ Update/*  CFUNUpdate  OS bug:- Doesn't update flags*/local modelocal fn CFUNUpdate( timeout as CFTimeInterval )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )fn CFUserNotificationUpdate( un.ref, timeout, un.flags, un.dict )end fn'~   ¥ Release/*   CFUNRelease*/local modelocal fn CFUNRelease'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )if ( un.ref ) then CFRelease( un.ref )if ( un.runLoopSourceRef ) then CFRelease( un.runLoopSourceRef )BlockZero( @un, sizeof( CFUNInfo ) )fn CFUNSetInfo( @un )end fn'~   ¥ Header & Message/*   CFUNSetAlertHeader*/local modelocal fn CFUNSetAlertHeader( string as CFStringRef )'~'1fn CFUNSetDictValue( kCFUserNotificationAlertHeaderKey, string )end fn/*   CFUNSetAlertMessage*/local modelocal fn CFUNSetAlertMessage( string as CFStringRef )'~'1fn CFUNSetDictValue( kCFUserNotificationAlertMessageKey, string )end fn/*   CFUNSetAlert*/local modelocal fn CFUNSetAlert( alertHeader as CFStringRef, alertMessage as CFStringRef )'~'1fn CFUNSetAlertHeader( alertHeader )if ( alertMessage ) then fn CFUNSetAlertMessage( alertMessage )end fn'~   ¥ Button/*   CFUNSetDefaultButtonTitle*/local modelocal fn CFUNSetDefaultButtonTitle( string as CFStringRef )'~'1fn CFUNSetDictValue( kCFUserNotificationDefaultButtonTitleKey, string )end fn/*   CFUNSetOtherButtonTitle*/local modelocal fn CFUNSetOtherButtonTitle( string as CFStringRef )'~'1fn CFUNSetDictValue( kCFUserNotificationOtherButtonTitleKey, string )end fn/*   CFUNSetAlternateButtonTitle*/local modelocal fn CFUNSetAlternateButtonTitle( string as CFStringRef )'~'1fn CFUNSetDictValue( kCFUserNotificationAlternateButtonTitleKey, string )end fn/*   CFUNSetNoDefaultButton*/local modelocal fn CFUNSetNoDefaultButton'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )un.flags = ( un.flags || _kCFUserNotificationNoDefaultButtonFlag )fn CFUNSetInfo( @un )end fn/*   CFUNSetButtons*/local modelocal fn CFUNSetButtons( default as CFStringRef, other as CFStringRef, alternate as CFStringRef, noDefault as Boolean )'~'1fn CFUNSetDefaultButtonTitle( default )if ( other ) then fn CFUNSetOtherButtonTitle( other )if ( alternate ) then fn CFUNSetAlternateButtonTitle( alternate )if ( noDefault ) then fn CFUNSetNoDefaultButton()end fn'~   ¥ CheckBox/Radio Button/*   CFUNSetCheckBoxTitle*/local modelocal fn CFUNSetCheckBoxTitle( index as CFIndex, string as CFStringRef )'~'1fn CFUNSetArrayValue( kCFUserNotificationCheckBoxTitlesKey, index, string, _kCFUNMaxCheckBoxes )end fn/*   CFUNSetCheckBoxChecked*/local modelocal fn CFUNSetCheckBoxChecked( index as CFIndex )'~'1dim as CFUNInfo   unlong if ( index < _kCFUNMaxCheckBoxes )fn CFUNGetInfo( @un )un.flags = ( un.flags || fn CFUserNotificationCheckBoxChecked( index ) )fn CFUNSetInfo( @un )end ifend fn/*   CFUNCheckBoxChecked*/local modelocal fn CFUNCheckBoxChecked( index as CFIndex )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )end fn = ( ( un.responseFlags && fn CFUserNotificationCheckBoxChecked( index ) ) != 0 )/*   CFUNSetUseRadioButtons*/local modelocal fn CFUNSetUseRadioButtons'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )un.flags = ( un.flags || _kCFUserNotificationUseRadioButtonsFlag )fn CFUNSetInfo( @un )end fn/*   CFUNSelectedRadioButton*/local modelocal fn CFUNSelectedRadioButton'~'1dim as CFUNInfo   undim as UInt8      value, btnfn CFUNGetInfo( @un )value = ( ( un.responseFlags && _kCFUNCheckBoxBits ) >> 8 )btn = 8dobtn--if ( value && bit(btn) ) then exit untiluntil ( btn == 0 )end fn = btn/*   CFUNSetCheckBox*/local modelocal fn CFUNSetCheckBox( index as CFIndex, title as CFStringRef, checked as Boolean )'~'1fn CFUNSetCheckBoxTitle( index, title )if ( checked ) then fn CFUNSetCheckBoxChecked( index )end fn'~   ¥ TextField/*   CFUNSetTextFieldTitle*/local modelocal fn CFUNSetTextFieldTitle( index as CFIndex, string as CFStringRef )'~'1fn CFUNSetArrayValue( kCFUserNotificationTextFieldTitlesKey, index, string, 0 )end fn/*   CFUNSetTextFieldValue*/local modelocal fn CFUNSetTextFieldValue( index as CFIndex, string as CFStringRef )'~'1fn CFUNSetArrayValue( kCFUserNotificationTextFieldValuesKey, index, string, 0 )end fn/*   CFUNSetSecureTextField*/local modelocal fn CFUNSetSecureTextField( index as CFIndex )'~'1dim as CFUNInfo   unlong if ( index < _kCFUNMaxSecureTextFields )fn CFUNGetInfo( @un )un.flags = ( un.flags || fn CFUserNotificationSecureTextField( index ) )fn CFUNSetInfo( @un )end ifend fn/*   CFUNSetTextField   set title, value and isSecure in one call*/local modelocal fn CFUNSetTextField( index as CFIndex, title as CFStringRef, value as CFStringRef, isSecure as Boolean )'~'1if ( title ) then fn CFUNSetTextFieldTitle( index, title )if ( value ) then fn CFUNSetTextFieldValue( index, value )if ( isSecure ) then fn CFUNSetSecureTextField( index )end fn/*   CFUNSetSecureTextField*/local modelocal fn CFUNTextFieldValue( index as CFIndex ) as CFStringRef'~'1dim as CFUNInfo      undim as CFStringRef   string : string = 0fn CFUNGetInfo( @un )string = fn CFUserNotificationGetResponseValue( un.ref, kCFUserNotificationTextFieldValuesKey, index )end fn = string/*   CFUNTextFieldValueAsPascalString*/local modelocal fn CFUNTextFieldValueAsPascalString( index as CFIndex ) as Str255'~'1dim as CFUNInfo      undim as Str255        s : s[0] = 0dim as CFStringRef   stringfn CFUNGetInfo( @un )string = fn CFUNTextFieldValue( index )if ( string ) then fn CFStringGetPascalString( string, @s, 256, _kCFStringEncodingMacRoman )end fn = s/*   CFUNTextFieldArray*/local modelocal fn CFUNTextFieldArray as CFArrayref'~'1dim as CFUNInfo     undim as CFArrayRef   array : array = 0fn CFUNGetInfo( @un )long if ( un.responseDict )array = fn CFDictionaryGetValue( un.responseDict, kCFUserNotificationTextFieldValuesKey )end ifend fn = array'~   ¥ PopUp/*   CFUNSetPopUpTitle*/local modelocal fn CFUNSetPopUpTitle( index as CFIndex, string as CFStringRef )'~'1fn CFUNSetArrayValue( kCFUserNotificationPopUpTitlesKey, index, string, _kCFUNMaxPopUpTitles )end fn/*   CFUNSetPopUpSelection*/local modelocal fn CFUNSetPopUpSelection( index as CFIndex )'~'1dim as CFUNInfo   unlong if ( index < _kCFUNMaxPopUpTitles )fn CFUNGetInfo( @un )un.flags = ( un.flags && _kCFUNPopUpSelectionMask )un.flags = ( un.flags || fn CFUserNotificationPopUpSelection( index ) )fn CFUNSetInfo( @un )end ifend fn/*   CFUNPopUpSelection*/local modelocal fn CFUNPopUpSelection'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )end fn = ( un.responseFlags >> 24 )'~   ¥ ProgressIndicator/*  CFUNSetProgressIndicatorValue  value:  0.0 - 1.0  _kCFUNProgressIndicatorIndeterminate (-1) = indeterminate  _kCFUNProgressIndicatorNoAnimation (-2) = indeterminate, no animation*/local modelocal fn CFUNSetProgressIndicatorValue( value as double )'~'1dim as CFUNInfo      undim as CFStringRef   stringfn CFUNGetInfo( @un )selectcase ( value >= 0.0 && value <= 1.0 )string = fn CFStringCreateWithPascalString( 0, str$(value), _kCFStringEncodingMacRoman )long if ( string )CFDictionarySetValue( un.dict, kCFUserNotificationProgressIndicatorValueKey, string )CFRelease( string )end ifcase _kCFUNProgressIndicatorIndeterminateCFDictionarySetValue( un.dict, kCFUserNotificationProgressIndicatorValueKey, kCFBooleanTrue )case _kCFUNProgressIndicatorNoAnimationCFDictionarySetValue( un.dict, kCFUserNotificationProgressIndicatorValueKey, kCFBooleanFalse )end selectfn CFUNSetInfo( @un )end fn/*   CFUNProgressIndicatorValue   OS bug:   Always returns zero*//*local modelocal fn CFUNGetProgressIndicatorValue as double'~'1dim as CFUNInfo     undim as CFStringRef  stringdim as double       valuevalue = 0.0fn CFUNGetInfo( @un )long if ( un.responseDict )string = fn CFDictionaryGetValue( un.responseDict, kCFUserNotificationProgressIndicatorValueKey )long if ( string )select ( string )case fn CFBooleanTrue()  : value = _kCFUNProgressIndicatorIndeterminatecase fn CFBooleanFalse() : value = _kCFUNProgressIndicatorNoAnimationcase else                : value = fn CFStringGetDoubleValue( string )end selectend ifend ifend fn = value*/'~   ¥ IconURL/*   CFUNSetIconURL*/local modelocal fn CFUNSetIconURL( url as CFURLRef )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )CFDictionarySetValue( un.dict, kCFUserNotificationIconURLKey, url )fn CFUNSetInfo( @un )end fn/*   CFUNSetIconFromBundleResource*/local modelocal fn CFUNSetIconFromBundleResource( resourceName as CFStringRef )'~'1dim as CFURLRef   urlurl = fn CFBundleCopyResourceURL( fn CFBundleGetMainBundle(), resourceName, 0, 0 )long if ( url )fn CFUNSetIconURL( url )CFRelease( url )end ifend fn/*   CFUNSetIconFSRef*/local modelocal fn CFUNSetIconFSRef( ref as ^FSRef )'~'1dim as CFURLRef   urlfn FD_FSRefCreateCFURL( #ref, @url ) long if ( url )fn CFUNSetIconURL( url )CFRelease( url )end ifend fn/*   CFUNSetIconFSSpec*/local modelocal fn CFUNSetIconFSSpec( spec as ^FSSpec )'~'1dim as CFURLRef   urlfn FD_FSSpecCreateCFURL( #spec, @url )long if ( url )fn CFUNSetIconURL( url )CFRelease( url )end ifend fn'~   ¥ Localization URL/*   CFUNSetLocalizationURL*/local modelocal fn CFUNSetLocalizationURL( url as CFURLRef )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )CFDictionarySetValue( un.dict, kCFUserNotificationLocalizationURLKey, url )fn CFUNSetInfo( @un )end fn'~   ¥ Response/*   CFUNReceiveResponse*/local modelocal fn CFUNReceiveResponse( timeout as CFTimeInterval )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )fn CFUserNotificationReceiveResponse( un.ref, timeout, @un.responseFlags )un.responseDict = (CFMutableDictionaryRef)fn CFUserNotificationGetResponseDictionary( un.ref )fn CFUNSetInfo( @un )end fn = ( un.responseFlags && _kCFUNResponseButtonBits )/*   CFUNSetResponse*/local modelocal fn CFUNSetResponse( ref as CFUserNotificationRef, flags as CFOptionFlags )'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )un.ref = refun.responseFlags = flagsun.responseDict = (CFMutableDictionaryRef)fn CFUserNotificationGetResponseDictionary( ref )fn CFUNSetInfo( @un )end fn/*   CFUNResponseButton*/local modelocal fn CFUNResponseButton'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )end fn = ( un.responseFlags && _kCFUNResponseButtonBits )/*   CFUNResponseFlags*/local modelocal fn CFUNResponseFlags'~'1dim as CFUNInfo   unfn CFUNGetInfo( @un )end fn = un.responseFlags'~   ¥ Create/*   CFUNCreate*/local modelocal fn CFUNCreate( flags as CFOptionFlags, timeout as CFTimeInterval, callback as pointer ) as CFOptionFlags'~'1dim as CFUNInfo        undim as CFOptionFlags   response : response = 0fn CFUNGetInfo( @un )if ( un.ref ) then CFRelease( un.ref )long if ( fn CFDictionaryGetValue( un.dict, kCFUserNotificationAlertHeaderKey ) == 0 )fn CFDictionarySetValue( un.dict, kCFUserNotificationAlertHeaderKey, kCFUserNotificationAlertHeaderKey )end ifun.flags = ( un.flags || flags )un.ref = fn CFUserNotificationCreate( 0, timeout, un.flags, #0, un.dict )fn CFUNSetInfo( @un )long if ( callback )un.runLoopSourceRef = fn CFUserNotificationCreateRunLoopSource( _kCFAllocatorDefault, un.ref, callback, 0 )long if ( un.runLoopSourceRef )CFRunLoopAddSource( fn CFRunLoopGetCurrent(), un.runLoopSourceRef, kCFRunLoopCommonModes )CFRunLoopRun()end ifxelseresponse = fn CFUNReceiveResponse( timeout )end ifend fn = response/*   CFUNDisplayAlert*/local modelocal fn CFUNDisplayAlert( timeout as CFTimeInterval, flags as CFOptionFlags, Â                         iconURL as CFURLRef, soundURL as CFURLRef, localizationURL as CFURLRef, Â                         alertHeader as CFStringRef, alertMessage as CFStringRef, Â                         defaultButtonTitle as CFStringRef, alternateButtonTitle as CFStringRef, otherButtonTitle as CFStringRef, Â                         responseFlags as ^CFOptionFlags )'~'1end fn = fn CFUserNotificationDisplayAlert( timeout, flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle, alternateButtonTitle, otherButtonTitle, (ptr)@responseFlags )/*   CFUNDisplayNotice*/local modelocal fn CFUNDisplayNotice( timeout as CFTimeInterval, flags as CFOptionFlags, iconURL as CFURLRef, soundURL as CFURLRef, localizationURL as CFURLRef, alertHeader as CFStringRef, alertMessage as CFStringRef, defaultButtonTitle as CFStringRef )'~'1end fn = fn CFUserNotificationDisplayNotice( timeout, flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle )/*   CFUNAsk   Build simple ask dialog containing app icon, header, messsage, field title, edit field, cancel and OK buttons.*/local modelocal fn CFUNAsk( alertHeader as CFStringRef, alertMessage as CFStringRef, fieldTitle as CFStringRef, fieldValue as CFStringRef, isSecure as Boolean ) as CFStringRef'~'1dim as CFStringRef   string, answer : answer = 0string = fn CFBundleGetValueForInfoDictionaryKey( fn CFBundleGetMainBundle(), fn CFSTR( "CFBundleIconFile" ) )if ( string ) then fn CFUNSetIconFromBundleResource( string )fn CFUNSetAlert( alertHeader, alertMessage )fn CFUNSetTextField( 0, fieldTitle, fieldValue, isSecure )fn CFUNSetOtherButtonTitle( fn CFSTR( "Cancel" ) )select ( fn CFUNCreate( _kCFUserNotificationPlainAlertLevel, 0, 0 ) )case _kCFUserNotificationDefaultResponse : answer = fn CFRetain( fn CFUNTextFieldValue( 0 ) )end selectfn CFUNRelease()end fn = answer/*   CFUNAskPascalString*/local modelocal fn CFUNAskPascalString( alertHeaderPS as Str255, alertMessagePS as Str255, fieldTitlePS as Str255, fieldValuePS as Str255, isSecure as Boolean ) as Str255'~'1dim as Str255        answerPS : answerPS[0] = 0dim as CFStringRef   alertHeader, alertMessage, fieldTitle, fieldValue, answeralertMessage = 0fieldTitle = 0fieldValue = 0alertHeader = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, alertHeaderPS, _kCFStringEncodingMacRoman )if ( alertMessagePS[0] ) then alertMessage = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, alertMessagePS, _kCFStringEncodingMacRoman )if ( fieldTitlePS[0] ) then fieldTitle = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, fieldTitlePS, _kCFStringEncodingMacRoman )if ( fieldValuePS[0] ) then fieldValue = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, fieldValuePS, _kCFStringEncodingMacRoman )answer = fn CFUNAsk( alertHeader, alertMessage, fieldTitle, fieldValue, isSecure )long if ( answer )fn CFStringGetPascalString( answer, @answerPS, 256, _kCFStringEncodingMacRoman )CFRelease( answer )end ifCFRelease( alertHeader )if ( alertMessage ) then CFRelease( alertMessage )if ( fieldTitle ) then CFRelease( fieldTitle )if ( fieldValue ) then CFRelease( fieldValue )end fn = answerPS