/*A range of convenience functions for common operations on directories (folders).Many of the functions apply more generally to any file object: a file, directory or volume.See the sections below:Format ConversionGet File Object by PathGet File Object's PathGet Parent DirectoryCreate DirectoryGet Application DirectorySpecial DirectoriesFile Object Exists- Most functions are provided in three variants: for FSRef, CFURLRef, or FSSpec.- An output parameter, if present, is always the last in the parameter list.- Functions FD_XxxxYyyyCreateCFURL() pass back a CFURLRef, which if non-zero,   must be released (CFRelease) later by the caller, to avoid a memory leak.- Many functions return an error code (_noErr on success).*/// updated to retreive 'system' constants from Util_PathUtilities.incl.// this allows use of both Util_FileDirectory.incl and Util_FileManager.incl at the same time// without 'redefined variable' errors. Bernie found the issue and fix.// NSPathUtilities.h// search path directories/*system UInt32 NSApplicationDirectorysystem UInt32 NSDemoApplicationDirectorysystem UInt32 NSDeveloperApplicationDirectorysystem UInt32 NSAdminApplicationDirectorysystem UInt32 NSLibraryDirectorysystem UInt32 NSDeveloperDirectorysystem UInt32 NSUserDirectorysystem UInt32 NSDocumentationDirectorysystem UInt32 NSDocumentDirectorysystem UInt32 NSCoreServiceDirectorysystem UInt32 NSAutosavedInformationDirectory system UInt32 NSDesktopDirectory system UInt32 NSCachesDirectorysystem UInt32 NSApplicationSupportDirectorysystem UInt32 NSDownloadsDirectorysystem UInt32 NSInputMethodsDirectorysystem UInt32 NSMoviesDirectorysystem UInt32 NSMusicDirectorysystem UInt32 NSPicturesDirectorysystem UInt32 NSPrinterDescriptionDirectorysystem UInt32 NSSharedPublicDirectorysystem UInt32 NSPreferencePanesDirectorysystem UInt32 NSApplicationScriptsDirectory system UInt32 NSItemReplacementDirectorysystem UInt32 NSAllApplicationsDirectorysystem UInt32 NSAllLibrariesDirectory system UInt32 NSTrashDirectory// search path domainssystem UInt32 NSUserDomainMasksystem UInt32 NSLocalDomainMasksystem UInt32 NSNetworkDomainMasksystem UInt32 NSSystemDomainMasksystem UInt32 NSAllDomainsMask*/include "Util_PathUtilities.incl"include "Tlbx MoreFilesX.incl"include "Util_FileDirectory.h"include "Util_FileDirectory.c"include "SystemDirectoryCopyURL.h"include "SystemDirectoryCopyURL.m"_kCFURLFSRefConversionErr = -32021_kCFURLCreationErr        = -32022/*Format Conversion:Convert from one file identifier to another. The first parameter is the input identifier and the second is the output identifier. For example,FD_FSRefCreateCFURL() takes a pointer to an FSRef as inputand passes back a CFURLRef. Note that a CFURLRef passed back, if non-zero, must be released (CFRelease) later by the caller.FD_CFURLGetFSRef() and FD_FSSpecGetFSRef() fail with an error code if the object does not exist.*/toolbox fn FD_FSRefCreateCFURL( FSRef *ref, CFURLRef *outUrl ) = OSStatustoolbox fn FD_CFURLGetFSRef( CFURLRef url, FSRef *outRef ) = OSStatus#if ndef _LP64toolbox fn FD_FSRefGetFSSpec( FSRef *ref, FSSpec *outSpec ) = OSStatustoolbox fn FD_CFURLGetFSSpec( CFURLRef url, FSSpec *outSpec ) = OSStatustoolbox fn FD_FSSpecGetFSRef( FSSpec *spec, FSRef *outRef ) = OSStatustoolbox fn FD_FSSpecCreateCFURL( FSSpec *spec, CFURLRef *outUrl ) = OSStatus#endif /* ndef _LP64 *//*Get File Object by Path:Inputs: A path (or partial path) as a CFStringRef. If the CFStringRef represents a partial path,a reference to the parent directory (i.e. the starting point of the partial path) must be supplied.Output: An FSRef, CRURLRef or FSSpec depending on which function is used. FD_CFURLCreatePath() passes back a CFURLRef that, if non-zero, must be released (CFRelease) by the caller.To use the partial-path option a start directory is supplied as the second parameter.FD_PathGetFSRef( path, 0, @ref )   // full path (zero in second parameter = full path)FD_PathGetFSRef( path, @parRef, @ref )  // path is relative to parRefFor example,  to obtain the FSRef of a folder or file within the application folder, do something like:fn FD_ApplicationDirectoryGetFSRef( @appRef ) // get an FSRef to the application's folderfn FD_PathGetFSRef( fn CFSTR( "My internal folder/My file.txt" ), @appRef, @ref )Where the full path may be something like:/Users/myUserID/Documents/My Projects Folder/My Great App Folder/My internal folder/My file.txt*/toolbox fn FD_PathGetFSRef( CFStringRef path, FSRef *parRef, FSRef *outRef ) = OSStatustoolbox fn FD_PathCreateCFURL( CFStringRef path, CFURLRef parUrl, CFURLRef *outUrl ) = OSStatus#if ndef _LP64toolbox fn FD_PathGetFSSpec( CFStringRef path, FSSpec *parSpec, FSSpec *outSpec ) = OSStatus#endif /* ndef _LP64 *//*Get File Object's Path:The FD_XxxxCreatePath functions take an FSRef, CFURLRef or FSSpec as input, and pass back a CFStringRef representing the full path to the file object. The CFStringRef, if non-zero, must be released (CFRelease) by the caller.*/toolbox fn FD_FSRefCreatePath( FSRef *ref, CFStringRef *outPath ) = OSStatustoolbox fn FD_CFURLCreatePath( CFURLRef url, CFStringRef *outPath ) = OSStatus#if ndef _LP64toolbox fn FD_FSSpecCreatePath( FSSpec *spec, CFStringRef *outPath ) = OSStatus#endif /* ndef _LP64 *//*Get Parent Directory:Obtain a file object's enclosing folder. For example, if folder B is inside folder A and the FSRef of folder B is known,FD_ParentDirectoryGetFSRef() with folder B's FSRef as the first parameter would returnthe FSRef of Folder A via the second parameter ('parRef').The CFURLRef passed back by FD_ParentDirectoryCreateCFURL() must be released (CFRelease) by the caller.*/toolbox fn FD_ParentDirectoryGetFSRef( FSRef *ref, FSRef *outParRef ) = OSStatustoolbox fn FD_ParentDirectoryCreateCFURL( CFURLRef url, CFURLRef *outParUrl ) = OSStatus#if ndef _LP64toolbox fn FD_ParentDirectoryGetFSSpec( FSSpec *spec, FSSpec *outParSpec ) = OSStatus#endif /* ndef _LP64 *//*Create Directory:Inputs: Name of the new directory as a CFStringRef and a reference to the parent directory.For example, to create a new folder/directory named 'B' insideexisting directory/folder 'A' (i.e. parent directory), once we have an FSRef of folder 'A', FD_CreateDirectoryWithFSRef()would pass back the FSRef (via outDirRef) of the newly created directory.The CFURLRef passed back by FD_CreateDirectoryWithCFURL() must be released (CFRelease) by the caller.*/toolbox fn FD_CreateDirectoryWithFSRef( CFStringRef name, FSRef *parRef, FSRef *outDirRef ) = OSStatustoolbox fn FD_CreateDirectoryWithCFURL( CFStringRef name, CFURLRef parUrl, CFURLRef *outDirUrl ) = OSStatus#if ndef _LP64toolbox fn FD_CreateDirectoryWithFSSpec( CFStringRef name, FSSpec *parSpec, FSSpec *outDirSpec ) = OSStatus#endif /* ndef _LP64 *//*Get Application Directory:Pass back the FSRef, CFURLRef or FSSpec of the directory for the currently runningapplication. The CFURLRef passed back by FD_ApplicationDirectoryCreateCFURL() must be released (CFRelease) by the caller.*/toolbox fn FD_ApplicationDirectoryGetFSRef( FSRef *outAppDirRef ) = OSStatustoolbox fn FD_ApplicationDirectoryCreateCFURL( CFURLRef *outAppDirUrl ) = OSStatus#if ndef _LP64toolbox fn FD_ApplicationDirectoryGetFSSpec( FSSpec *outAppDirSpec ) = OSStatus#endif /* ndef _LP64 *//*Special Directories:Retrieves a reference to various special folders.These functions are convenient wrappers for the toolbox FSFindFolder(). Not all special folderconstants are provided in the wrappers but the programmer can look up the domain constants and folder type constants (in Folder Manager Reference within the Xcode documentation) and either callone of the FD_SpecialDirectoryXxxx functions or FSFindFolder() directly. //// 03-August-2012 Brian - Changes to all FD_SpecialDirectoryxxxxxx functions//// Updated to avoid deprecattion of FSFindFolder() in OS X 10.8// Now calls Cocoa method via SystemDirectoryCopyURL()//// Input to function has changed.// Instead of the old Folder.h constants ( such as kUserDomain, kDesktopFolderTypeetc. which are also deprecated ),// it uses the 'NS' constants such as NSUserDomainMask, NSApplicationSupportDirectory, NSDownloadsDirectory etc. )      If these constants aren't available, define them in your project like so:// NSPathUtilities.h// search path directoriessystem UInt32 NSLibraryDirectorysystem UInt32 NSApplicationSupportDirectorysystem UInt32 NSDesktopDirectory// search path domainssystem UInt32 NSUserDomainMasksystem UInt32 NSLocalDomainMasksystem UInt32 NSNetworkDomainMasksystem UInt32 NSSystemDomainMasksystem UInt32 NSAllDomainsMask    */_kUserDomain = -32763toolbox fn FD_SpecialDirectoryGetFSRef( UInt32 domain, UInt32 whichDirectory, FSRef *outRef ) = OSStatus// Brian 20141017 - now returns an OSStatustoolbox fn FD_SpecialDirectoryCreateCFURL( UInt32 domain, UInt32 whichDirectory, CFURLRef *outUrl ) = OSStatus#if ndef _LP64toolbox fn FD_SpecialDirectoryGetFSSpec( UInt32 domain, UInt32 whichDirectory, FSSpec *outSpec ) = OSStatus#endif /* ndef _LP64 *//*File Object (file, directory or volume) Exists:These functions are used to query the existence of a file, directory or volume.The Boolean return value is non-zero if the object exists, otherwise _false.The FSRef version requires the name of the file object as a CFStringRef along with the FSRef of the parent directory (parRef).The other two functions provide the same output but accept CFURLRef and an FSSpec.*/toolbox fn FD_ObjectExistsFSRef( CFStringRef name, FSRef *parRef ) = Booleantoolbox fn FD_ObjectExistsCFURL( CFURLRef url ) = Boolean#if ndef _LP64toolbox fn FD_ObjectExistsFSSpec( FSSpec *spec ) = Boolean#endif /* ndef _LP64 */// renametoolbox fn FD_RenameObjectFSRef( FSRef *ref, CFStringRef newName, FSRef *outRef ) = OSStatus // outRef may be 0// querytoolbox fn FD_IsDirectoryFSRef( FSRef *ref ) = Boolean