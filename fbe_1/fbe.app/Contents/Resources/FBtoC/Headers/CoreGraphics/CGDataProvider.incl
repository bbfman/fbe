/*   Translated to FB using         HeadToHead       by Bernie Wylde         ----------        5 January 2009*//* CoreGraphics - CGDataProvider.h * Copyright (c) 1999-2006 Apple Computer, Inc. * All rights reserved.*/#if ndef _DEFINEDINCARBON#define CGDataProviderRef as pointer/* This callback is called to copy `count' bytes from the sequential data* stream to `buffer'. *///typedef size_t (*CGDataProviderGetBytesCallback)(void *info, void *buffer, size_t count);#define CGDataProviderGetBytesCallback as pointer/* This callback is called to skip `count' bytes forward in the sequential * data stream. It should return the number of bytes that were actually* skipped. *///typedef off_t (*CGDataProviderSkipForwardCallback)(void *info, off_t count);#define CGDataProviderSkipForwardCallback as pointer/* This callback is called to rewind to the beginning of sequential data* stream. */#define CGDataProviderRewindCallback as pointer/* This callback is called to release the `info' pointer when the data* provider is freed. */#define CGDataProviderReleaseInfoCallback as pointer/* Callbacks for sequentially accessing data. * `version' is the version of this structure. It should be set to 0. * `getBytes' is called to copy `count' bytes from the sequential data * stream to `buffer'. It should return the number of bytes copied, or 0 * if there's no more data. * `skipForward' is called to skip ahead in the sequential data stream by * `count' bytes. * `rewind' is called to rewind the sequential data stream to the beginning * of the data. * `releaseInfo', if non-NULL, is called to release the `info' pointer when* the provider is freed. */begin record CGDataProviderSequentialCallbacksdim as unsigned long                      versiondim as CGDataProviderGetBytesCallback     getBytesdim as CGDataProviderSkipForwardCallback  skipForwarddim as CGDataProviderRewindCallback       rewinddim as CGDataProviderReleaseInfoCallback  releaseInfoend record/* This callback is called to get a pointer to the entire block of data. *///typedef const void *(*CGDataProviderGetBytePointerCallback)(void *info);#define CGDataProviderGetBytePointerCallback as pointer/* This callback is called to release the pointer to entire block of* data. *///typedef void (*CGDataProviderReleaseBytePointerCallback)(void *info, const void *pointer);#define CGDataProviderReleaseBytePointerCallback as pointer/* This callback is called to copy `count' bytes at byte offset `position'* into `buffer'. *///typedef size_t (*CGDataProviderGetBytesAtPositionCallback)(void *info, void *buffer, off_t position, size_t count);#define CGDataProviderGetBytesAtPositionCallback as pointer/* Callbacks for directly accessing data. * `version' is the version of this structure. It should be set to 0. * `getBytePointer', if non-NULL, is called to return a pointer to the * provider's entire block of data. * `releaseBytePointer', if non-NULL, is called to release a pointer to the * provider's entire block of data. * `getBytesAtPosition', if non-NULL, is called to copy `count' bytes at * offset `position' from the provider's data to `buffer'. It should * return the number of bytes copied, or 0 if there's no more data. * `releaseInfo', if non-NULL, is called to release the `info' pointer when * the provider is freed. * * At least one of `getBytePointer' or `getBytesAtPosition' must be* non-NULL. */begin record CGDataProviderDirectCallbacksdim as unsigned long                             versiondim as CGDataProviderGetBytePointerCallback      getBytePointerdim as CGDataProviderReleaseBytePointerCallback  releaseBytePointerdim as CGDataProviderGetBytesAtPositionCallback  getBytesAtPositiondim as CGDataProviderReleaseInfoCallback         releaseInfoend record/* Return the CFTypeID for CGDataProviderRefs. */toolbox fn CGDataProviderGetTypeID = CFTypeID// AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* Create a sequential-access data provider using `callbacks' to provide* the data. `info' is passed to each of the callback functions. */toolbox fn CGDataProviderCreateSequential( pointer info, const CGDataProviderSequentialCallbacks *callbacks ) = CGDataProviderRef// AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Create a direct-access data provider using `callbacks' to supply `size'* bytes of data. `info' is passed to each of the callback functions. *///CG_EXTERN CGDataProviderRef CGDataProviderCreateDirect(void *info, off_t size, const CGDataProviderDirectCallbacks *callbacks) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;toolbox fn CGDataProviderCreateDirect( pointer info, long size, const CGDataProviderDirectCallbacks *callbacks ) = CGDataProviderRef// AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* The callback used by `CGDataProviderCreateWithData'. *///typedef void (*CGDataProviderReleaseDataCallback)(void *info, const void *data, size_t size);#define CGDataProviderReleaseDataCallback as pointer/* Create a direct-access data provider using `data', an array of `size' * bytes. `releaseData' is called when the data provider is freed, and is* passed `info' as its first argument. */// CG_EXTERN CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData);toolbox fn CGDataProviderCreateWithData( pointer info, pointer data, UInt32 size, CGDataProviderReleaseDataCallback releaseData ) = CGDataProviderRef/* Create a direct-access data provider which reads from `data'. */toolbox fn CGDataProviderCreateWithCFData( CFDataRef data ) = CGDataProviderRef// AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Create a data provider reading from `url'. */toolbox fn CGDataProviderCreateWithURL( CFURLRef url ) = CGDataProviderRef/* Create a data provider reading from `filename'. */toolbox fn CGDataProviderCreateWithFilename( pointer filename ) = CGDataProviderRef/* Equivalent to `CFRetain(provider)', but doesn't crash (as CFRetain does)* if `provider' is NULL. */toolbox fn CGDataProviderRetain( CGDataProviderRef provider ) = CGDataProviderRef/* Equivalent to `CFRelease(provider)', but doesn't crash (as CFRelease* does) if `provider' is NULL. */toolbox CGDataProviderRelease( CGDataProviderRef provider )/* Return a copy of the data specified by provider. Returns NULL if a * complete copy of the data can't be obtained (for example, if the* underlying data is too large to fit in memory). */toolbox fn CGDataProviderCopyData( CGDataProviderRef provider ) = CFDataRef // 10.5/* Deprecated API. *//* This callback is called to skip `count' bytes forward in the sequential* data stream. *///typedef void (*CGDataProviderSkipBytesCallback)(void *info, size_t count);#define CGDataProviderSkipBytesCallback as pointer/* Old-style callbacks for sequentially accessing data. * `getBytes' is called to copy `count' bytes from the sequential data * stream to `buffer'. It should return the number of bytes copied, or 0 * if there's no more data. * `skipBytes' is called to skip ahead in the sequential data stream by * `count' bytes. * `rewind' is called to rewind the sequential data stream to the beginning * of the data. * `releaseProvider', if non-NULL, is called to release the `info' pointer* when the provider is freed. */begin record CGDataProviderCallbacksdim as CGDataProviderGetBytesCallback     getBytesdim as CGDataProviderSkipBytesCallback    skipBytesdim as CGDataProviderRewindCallback       rewinddim as CGDataProviderReleaseInfoCallback  releaseProviderend record/* This callback is called to copy `count' bytes at byte offset `offset'* into `buffer'. *///typedef size_t (*CGDataProviderGetBytesAtOffsetCallback)(void *info, void *buffer, size_t offset, size_t count);#define CGDataProviderGetBytesAtOffsetCallback as pointer/* Callbacks for directly accessing data. * `getBytePointer', if non-NULL, is called to return a pointer to the * provider's entire block of data. * `releaseBytePointer', if non-NULL, is called to release a pointer to the * provider's entire block of data. * `getBytes', if non-NULL, is called to copy `count' bytes at offset * `offset' from the provider's data to `buffer'. It should return the * number of bytes copied, or 0 if there's no more data. * `releaseProvider', if non-NULL, is called when the provider is freed. ** At least one of `getBytePointer' or `getBytes' must be non-NULL. */begin record CGDataProviderDirectAccessCallbacksdim as CGDataProviderGetBytePointerCallback      getBytePointerdim as CGDataProviderReleaseBytePointerCallback  releaseBytePointerdim as CGDataProviderGetBytesAtOffsetCallback    getBytesdim as CGDataProviderReleaseInfoCallback         releaseProviderend record/* Create a sequential-access data provider using `callbacks' to provide* the data. `info' is passed to each of the callback functions. */toolbox fn CGDataProviderCreate( pointer info, const CGDataProviderCallbacks *callbacks ) = CGDataProviderRef// AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;/* Create a direct-access data provider using `callbacks' to supply `size'* bytes of data. `info' is passed to each of the callback functions. */toolbox fn CGDataProviderCreateDirectAccess( pointer info, UInt32 size, const CGDataProviderDirectAccessCallbacks *callbacks ) = CGDataProviderRef// AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;#endif// _DEFINEDINCARBON