// CGDisplayConfiguration.h#if ndef _DEFINEDINCARBON#define CGDisplayConfigRef as pointer // opaque#endif// CGDisplayFade.h#if ndef _DEFINEDINCARBON#define CGDisplayFadeReservationToken as UInt32#define CGDisplayBlendFraction as float#define CGDisplayFadeInterval as float#define CGDisplayReservationInterval as float#endif/* Values for the limits of the fade. `kCGDisplayBlendNormal' represents a   normal display state. `kCGDisplayBlendSolidColor' represents a display   blended to a solid color */system float kCGDisplayBlendNormal, kCGDisplayBlendSolidColor/* Set the display fade time and color for a display reconfigure operation.   Call this function after `CGBeginDisplayConfiguration' and before   `CGCompleteDisplayConfiguration'.   When `CGCompleteDisplayConfiguration' is called, a fade-out effect will   occur prior to the display reconfiguration. When the reconfiguration is   complete, control returns to the calling program; the fade-in effect runs   asynchronously. */toolbox fn CGConfigureDisplayFadeEffect(CGDisplayConfigRef config,Â  CGDisplayFadeInterval fadeOutSeconds, CGDisplayFadeInterval fadeInSeconds,Â  float fadeRed, float fadeGreen, float fadeBlue) = OSStatus/* It may be desirable to perform fade operations at other times, such as   when transitioning between game play and cinematic sequences. The   following API provides a mechanism for controlling display fade   operations outside of display mode reconfigurations. *//* Return a reservation token for the display hardware. Before performing a   fade operation, the caller must reserve the hardware for the expected   period of time that the program will be doing fades.   Failing to release the hardware by the end of the reservation interval   will result in the reservation token becomingn invalid, and the hardware   being unfaded back to a normal state. The reservation interval is limited   to a maximum of 15 seconds and should be greater than zero. */system float kCGMaxDisplayReservationIntervaltoolbox fn CGAcquireDisplayFadeReservation(CGDisplayReservationIntervalÂ  seconds, CGDisplayFadeReservationToken *token) = OSStatus/* Release a display fade reservation, and unfades the display if needed.   The reservation token is no longer valid after this operation.    `CGReleaseDisplayFadeReservation' may be safely called while an   asynchronous fade operation is running; if the ending blend value is   `kCGDisplayBlendNormal', this will not disturb the running operation. The   reservation is dropped when the fade operation completes. */toolbox fn CGReleaseDisplayFadeReservation( CGDisplayFadeReservationToken token ) = OSStatus/* Perform a fade operation. The reservation token `token' must have been   previously acquired from `CGAcquireDisplayFadeReservation'. The duration   of the fade is specified by `duration'. The starting and ending values of   the alpha component of the desired blend color are specified by   `startBlend' and `endBlend', respectively. The RGB blend color is   specified by the three components `(redBlend, greenBlend, blueBlend)'. If   the operation should be synchronous, specify true for `synchronous',   otherwise specify false.   Over the fade operation time interval, the system interpolates the   blending coefficient between the specified starting and ending values,   applying a nonlinear (sine-based) bias term, and blends the video output   with the specified color based on the resulting value.   If the time interval is specifed as 0, then the ending state blend value   is applied at once and the function returns.   The maximum allowable time interval is 15 seconds.   If the `synchronous' is true, the function does not return until the fade   operation is complete. If false, the function returns at once, and the   fade operation runs asynchronously.      To perform a two-second fade-to-black, waiting until complete:     CGDisplayFade(token,     2,    // 2 seconds      kCGDisplayBlendNormal, // Starting state      kCGDisplayBlendSolidColor, // Ending state      0, 0, 0,   // black      true);   // Wait for completion    To perform a two-second fade-from-black to normal, without waiting for   completion:     CGDisplayFade(token,     2,    // 2 seconds      kCGDisplayBlendSolidColor, // Starting state      kCGDisplayBlendNormal, // Ending state      0, 0, 0,   // black      false);   // Don't wait for completion */toolbox fn CGDisplayFade( CGDisplayFadeReservationToken token,Â  CGDisplayFadeInterval duration, CGDisplayBlendFraction startBlend,Â  CGDisplayBlendFraction endBlend, float redBlend, float greenBlend,Â  float blueBlend, boolean synchronous) = OSStatus/* Return true if a fade operation is currently in progress, false   otherwise. */toolbox fn CGDisplayFadeOperationInProgress() = boolean