// This file is for private use by the FBtoC runtime// That means you should not call any of these FNs in your code.//// It is included via FBRuntime.inclinclude "ConsoleApp.c"include "ConsoleApp.h"include "Tlbx MacTextEditor.incl"include "Tlbx MoreFilesX.incl"include "Util_FileDirectory.incl"_FBConsoleWndNum = 31276792 // arbitrary but picked( by RP ) to avoid conflict with user-assigned file ids. Brian 20170306local modelocal fn CA_SetTXNObjectWordWrap( txtObject as TXNObject, wrap as Boolean ) as OSStatus'~'1dim as TXNControlData   cDatadim as TXNControlTag    taglong if ( wrap )cData.uValue = _kTXNAutoWrapxelsecData.uValue = _kTXNNoAutoWrapend iftag = _kTXNWordWrapStateTagend fn = fn TXNSetTXNObjectControls( txtObject, _false, 1, @tag, @cData )// privatebegin globalsdim as WindowRef    sConsoleWindowdim as HIViewRef    sConsoleHITextView, sConsoleScrollViewdim as TXNObject    sConsoleTXNObjectend globals_FBConsoleleftMarginHITextView = 5 // looks better than 0, and easier for selectionlocal fn BuildWholeWindowHITextView( w as WindowRef, wrap as Boolean ) as HIViewRef'~'1dim as Rect             rdim as HIRect           hiRectdim as HIViewRef        scrollView, txtView, contentViewdim as OptionBits       scrollOptionsdim as TXNFrameOptions  txnOptionsdim as HILayoutInfo     layoutInfotxnOptions = 0 // 0 has same effect as _kTXNAlwaysWrapAtViewEdgeBit; text is wrapped with either option :-(// horiz scroll bar doesn't work, i.e. its thumb is never drawn //scrollOptions = _kHIScrollViewOptionsVertScroll || _kHIScrollViewOptionsHorizScroll || _kHIScrollViewOptionsAllowGrowscrollOptions = _kHIScrollViewOptionsVertScroll + _kHIScrollViewOptionsAllowGrow call HIViewFindByID( fn HIViewGetRoot( w ), kHIViewWindowContentID, @contentView )call HIScrollViewCreate( scrollOptions, @scrollView )call HIViewAddSubview( contentView, scrollView )call GetWindowPortBounds( w, @r )hiRect.origin.x = _FBConsoleleftMarginHITextViewhiRect.origin.y = 0.0hiRect.size.width  = r.right - _FBConsoleleftMarginHITextViewhiRect.size.height = r.bottomcall HIViewSetFrame( scrollView, @hiRect )call HITextViewCreate( @hiRect, 0, txnOptions, @txtView )// turns off wrapping OK, but a horiz scroll bar (if present) is not brought into useif ( wrap == _false ) then fn CA_SetTXNObjectWordWrap( fn HITextViewGetTXNObject( txtView ), _false ) call HIViewSetVisible( txtView, _true )call HIViewAddSubview( scrollView, txtView )call HIViewSetVisible( scrollView, _true )// set scrollView's layout to resize with windowlayoutInfo.version = _kHILayoutInfoVersionZerocall HIViewGetLayoutInfo( scrollView, @layoutInfo ) layoutInfo.binding.top.toView    = 0layoutInfo.binding.top.kind      = _kHILayoutBindToplayoutInfo.binding.left.toView   = 0layoutInfo.binding.left.kind     = _kHILayoutBindLeftlayoutInfo.binding.bottom.toView = 0layoutInfo.binding.bottom.kind   = _kHILayoutBindBottomlayoutInfo.binding.right.toView  = 0layoutInfo.binding.right.kind    = _kHILayoutBindRightcall HIViewSetLayoutInfo( scrollView, @layoutInfo )call SetUserFocusWindow( w )call SetKeyboardFocus( w, txtView, _kControlFocusNextPart )end fn = txtViewlocal fn SaveConsoleTXNObjectToTextFile( fs as ^FSSpec )'~'1dim as short      refNumDFdim as FSSpec     tempSpecdim as OSStatus   errerr = fn FSMakeFSSpec( fs.vRefNum, fs.parID, fs.name, @tempSpec )long if ( err == _fnfErr )err = fn FSpCreate( #fs, 0, _"TEXT", _smSystemScript )end ifif ( err == _noErr ) then err = fn FSpOpenDF( #fs, _fsRdWrPerm, @refNumDF )if ( err == _noErr ) then err = fn SetEOF( refNumDF, 0 ) // null out file// Last parameter -1 means "don't save anything in resource fork".if ( err == _noErr ) then err = fn TXNSave( sConsoleTXNObject, _kTXNTextFile, 0, _kTXNMacOSEncoding, #fs, refNumDF, -1 )if ( err == _noErr ) then err = fn FSClose( refNumDF )stringlist runif ( err ) then call StandardAlert (_kAlertNoteAlert, "Error "  + str$( err ) + " while saving " + fs.name, "", 0, #0 )stringlist end fn = errlocal modelocal fn GetConsolePreferredFontDescription( iFontName as Str255, oDefaults as ^TXNMacOSPreferredFontDescription )'~'1dim as short @ nnGetFNum( iFontName, @nn )oDefaults.fontID    = nnoDefaults.pointSize = 12<<16 // 12 ptoDefaults.fontStyle = _kTXNDefaultFontStyleoDefaults.encoding  = fn CreateTextEncoding( _kTextEncodingMacRoman, _kTextEncodingDefaultVariant, _kTextEncodingDefaultFormat )end fnlocal modelocal fn CA_SetTXNSelectionFontSize( txtObject as TXNObject, start as TXNOffset, finish as TXNOffset, fontSize as short )'~'1dim as TXNTypeAttributes attrattr.tag  = _kTXNQDFontSizeAttributeattr.size = _kTXNFontSizeAttributeSizeattr.data.dataValue = fontSize << 16end fn = fn TXNSetTypeAttributes( txtObject, 1, @attr, start, finish )local modelocal fn CA_SetTXNSelectionFontName( txtObject as TXNObject, start as TXNOffset, finish as TXNOffset, fontName as Str255 )'~'1dim as TXNTypeAttributes attrattr.tag  = _kTXNQDFontNameAttributeattr.size = _kTXNQDFontNameAttributeSizeattr.data.dataValue = @fontNameend fn = fn TXNSetTypeAttributes( txtObject, 1, @attr, start, finish )void local fn BuildConsoleWindow'~'1dim as TXNMacOSPreferredFontDescription  defaultFontDescriptiondim as Rect ÊÊÊÊÊÊÊÊÊÊÊÊÊrdim as WindowAttributes Êwadim as WindowRef ÊÊÊÊÊÊÊÊw// We initialize TXN as a workaround in order to get Monaco with a read-only TXNObject.// A read-only TXNObject's font apparently can't be changed after creation via HITextViewCreate()fn GetConsolePreferredFontDescription( "Monaco", @defaultFontDescription )call TXNInitTextension( @defaultFontDescription, 1, 0 ) SetRect( @r, 0, 0, 0, 0 )wa = Ê_kWindowStandardHandlerAttribute + _kWindowCompositingAttributewa += Ê_kWindowStandardDocumentAttributes + _kWindowLiveResizeAttributestringlist runappearance window -_FBConsoleWndNum, @"FB Console", @r, _kDocumentWindowClass, wastringlistget window _FBConsoleWndNum, @wfn GetAvailableWindowPositioningBounds( fn GetMainDevice(), @r )r.right = 700r.left = 5r.bottom -=5fn SetWindowBounds( w, _kWindowStructureRgn, @r )window _FBConsoleWndNumsConsoleWindow = wsConsoleHITextView = fn BuildWholeWindowHITextView( w, _zTrue )sConsoleScrollView = fn HIViewGetSuperview( sConsoleHITextView ) // parent viewsConsoleTXNObject Ê= fn HITextViewGetTXNObject( sConsoleHITextView )fn CA_SetTXNSelectionFontName( sConsoleTXNObject, _kTXNEndOffset, _kTXNEndOffset, "Monaco" )fn CA_SetTXNSelectionFontSize( sConsoleTXNObject, _kTXNEndOffset, _kTXNEndOffset, 12 ) end fnvoid local fn ConsolePrintCFType( typeRef as CFTypeRef )'~'1dim as CFStringRef ÊÊoldText, newTextoldText = fn HIViewCopyText( sConsoleHITextView )newText = fn CFStringCreateWithFormat( _kCFAllocatorDefault, #0, @"%@%@\r", oldText, typeRef )CFRelease( oldText )fn HIViewSetText( sConsoleHITextView, newText )CFRelease( newText )end fnlocal modevoid local fn ConsolePrintCFString( string as CFStringRef )'~'1dim as Str255 ÊÊÊÊÊÊÊpascalChunkdim as CFStringRef ÊÊchunkdim as CFIndex ÊÊÊÊÊÊj, fullLength, chunkLengthj = 0chunkLength = 255fullLength = fn CFStringGetLength( string )while ( j < fullLength )if ( fullLength - j < chunkLength ) then chunkLength = fullLength - jchunk = fn CFStringCreateWithSubstring( _kCFAllocatorDefault, string, fn CFRangeMake( j, chunkLength ) )fn CFStringGetPascalString( chunk, @pascalChunk, 256, _kCFStringEncodingMacRoman )CFRelease( chunk )print pascalChunk;j += chunkLengthwendprintend fn// // files$ call below updated to use CFURLRef so it is compatible with FB 5.7.99// Unfortunately, this function calls fn SaveConsoleTXNObjectToTextFile and it requres an FSSpec.// To do: All of ConsoleWindow needs an update to use code similar to FBtoC's log window// Brian 20170307//local modelocal fn ConsoleSaveAs as OSStatus'~'1dim as FSSpec     fsdim as OSStatus   errdim as CFURLRef   urlstringlist runurl = OSPanelSave( 0, @"Untitled" )// bw 20170414if ( url )// bw 20170414//if ( files$( _URLSave,, "Untitled", url ) != "" ) // not cancelledstringlistif ( fn FD_ObjectExistsCFURL( url ) == _false )open "O",1,@urlclose 1end iferr = fn FD_CFURLGetFSSpec( url, @fs )if ( err == _noErr ) then err = fn SaveConsoleTXNObjectToTextFile( @fs )elseerr = _userCanceledErrend ifend fn = errvoid local fn ConsoleDoMenu'~'1long if menu(1) == 1fn ConsoleSaveAsend ifmenuend fn// main program'~'1stringlist runmenu 1, 0, 1, @"File"menu 1, 1, 1, @"Save As.../S"stringlistedit menu 2on menu fn ConsoleDoMenufn BuildConsoleWindowend runtime