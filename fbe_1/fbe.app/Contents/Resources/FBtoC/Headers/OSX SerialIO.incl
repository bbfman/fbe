// last mod RP   7 Aug 2004include "OSX termios.incl"include "OSX fcntl.incl"include "OSX IOSerialKeys.incl"include "OSX IOKitLib.incl"include "OSX BSD glue.incl"_kFBMaxSerialFiles = 12 // -1 to -8_kFBMaxDiskFiles   = 256  // 1 - 255#if def _DEFINEDINCARBON // suppress declaration outputbegin record FBInfoForOpenFile // shadows the declaration in FBtoC.h// all: open "UNIX", disk files, serial  dim as Boolean   isOpen, eof// open "UNIX" onlydim as pointer    pipeUNIX  // see FBOpenUNIX()// disk files only//dim as SInt16     forkRefNumdim as UInt64     savedOffsetdim as CFURLRef      url//dim as UInt32     recordSize, linePosdim as SInt64     recordSize, linePos// serial only//dim as termios   originalOptionsdim as pointer   buffdim as SInt32    buffSize, bytesInBuffdim as SInt32    fileDescriptorend record#endif#if def _DEFINEDINCRUNTIME // suppress declaration outputbegin globalsdim as FBInfoForOpenFile   gFBOpenFiles(_kFBMaxDiskFiles + _kFBMaxSerialFiles - 1) // shadows the declaration in Filehandling.cend globals#endifbegin globalsdim as UInt16  gFBSerialPortCount// Number of Serial Ports available (0 til Inited)dim as Str63   gFBSerialName(_kFBMaxSerialFiles) // Serial Device Namedim as Str63   gFBSerialInName(_kFBMaxSerialFiles) // BSD path  dim as Str63   gFBSerialOutName(_kFBMaxSerialFiles) // BSD pathdim as Boolean gOSXSerialInitedend globalslocal fn FBXSerialGetSerialIterator( matchingServices as ^io_iterator_t )'~'1dim as kern_return_t          kernResultdim as mach_port_t            masterPortdim as CFMutableDictionaryRef classesToMatchdim as Str255                 serviceNamedim as CFStringRef            key, valuekernResult = fn IOMasterPort( _MACHPORTNULL, @masterPort )if ( _KERNSUCCESS != kernResult ) then exit fnkernResult = _KERNFAILURE// Serial devices are instances of class IOSerialBSDClientserviceName = _kIOSerialBSDServiceValue$fn FBPStr2CStr( serviceName ) // -> CStringclassesToMatch = fn IOServiceMatching( @serviceName )if ( classesToMatch == 0 ) then exit fn// Each serial device object has a property with key// kIOSerialBSDTypeKey and a value that is one of kIOSerialBSDAllTypes,// kIOSerialBSDModemType, or kIOSerialBSDRS232Type.key = fn CFStringCreateWithPascalString( 0, _kIOSerialBSDTypeKey$,   _kCFStringEncodingASCII )//  _kIOSerialBSDAllTypes$ here, finds all serial devicesvalue = fn CFStringCreateWithPascalString( 0, _kIOSerialBSDAllTypes$, _kCFStringEncodingASCII )fn CFDictionarySetValue( classesToMatch, key, value )fn CFRelease( key )fn CFRelease( value )kernResult = fn IOServiceGetMatchingServices( masterPort, classesToMatch, #matchingServices )end fn = kernResult// Given an iterator across a set of serial devices, get their names and BSD paths.local fn FBXSerialGetCountAndNames( serialPortIterator as io_iterator_t )'~'1dim as io_object_t    serialServicedim as CFTypeRef      serialNameCFStr, bsdPathCFStrdim as Str255         bsdPathdim as Str255         serialDevNamedim as CFStringRef    keydim as Boolean        resultbsdPath[0] = 0 // Initialize the pathserialService = fn IOIteratorNext( serialPortIterator )while ( serialService != 0 )key             = fn CFStringCreateWithPascalString( 0, _kIOTTYDeviceKey$, _kCFStringEncodingASCII )serialNameCFStr = fn IORegistryEntryCreateCFProperty( serialService, key, 0, 0 )fn CFRelease( key )long if ( serialNameCFStr )result = fn CFStringGetPascalString( serialNameCFStr, @serialDevName, sizeof( serialDevName ), _kCFStringEncodingASCII ) fn CFRelease( serialNameCFStr )// bump count; names -> FB serial globalslong if ( result )gFBSerialPortCount++gFBSerialName(gFBSerialPortCount) = serialDevName // a name like "modem"end ifkey          = fn CFStringCreateWithPascalString( 0, _kIOCalloutDeviceKey$, _kCFStringEncodingASCII )bsdPathCFStr = fn IORegistryEntryCreateCFProperty( serialService, key, 0, 0 )fn CFRelease( key )long if ( bsdPathCFStr )result = fn CFStringGetCString( bsdPathCFStr, @bsdPath, sizeof( bsdPath ), _kCFStringEncodingASCII )fn CFRelease( bsdPathCFStr )long if ( result )fn FBCStr2PStr(bsdPath)gFBSerialOutName(gFBSerialPortCount) = bsdPath // path like  "/dec/cu.modem"gFBSerialInName(gFBSerialPortCount)  = bsdPath///print " BSD path: "; : fn PrintCString( bsdPath ) : print end ifend ifend iffn IOObjectRelease( serialService )serialService = fn IOIteratorNext( serialPortIterator )wendend fn// set input and output speeds of a termios structurelocal fn FBXSerialSetBaud( options as ^termios, speed as long )'~'1select  ( speed )case >= 230400 : speed = 230400case >= 115200 : speed = 115200case >=  76800 : speed =  76800case >=  57600 : speed =  57600case >=  38400 : speed =  38400case >=  28800 : speed =  28800case >=  19200 : speed =  19200case >=  14400 : speed =  14400case >=   9600 : speed =   9600case >=   7200 : speed =   7200case >=   4800 : speed =   4800case >=   2400 : speed =   2400case >=   1800 : speed =   1800case >=   1200 : speed =   1200case >=    600 : speed =    600case >=    300 : speed =    300case >=    200 : speed =    200case >=    150 : speed =    150case >=    134 : speed =    134case else      : speed =    110//75, 50 not availend selectend fn = fn cfsetspeed( #options, speed )// Given the path to a serial device, open the device and configure it.// Return the file descriptor associated with the device.local fn FBXOpenSerialPort( path as Str255, speed as long, parity as long, stopBits as long, charSize as long, origOptions as ^termios )'~'1dim as long     fileDescriptordim as termios  optionsdim as Str255   pathCdim as long     csizeBlockMoveData( @path, @pathC, 256 )fn FBPStr2CStr( pathC ) // make C stringfileDescriptor = fn open( (ptr)@pathC, _ORDWR || _ONOCTTY || _ONDELAY )long if ( fileDescriptor == -1 )//print "Error opening serial port"exit "FBXOpenSerialPort"end iflong if ( fn fcntl( fileDescriptor, _FSETFL, 0 ) ==  -1 )//print "Error clearing O_NDELAY"exit "FBXOpenSerialPort"end if// Get the current options and save them for later resetlong if ( fn tcgetattr( fileDescriptor, origOptions ) == -1 )//print "Error getting tty attributes"exit "FBXOpenSerialPort"end ifoptions = origOptions/*Function int cfmakeraw (struct termios *termios-p)This function provides an easy way to set up *termios-p for what has traditionallybeen called \raw mode" in BSD. This uses noncanonical input, and turns off mostprocessing to give an unmodifed channel to the terminal.It does exactly this:termios-p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);termios-p->c_oflag &= ~OPOST;termios-p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);termios-p->c_cflag &= ~(CSIZE|PARENB);termios-p->c_cflag |= CS8;*/fn cfmakeraw( @options ) // this cannot be undone, except by getting the original termios attributesoptions.c_cflag = options.c_cflag || _CLOCAL || _CREADoptions.c_lflag = options.c_lflag and not ( _ECHOE ) //( _ICANON || _ECHO || _ECHOE || _ISIG )options.c_cc[_VMIN]  = 0options.c_cc[_VTIME] = 0fn FBXSerialSetBaud( @options, speed ) //long if fn FBXSerialSetBaud( @options, speed ) //print "FBXSerialSetBaud error"//exit "FBXOpenSerialPort"//end ifselect paritycase _oddParityoptions.c_cflag = options.c_cflag || _PARENB || _PARODDcase _evenParityoptions.c_cflag = (options.c_cflag || _PARENB) and not( _PARODD )case elseoptions.c_cflag = options.c_cflag and not( _PARENB ) // default _noParityend selectlong if stopBits == _twoStopBitsoptions.c_cflag = options.c_cflag || _CSTOPBxelse // default _oneStopBit;  _halfStopBit not supportedoptions.c_cflag = options.c_cflag and not( _CSTOPB )end ifselect charSizecase _fiveBits   : csize = _CS5case _sixBits    : csize = _CS6case _sevenBits  : csize = _CS7case else        : csize = _CS8 // default _eightBits end selectoptions.c_cflag = (options.c_cflag and not( _CSIZE )) || (csize and _CSIZE)// Set the optionslong if ( fn tcsetattr( fileDescriptor, _TCSANOW, @options ) ==  -1 )//print "Error setting tty attributes"exit "FBXOpenSerialPort"end ifexit fn // Success// Failure path"FBXOpenSerialPort"if ( fileDescriptor != -1 ) then fn close( fileDescriptor ) : fileDescriptor = -1end fn = fileDescriptor_TIOCMGET = 1074033770 // see <sys/ttycom.h>_TIOCMSET = -2147191699_TIOCMDTR = 2local fn FBXHandShake( fileDescriptor as long, controlMode as long )'~'1dim as termios  optionsdim as long     flagslong if fileDescriptor > 0 // validlong if fn tcgetattr( fileDescriptor, @options ) != -1select controlModecase _noneoptions.c_cflag = options.c_cflag and not( _CRTSCTS )options.c_iflag = options.c_iflag and not( _IXON || _IXOFF || _IXANY  ) case _CTS // use CTS and RTSoptions.c_cflag = options.c_cflag || _CRTSCTSoptions.c_iflag = options.c_iflag and not( _IXON || _IXOFF || _IXANY  ) case _XON // use characters ^S and ^Ooptions.c_cflag = options.c_cflag and not( _CRTSCTS )options.c_iflag = options.c_iflag or ( _IXON || _IXOFF || _IXANY  )case _DTRlong if fn ioctl( fileDescriptor, _TIOCMGET, @flags ) != -1flags = flags || _TIOCMDTRfn ioctl( fileDescriptor, _TIOCMSET, @flags ) // raise DTRend ifcase _DTRTogglelong if fn ioctl( fileDescriptor, _TIOCMGET, @flags ) != -1flags = flags and not( _TIOCMDTR )fn ioctl( fileDescriptor, _TIOCMSET, @flags ) // lower DTRend ifend selectfn tcsetattr( fileDescriptor, _TCSANOW, @options )end ifend ifend fn//  Init Carbon Serial I/Olocal fn FBInitSerialPorts'~'1dim as io_iterator_t  @  serialPortIteratorlong if ( gOSXSerialInited == _false or gFBSerialPortCount == 0 )gOSXSerialInited = _zTruefn FBXInitBSDSystemFrameworklong if ( fn FBXSerialGetSerialIterator( @serialPortIterator ) == _noErr )// set gFBSerialPortCount, gFBSerialName etcfn FBXSerialGetCountAndNames( serialPortIterator )end ifend ifend fntoolbox FBCheckFileError( long fileID, OSStatus err ) // in FileHandling.c//OPEN "C",portID,baud[,[parity][,[stopbit][,[wordLength][,buffSize]]]]local fn FBSerialOpen( fileRef as long, baudRate as long, parity as long, stopBits as long, charSize as long, buffSize as long )'~'1dim as long      portNumdim as Str255    pathdim as pointer   buffdim as long      fddim as termios   origOptionsdim as long      iportNum = -fileReflong if ( portNum <= 0 or portNum > gFBSerialPortCount )FBCheckFileError( fileRef, _bdNamErr )  // bad port requestedexit fnend ifi = portNum + _kFBMaxDiskFileslong if ( gFBOpenFiles.fileDescriptor(i) )FBCheckFileError( fileRef, _fBsyErr )// port already openexit fnend iffn FBInitSerialPortspath = gFBSerialOutName(portNum)if ( buffSize < 4096 ) then buffSize = 4096if ( buffSize > 32768 ) then buffSize = 32768buff = fn malloc( buffSize )fd = fn FBXOpenSerialPort( path, baudRate, parity, stopBits, charSize, @origOptions )long if ( fd < 0 ) // failedfn free( buff )FBCheckFileError( fileRef, _ioErr )exit fnend if// successgFBOpenFiles.isOpen(i)          = _true//gFBOpenFiles.originalOptions(i) = origOptions  rp 20080209gFBOpenFiles.buff(i)            = buffgFBOpenFiles.buffSize(i)        = buffSizegFBOpenFiles.fileDescriptor(i)  = fdend fnlocal fn FBHandShake( fileRef as long, flags as long )'~'1dim as long      portNum, fdportNum = -fileReflong if ( portNum > 0 and portNum <= gFBSerialPortCount )fd = gFBOpenFiles.fileDescriptor(portNum + _kFBMaxDiskFiles)if ( fd ) then fn FBXHandShake( fd, flags )end ifend fnlocal fn TermGetStatus( fileRef as long ) // Is the serial port in use?'~'1dim as long   portNum, portStatus, fddim as Str255 pathCfn FBInitSerialPortsportNum = -fileReflong if ( portNum <= 0 or portNum > gFBSerialPortCount )portStatus = 3 // invalid or unknownexit fnend iflong if ( gFBOpenFiles.fileDescriptor(portNum + _kFBMaxDiskFiles) )portStatus = 2 // in use by usexit fnend ifpathC = gFBSerialOutName(portNum)fn FBPStr2CStr( pathC ) // make C stringfd = fn open( (ptr)@pathC, _ORDWR || _ONOCTTY || _ONDELAY )portStatus = 0if ( fd == -1 ) then portStatus = 2 // busy (but not by us), or not openablefn close( fd )end fn = portStatus