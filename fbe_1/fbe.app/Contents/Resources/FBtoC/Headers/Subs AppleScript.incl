/*     version November 2005     bux fix by Russ in AppleScriptLoadAndRun     AppleScriptLoadAndRun entirely rewritten (Alain Jan. 2006)*/include "Tlbx OSA.Incl"stringlist runbegin enum_gestaltAppleScriptAttr           = _"ascr"_gestaltAppleScriptPresent        = 0_gestaltAppleScriptPowerPCSupport = 1end enum_typeAppleScript     = _"ascr"_errOSAScriptError   = -1753 /*     AppleScriptAvailable returns true if AppleScript     is available and the routines defined herein can     be called.*/clear local modelocal fn AppleScriptAvailable'~'1dim @ response as long if (fn Gestalt(_gestaltAppleScriptAttr, response) != _noErr) then response = 0end fn = ((response and (1 << _gestaltAppleScriptPresent)) != 0) /*     AppleScriptLowRun compiles and runs an AppleScript     provided as text in the buffer pointed to by text.     textLength bytes will be compiled from this buffer     and run as an AppleScript using all of the default     environment and execution settings. If resultData     is not _nil, then the result returned by the execution     command will be returned as typeChar in this descriptor     record (or typeNull if there is no result information).     If the function returns errOSAScriptError, then resultData     will be set to a descriptive error message describing     the error (if one is available).*/local modelocal fn AppleScriptLowRun( @textHandlePtr as ptr, result as .str255 )'~'1dim ci                as ComponentInstancedim scriptTextDesc    as AEDesc dim resultData        as AEDesc dim err               as OSStatusdim size              as longerr = _zTrueresult.nil` = 0//  open the scripting componentci = fn OpenDefaultComponent( _kOSAComponentType, _typeAppleScript )long if ci// put the script text into an AEDescerr  = fn AECreateDesc( _typeChar, #[textHandlePtr.nil&], fn GetHandleSize( textHandlePtr.nil& ), scriptTextDesc )long if err == _noErrerr = _zTruelong if fn AECreateDesc( _typeNull, #_nil, 0, resultData ) == _noErr // Compiles, executes and returns result at onceerr = fn OSADoScript( ci, scriptTextDesc, _kOSANullScript, _typeChar, _kOSAModeAlwaysInteract, resultData )long if err == _errOSAScriptErrorfn OSAScriptError ( ci, _kOSAErrorBriefMessage, _typeChar, resultData )end iflong if err == _noErr or err == _errOSAScriptErrorsize = fn AEGetDescDataSize( resultData )long if sizeSetHandleSize( textHandlePtr.nil&, size )long if fn MemError == _noErrfn AEGetDescData( resultData, [textHandlePtr.nil&], size )if size > 255 then size = 255BlockMove( [textHandlePtr.nil&] , result + 1, size )result.nil` = sizeend ifxelsecall DisposeHandle( textHandlePtr.nil& )textHandlePtr.nil& = _nilend ifxelseresult.nil$ = "ERROR: An error has occurred."end ifxelseresult.nil$ = "ERROR: Couldn't create container for the result"end ifxelseresult.nil$ = "ERROR: Couldn't create Script"end ifxelseresult.nil$ = "ERROR: Couldn't launch AppleScript"end iffn AEDisposeDesc( scriptTextDesc )fn AEDisposeDesc( resultData )if (ci != _nil) then fn CloseComponent( ci )end fn = errlocal modelocal fn AppleScriptLowSave( theFile as .FSSpec, resID as short, scriptName as str31, @dataHandlePtr as ptr )'~'1dim ci                 as ComponentInstancedim sourceScriptDesc   as AEDesc dim compiledScriptDesc as AEDescdim resH               as Handledim oldRef             as shortdim fileRef            as shortdim err                as OSStatusdim scriptID           as OSAID dim as Handle  resH2scriptID = _kOSANullScripterr = _zTrueci  = fn OpenDefaultComponent( _kOSAComponentType, _typeAppleScript )long if cilong if dataHandlePtr.nil&err  = fn AECreateDesc( _typeChar, #[dataHandlePtr.nil&], fn GetHandleSize( dataHandlePtr.nil& ), sourceScriptDesc )long if fn AECreateDesc( _typeNull, #_nil, 0, compiledScriptDesc ) == _noErr long if fn OSACompile( ci, sourceScriptDesc, _kOSANullScript, @scriptID ) == _noErrlong if fn OSAStore( ci, scriptID, _typeOSAGenericStorage, _kOSANullScript, @compiledScriptDesc ) == _noErroldRef = fn CurResFilelong if theFilefileRef = fn FSpOpenResFile( #theFile, _fsWrPerm )long if fileRef == -1FSpCreateResFile( #theFile, _"ToyS", _"osas", _smCurrentScript )long if fn ResError == _noErrfileRef = fn FSpOpenResFile( #theFile, _fsRdWrPerm )xelsefileRef = -1end ifend ifxelsefileRef = system( _aplRes )end iflong if fileRef != -1UseResFile( fileRef )SetResLoad( _false )if resID == 0 then resID = 128resH = fn GetResource( _kOSAScriptResourceType, resID )SetResLoad( _true )if resH then RemoveResource( resH )long if fn ResError == _noErrresH2 = (Handle)compiledScriptDesc.dataHandle // fix for #316AddResource( resH2, _kOSAScriptResourceType, resID, scriptName )long if fn ResError = _noErrDisposeHandle( resH )err = _noErrxelseAddResource( resH, _kOSAScriptResourceType, resID, scriptName )ReleaseResource( resH )end ifend ifif fileRef != system( _aplRes) then call CloseResFile( fileRef )UseResFile( oldRef )end ifend ifend ifend ifend iffn AEDisposeDesc( sourceScriptDesc )fn AEDisposeDesc( compiledScriptDesc )if (scriptID != _kOSANullScript) then fn OSADispose( ci, scriptID )if (ci != _nil) then fn CloseComponent( ci )end ifend fn = errlocal fn AppleScriptStore( theFile as .FSSpec, resID as short, scriptName as str31 )'~'1dim as short err, bufferNumberbufferNumber = _toAppleScript - _toBuffererr = _zTruelong if fn AppleScriptAvailablelong if gFBBuffer(bufferNumber)err = fn AppleScriptLowSave( theFile, resID, scriptName, gFBBuffer(bufferNumber) )end ifend ifend fn = errlocal fn AppleScriptLoadAndRun( theFile as .FSSpec, resID as short )'~'1dim   ci           as ComponentInstance        dim   h            as handle                  dim   fileRef      as shortdim   curResRef    as shortdim   err          as OSAErrordim   scriptData   as AEDescdim   resultData   as AEDescdim   scriptID     as OSAIDdim   resultID     as OSAIDdim   size         as longerr = -1if fn AppleScriptAvailable = _false then exit fnci = fn OpenDefaultComponent( _kOSAComponentType, _typeAppleScript )if (ci == _nil) then exit fnscriptID = _kOSANullScriptresultID = _kOSANullScriptcurResRef = fn CurResFilelong if theFile// file specified by userfileRef = fn FSpOpenResFile( #theFile, _fsRdPerm )xelse// no file specifiedfileRef = system( _aplRes )end iferr = fn ResErrorif err != _noErr or fileRef == -1 then exit fnerr = fn AECreateDesc( _typeNull, #_nil, 0, @scriptData )if err != _noErr then exit fnif resID = 0 then resID = 128UseResFile ( fileRef )h = fn Get1Resource( _kOSAScriptResourceType, resID )if ( h ) then call DetachResource( h )err = fn ResErrorUseResFile ( curResRef )if fileRef != system( _aplRes ) then call CloseResFile( fileRef )long if err != _noErr or h == 0if h then DisposeHandle( h )fn AEDisposeDesc( scriptData )exit fnend ifscriptData.descriptorType = _typeOSAGenericStoragescriptData.dataHandle = (AEDataStorage)herr = fn HandToHand( (ptr)@scriptData.dataHandle )DisposeHandle( h )long if err == _noErrerr = fn OSALoad( ci, scriptData, _kOSAModeNull, scriptID )long if errfn AEDisposeDesc( scriptData )exit fnend ifend iflong if scriptID != _kOSANullScripterr = fn AECreateDesc( _typeNull, #0, 0, @resultData )long if err == _noErrerr = fn OSAExecute( ci, scriptID, _kOSANullScript, _kOSAModeAlwaysInteract, resultID )long if err == _noErrerr = fn OSADisplay( ci, resultID, _typeChar, _kOSAModeNull, resultData )xelselong if err = _errOSAScriptErrorerr = fn OSAScriptError ( ci, _kOSAErrorMessage, _typeChar, resultData )end ifend iflong if err == _noErrsize = fn AEGetDescDataSize( resultData )long if sizefileRef = _toAppleScript-_toBufferif gFBBuffer( fileRef ) then fn disposeH( gFBBuffer( fileRef ) )gFBBuffer( fileRef ) = fn NewHandleClear( size )err = fn MemErrorlong if err == _noErr and gFBBuffer( fileRef ) != _nilfn AEGetDescData( resultData, [gFBBuffer( fileRef )], size )end if// mem errorend if// no resultend if// OSADisplay errorend if // AECreateDesc errorend iffn AEDisposeDesc( scriptData )fn AEDisposeDesc( resultData )if (scriptID != _kOSANullScript) then fn OSADispose( ci, scriptID )if (resultID != _kOSANullScript) then fn OSADispose( ci, resultID )fn CloseComponent( ci )end fn = err/*     Runs the AppleScript stored in an FB internal     buffer.*/local fn AppleScriptRun( @result as ^str255 )'~'1dim as short bufferNumber,errbufferNumber = _toAppleScript - _toBuffererr = _zTruelong if fn AppleScriptAvailable = _falseresult.nil$ = "AppleScript is not available"xelselong if gFBBuffer(bufferNumber) = _nilresult.nil$ = "Use ROUTE _toAppleScript to store the script."xelseerr = fn AppleScriptLowRun( gFBBuffer(bufferNumber), result )end ifend ifend fn = errlocal fn AppleScriptGetResult as Handle'~'1dim as short bufferNumberdim as short bufferNumberdim textH as HandletextH = _nilbufferNumber = _toAppleScript - _toBufferlong if gFBBuffer(bufferNumber)textH = gFBBuffer(bufferNumber)long if fn HandToHand( textH ) == _noErrfn disposeh( gFBBuffer(bufferNumber ) )xelsetextH = _nilend ifend ifend fn = textHstringlist