_betterReplaceResource = 0 //  rp 20090830// Quickdraw.htoolbox fn GetPortBounds( CGrafPtr port, Rect *r ) = ptrtoolbox fn GetPortBitMapForCopyBits( CGrafPtr port ) = ptr// Events.htoolbox fn Button = Boolean#if ndef _DEFINEDINCARBON#define StringPtr as ptr#endif// ndef _DEFINEDINCARBONvoid local fn BlockFill( address as ptr, bytes as unsigned long, byteVal as long )'~'1fn memset( address, byteVal, bytes )end fnvoid local fn LongBlockFill( address as ptr, bytes as unsigned long, byteVal as long )'~'1fn memset( address, byteVal, bytes )end fn#if ndef _LP64local fn Handle2Btn( c as ControlRef )'~'1dim as ControlID   cIDbeginCCodeif ( GetControlID( c, &cID ) ) cID.id = 0;EndCend fn = cID.idvoid local fn FLASH'~'dim as CGrafPtr portdim as rect    portRectGetPort( @port)fn GetPortBounds( port, @portRect )InvertRect( portRect )FlushWindowBufferend fnvoid local fn ORSICN(x&,y&,rID&)'~'dim rHndl as handledim as ^Bitmap @PortBitmapPtrDIM src as rectdim dest as rectdim as CGrafPtr @portdim pm as BitMapsetrect(src,0,0,16,16)dest = srcoffsetrect(dest,x&,y&)rHndl = fn getresource(_"SICN",rID&)long if rHndlgetport(port)PortBitmapPtr = fn GetPortBitMapForCopyBits(port)pm.baseAddr = [rHndl]pm.rowbytes = 2pm.bounds = srccopybits(@pm,#PortBitmapPtr,src,dest,_srcOR,0)xelseframerect(dest)end ifend fn#endif /*  ndef _LP64 */void local fn DisposeH( @vPtr as ^Handle )'~'dim as Handle  hdim as char    stateh = vPtr.nil&long if hstate = fn hgetstate(h)long if state and 0x0020// rsrc HandlexelseDisposeHandle( h )vPtr.nil& = 0end ifend ifend fn#if ndef _LP64// ÊSCROLL (l,t)-(r,b),dx,dyvoid local fn FBScroll( r as ^Rect, dx as long, dy as long )'~'1dim as RgnHandle  tempRgnlong if ( dx or dy )tempRgn = fn NewRgnScrollRect( #r, dx, dy, tempRgn)DisposeRgn( tempRgn )end ifend fnlocalvoid local fn SHOWPOP(@rPtr as ^rect)'~'dim as long ifor i = 0 to 5MoveTo(rPtr.Right%-11-i,rPtr.Top%-i+11)Lineto(rPtr.Right%-11+i,rPtr.Top%-i+11)next end fn#endif /*  ndef _LP64 */void local fn CopyRect(@rect1 as ^Rect, @rect2 as ^Rect)'~'BlockMove rect1, rect2, sizeof( Rect )end fn// remove item from STR# Handle  ( was 'def' in FB, now usr to return an error)local modelocal fn RemoveStr( strH as Handle, oneBasedItem as long)'~'1dim as long count, offset, lgth, shiftdim as OSStatus errerr = _paramErrif ( strH == 0 or oneBasedItem < 1 ) then exit fnerr = 1 // no strings in strHcount = strH..nil%long if ( count )err = 2 // not enough strings in strHlong if ( oneBasedItem <= count )err = _noErroneBasedItem--offset = 2while ( oneBasedItem )offset += peek( [strH] + offset ) + 1oneBasedItem--wendlgth = peek( [strH] + offset ) + 1shift = fn GetHandleSize( strH ) - lgth - offsetBlockMoveData( [strH] + offset + lgth, [strH] + offset, shift )strH..nil%-- // string countSetHandleSize( strH, fn GetHandleSize( strH ) - lgth )end ifend ifend fn = err#if ndef _LP64void local fn SHADOWBOX( @rectPtr as ^Rect )'~'OFFSETRECT(#rectPtr,-1,-1)ERASERECT(#rectPtr)FRAMERECT(#rectPtr)moveto(rectPtr.Left%+4,rectPtr.Bottom%)Lineto(rectPtr.Right%,rectPtr.Bottom%)Lineto(rectPtr.Right%,rectPtr.Top%+3)OFFSETRECT(#rectPtr,1,1)END FNvoid local fn CheckOneItem( menuId as long, itemId as long )'~'1dim as MenuRef   m, hierdim as long      item, countdim as short   @ markm = fn GetMenuHandle ( menuID )long if ( m )count = fn CountMenuItems ( m )long if ( count )for item = 1 to countGetItemMark ( m, item, @mark )if ( mark ) then hier = fn GetMenuHandle( mark ) else hier = 0long if ( hier == _false )CheckMenuItem( m, item, (itemId == item ) )end ifnext itemend ifend ifend fn#endif /*  ndef _LP64 */include "Tlbx CFByteOrder.incl"void local fn apndstr( t$, h as Handle )'~'dim as long          oldSizelong if holdSize = fn GetHandleSize( h )SetHandleSize( h, oldSize + t$[0] + 1 )long if ( fn MemError == _noErr )BlockMoveData( @t$, [h] + oldSize&, t$[0] + 1 )h..nil% += 1xelse/*t$ = "Failed to append "" + t$ + "" to STR# handle."shutdown t$*/shutdown @"Failed to append \"t$\" to STR# handle."end ifend ifend fnvoid local fn APNDLNG( param&, h as Handle )'~'dim oldSize&long if holdSize& = fn GetHandleSize( h )SetHandleSize( h, oldSize& + 4 )long if fn MemError == _noErrpoke long [h] + oldSize&, param&end ifend ifEND FN#if ndef _LP64void local fn CBOX(@rPtr as ^rect,@StrPtr as ^str255)'~'TETextBox(StrPtr+1,peek(StrPtr),#rPtr,_teJustCenter)END FNvoid local fn LBOX(@rPtr as ^rect,@StrPtr as ^str255)'~'TETextBox(StrPtr+1,peek(StrPtr),#rPtr,_teJustLeft)END FNvoid local fn RBOX(@rPtr as ^rect,@StrPtr as ^str255)'~'TETextBox(StrPtr+1,peek(StrPtr),#rPtr,_teJustRight)END FN#endif /*  ndef _LP64 */void local fn TRUNCATE(@StrPtr as ^str255)'~'dim as UInt8 strLenstrLen = peek(StrPtr)while strLen > 0 and peek(StrPtr+strLen) = _" "dec(strLen)WENDpoke StrPtr,strLenEND FN#if ndef _LP64localvoid local fn TITLERECT( s$,xOff%,@RectPtr as ^rect)'~'framerect(#RectPtr)moveto(RectPtr.left%+xOff%,RectPtr.top%+4)call textmode(0)drawstring(s$)end fnLOCALDIM Font as FontInfolocal fn FONTHEIGHT'~'GetFontInfo(Font)END FN = Font.ascent+Font.descent+Font.leading#endif /*  ndef _LP64 */local fn ROUND(f#)'~'END FN = int(f#)local fn roundUp(f#)' { 1/18/01 cs}'~'1dim as double ffff = frac( f# )if ( ff < 0.0 or ff > 0.0 ) then f# += sgn(f#)end fn = fix(f#)local fn roundDown(f#)' { 1/18/01 cs}'~'1end fn = fix(f#)#if ndef _LP64toolbox fn FBGetWndNumber( WindowRef ) = longlocal fn Wptr2WNum( w as WindowRef )end fn = fn FBGetWndNumber( w )#endif /*  ndef _LP64 */local fn STROFFSET( element&, rID& )'~'dim offset&dim as Handle rHndloffset& = 0long if rID& >> 15 'handle?rHndl = rID&xelse 'or resource ID?rHndl = fn getresource(_"STR#", rID&)end iflong if rHndloffset& = 2LONG IF element&DEC(element&)WHILE element&offset& += PEEK( [rHndl] + offset& ) + 1DEC(element&)WENDEND IFend ifEND FN = offset&void local fn ChangedResourceX( rH AS Handle )'~'LONG IF FN HGETSTATE(rH) AND _resource%LONG IF (FN GETRESATTRS(rH) AND _resChanged%) <> _resChanged%CALL CHANGEDRESOURCE(rH)END IFEND IFEND FN#if _betterReplaceResource // Êrp 20090830// Return value is://   _noErr if add/replace succeeded//   a resource manager or memory error otherwise (e.g. _rmvRefFailed, _addResFailed)local modelocal fn ReplaceResource( dataH as Handle, resType as OSType, resID as short, resName as Str255, resFile as short ) as OSStatus'~'1dim as Handle  rH, copyDataHdim as short   curRsFiledim as OSErr   err : err = _noErrcurRsFile = fn CurResFileUseResFile( resFile )SetResLoad( _false )rH = fn Get1Resource( resType, resID )SetResLoad( _true )long if ( rH ) // existing resourceRemoveResource( rH ) // remove iterr = fn ResErrorlong if ( err ) // failed to removeReleaseResource( rH ) // dump resource handlexelseDisposeHandle( rH ) // dump plain handleend ifend ifcopyDataH = dataHif ( err == _noErr ) then err = fn HandToHand( @copyDataH ) // copy the datalong if ( err == _noErr )AddResource( copyDataH, resType, resID, resName )err = fn ResErrorlong if ( err == _noErr )ChangedResource( copyDataH )ReleaseResource( copyDataH ) // dump resource handlexelseDisposeHandle( copyDataH ) // dump plain handleend ifend ifUseResFile( curRsFile ) // restore resource chainend fn = err#else// Return value is://   0, if error occurred//   either rH or a meaningless non-zero value, otherwise //  ***INCREDIBLY** bad codelocal fn ReplaceResource(rH AS Handle, rTp AS OSType, rID AS WORD, rName AS STR255, rRef AS Word) as Handle'~'Dim hFlags AS WordDim curRes AS WordDim size   AS LONGDim osErr as OSErrDim @ newH      AS HandleDim @ rOld      AS HandleDim @ tempResTp AS ResTypeDim @ tempResID AS WordtempResTp  = rTp// record requested tp & IDtempResID  = rIDOSErr      = _noErrLONG IF rHhFlags  = FN HGETSTATE(rH)// get handle flagsLONG IF hFlags AND _resource%// is this already a res?LOADRESOURCE(rH)// make sure it's loaded#if ndef _LP64HNOPURGE(rH)// don't allow purging for the moment#endif /* ndef _LP64 */newH   = rH// prepare to copy handleFN HANDTOHAND(newH)// make a copyHSETSTATE(rH,hFlags)// reset handle flags on orig hanlerH = newH// now work with the copyEND IFEND IFLONG IF rH// do we have a potential res hndl?curRes = FN CURRESFILE// record current res fileCALL USERESFILE(rRef)// temp switch to file specified by callerrOld = FN GET1RESOURCE(rTp,rID)// does res like this already exist?LONG IF rOldhFlags = FN HGETSTATE(rOld)// record flags for existing resourceHUNLOCK(rOld)// should't be locked#if ndef _LP64HNOPURGE(rOld)// shoud be purgeable#endif /* ndef _LP64 */size = FN GETHANDLESIZE(rH)// get old sizeSETHANDLESIZE(rOld,size)// reset to new sizeOSErr  = FN MemError// check for problemsIF OSErr THEN "Dump Old, Add New"// our bailout pointBLOCKMOVE [rH],[rOld],size// all OK. copy the info into the hndlHSETSTATE(rOld,hFlags)// restore the handle state#if ndef _LP64HNOPURGE(rOld)// make it purgeable#endif /* ndef _LP64 */fn ChangedResourceX(rOld)// mark it changed if necessaryFN DISPOSeHANDLE(rH)// get rid of oldLONG IF LEN(rName)// new name sent to fn?SETRESINFO(rOld,rID,rName)// set to new textEND IFXELSESETRESLOAD(_false)// don't load. just get specsrOld = FN GET1RESOURCE(rTp,rID)// make entry for existing resCALL SETRESLOAD(_zTrue)// restore resource loading"Dump Old, Add New"// reentry point for errorLONG IF rOld// does old res hndl exist?LONG IF LEN(rName) = 0// no name offered as parameterGETRESINFO(rOld,tempResID,tempResTp,rName)// get old nameEND IFReMoVERESOURCE(rOld)// remove resource map entryfn DISPOSEH(rOld)// dump from memoryEND IF// Finally!!!ADDRESOURCE(rh,rTp,rID,rName)// add itSETRESATTRS(rh,_resPurgeable% + _reschanged%)// make sure it's purgeable'cs { 9/30/02 }END IFCALL USERESFILE(curRes)// restore original res fileLONG IF FN RESERROR OR OSErr// any errors?rH = 0// return null handle//LONG IF SYSTEM(_aplFlag) = _false// only show errors if this is an interactive run//STOP "Error replacing resource"//END IFEND IFEND IFEND FN = rH#endif /* _betterReplaceResource */#if ndef _LP64localdim as CGrafPtr  @ portdim pictH as ^^Picturedim as RgnHandle theRgndim as ^Bitmap @PortBitmapPtrlocal fn GetPict( @r as ^Rect ) as pointer // becomes generic (void*)'~'GetPort( port )pictH  = fn OpenPicture( #r )theRgn = fn NewRgn // maskRgn required in JaguarRectRgn( theRgn, #r )PortBitmapPtr = fn GetPortBitMapForCopyBits(port)CopyBits( #PortBitmapPtr, #PortBitmapPtr, #r, #r, _srcCopy, 0 )ClosePicture()DisposeRgn( theRgn )end fn = pictH localdim as CGrafPtr  @ portdim p as ^^Picturedim as rect @ portRectvoid local fn LCOPY'~'1call getport(port)fn GetPortBounds(port, @portRect )p = fn getpict( portRect )long if proute 128call drawpicture(p, portRect )call killpicture(p)route 0close lprintend ifcall Setport(port)end fn#endif /*  ndef _LP64 */localdim p&, e&void local fn ClearHandle(h as Handle)// {8-06-2007}'~'long if he = fn gethandlesize(h)p& = [h]e& = (p&+e&)-3while p& < e&poke long p&,0'4 bytes at a timep&=p&+4wende&=e&+3while p& < e&poke p&,0'last few bytesp&=p&+1wendend ifend fnvoid local fn LCASE(@sPtr as ^Str255)'~'// convert via lookup table    Robert P.  23 Feb 2001dim endAddr as ptr, addr as ptraddr = sPtrendAddr = addr.nil`` + addrwhile ( addr < endAddr )inc( addr )addr.nil`` = gFBLowerChar(addr.nil``)wendend fn#if ndef _LP64localdim r     as rectdim wPtr as WindowRefdim as CGrafPtr @portvoid local fn SmallDebugWindow(msg$)'~'2getport(port)while fn buttonwendfn FBGetScreenRect(r)r.left = r.right  - 256r.top  = r.bottom - (4*12)call offsetrect(r,-4,-4)wptr = fn newcwindow(0,r,"",_zTrue,_plainDBox,-1,_false,0)// {5/27/05} b307 constrain window to look out for docfn ConstrainWindowToScreen(wptr,_kWindowStructureRgn,_kWindowConstrainMoveRegardlessOfFit,#0,#0)long if wptrcall SetPortWindowPort( wPtr )offsetrect(r,-r.left,-r.top)call backcolor(_yellowcolor)call forecolor(_Bluecolor)eraserect(r)r.bottom = r.bottom - 12textfont(0)textsize(9)TETextBox(@msg$[1], msg$[0], r, _teForceLeft)r.top    = r.bottomr.bottom = r.bottom + 12msg$ = "Click mouse to continue."call textface(_boldBit%)call TETextBox(@msg$[1], msg$[0], r, _tejustcenter)long if fn QDIsPortBuffered( fn getwindowport(wPtr) )call QDFlushPortBuffer( fn getwindowport(wPtr), 0 )end ifdodelay 60until fn buttonwhile fn buttondelay 60wenddisposewindow(wPtr)end ifsetport(port)end fnlocal dim msg$void local fn DEBUGNUMBER(theNum#)'~'1msg$ =        "Decimal:"+str$(theNum#)+chr$(13)msg$ = msg$ + "    Hex: "+hex$(theNum#)+chr$(13)msg$ = msg$ + " Binary: "+bin$(theNum#)fn SmallDebugWindow(msg$)end fnvoid local fn DEBUGSTRING(msg$)'~'1fn SmallDebugWindow(msg$)end fnvoid local fn DEBUGRECT(r as ^rect)'~'1dim as Str255      ss  =  "   t,l,b,r:" + str$(r.top ) +  "," Â      + str$(r.left) +  "," + Â     str$(r.bottom) +  "," + str$(r.right) + chr$( 13 )s += " (l,t)-(r,b)"+ "(" +str$(r.left ) +  "," + Â      ","  + str$(r.top) +  ")-(" + Â     str$(r.right) +  "," + str$(r.bottom) + ")" + chr$( 13 )s += "      width:" + str$( r.right - r.left) + " height:" + str$(r.bottom - r.top)fn SmallDebugWindow( s )end fn// This sets the output window's background to be auto-refreshing under every condition// that I can think of, including closing an EF or button,void local fn SetWindowBackground( inBackRGB as ^RGBColor, applyNow as boolean )'~'1dim w as WindowRefdim @ port as CGrafPtrdim backRGB as ^RGBColordim portOK as Booleandim brush as ThemeBrush// {8-05-2007}GetPort( port )portOK = fn IsValidPort( port )long if portOKw = fn GetWindowFromPort( port )long if ( w )brush = inBackRGB // {8-05-2007}long if ( brush >= _kThemeBrushAlternatePrimaryHighlightColor and brush <= _kThemeBrushMenuBackgroundSelected )fn SetThemeWindowBackground( w, brush, applyNow ) // {8-05-2007}xelselong if inBackRGBbackRGB = inBackRGBRGBBackColor( #backRGB )fn SetWindowContentColor( w, #backRGB )if applyNow then clsend ifend ifend ifend ifend fnvoid local fn InvalRect( @r as ^Rect )'~'1dim as CGrafPtr  portdim as WindowRef wndGetPort( @port )wnd = fn GetWindowFromPort( port )fn InvalWindowRect( wnd, #r )end fn#endif /*  ndef _LP64 */