/*Gone in FBtoC:_AutoXREFHndl_AutoXREFCurr_AutoXREFMax_AutoXREFPtrruntime FBAutoSizeXRef( index as long, homeAddr as ptr, elementSize as long )runtime FBKillAutoXref( homeAddr as ptr )runtime FBCompressAutoXref( homeAddr as ptr )runtime usr DynamicItemSize( dyn as ptr )*//* See General.c forruntime WriteDynamic( fileRef as long, homeAddr as ptr, elementSize as long )runtime ReadDynamic( fileRef as long, homeAddr as ptr, elementSize as long )*/// replacement for _AutoXREFCurrlocal fn DynamicNextElement( array as UInt8 ) as UInt32 '~'1dim as UInt32 nextElement BeginCCodenextElement = gFBDynArrayInfo[array].lastElem + 1;(void)FBDynamicArray( array, nextElement ); // ensure next element is allocated ; #641  was FBGrowDynamicArraygFBDynArrayInfo[array].lastElem = nextElement - 1; // restoreEndCend fn = nextElement// Remove 'howMany' items from dynamic array, starting with item 'first'local fn DynamicRemoveItems( dynArrayNum as SInt32, first as SInt32, howMany as SInt32, savePtr as pointer )'~'1dim as SInt32 itemSize, itemCount, lastElemdim as pointer baseBeginCCode// info from *.c runtime globals itemSize  = gFBDynArrayInfo[dynArrayNum].elemSize; base      = gFBDynArrayInfo[dynArrayNum].base; itemCount = gFBDynArrayInfo[dynArrayNum].maxIndex; lastElem  = gFBDynArrayInfo[dynArrayNum].lastElem; // #642EndCif ( first < 0 or first > lastElem ) then exit fn // #642if ( first + howMany - 1 > lastElem ) then howMany = lastElem - first + 1 // #642long if ( howMany > 0 )BeginCCodegFBDynArrayInfo[dynArrayNum].lastElem -= howMany;EndCif ( savePtr ) then BlockMoveData( base + first*itemSize, savePtr, howMany*itemSize ) // copyBlockMoveData( base + (first + howMany)*itemSize, base + first*itemSize, (itemCount - first - howMany)*itemSize )BlockZero( base + (itemCount - howMany)*itemSize, howMany*itemSize ) // zero the tail elementsend ifend fn/*Insert howMany new elements into dynamic array, beginning at item where. If fillPtr is 0, zero-fill new items otherwise copy data from fillPtr into the new items.*/local fn DynamicInsertItems( dynArrayNum as SInt32, where as SInt32, howMany as SInt32, fillPtr as pointer )dim as SInt32   itemSize, itemCountdim as pointer  baseif ( where < 0 or howMany < 0 ) then exit fnBeginCCode// info from *.c runtime globalsitemSize  = gFBDynArrayInfo[dynArrayNum].elemSize;itemCount = gFBDynArrayInfo[dynArrayNum].maxIndex;EndCif ( itemCount < where ) then itemCount = whereBeginCCodeFBGrowDynamicArray( dynArrayNum, itemCount + howMany ); // make roomgFBDynArrayInfo[dynArrayNum].lastElem += howMany; // bump the last elem a/c to num insertedbase = gFBDynArrayInfo[dynArrayNum].base;EndCBlockMoveData( base + where*itemSize, base + (where + howMany)*itemSize, (itemCount - where)*itemSize )long if ( fillPtr == 0 ) // clear items inserted to zeroBlockZero( base + where*itemSize, howMany*itemSize )xelse // copy in new dataBlockMoveData( fillPtr, base + where*itemSize, howMany*itemSize )end ifend fn