/*Utilities for swapping floating point values.The four functions   SwapDoubleBigToHost()  SwapDoubleHostToBig()  SwapSingleBigToHost()  SwapSingleHostToBig()are the fp equivalents of CFSwapInt32BigToHost(), CFSwapInt32HostToBig(), and so on.They do nothing in PPC, but swap if run Intel native.This is not the Apple official way to deal with f.p. swapping,which requires reading f.p. quantities from disk into aCFSwappedFloat32 or CFSwappedFloat64, then obtaining the (possibly) swapped value via CFConvertFloatSwappedToHost() or CFConvertDoubleSwappedToHost().A cautious engineer at Apple determined that direct numeric swappingcould give wrong answers under some conditions. The reasoning is not publicly known,and many people use direct var-swapping withot trouble. My guess as to the worry is: (1) a big-endian value could correspond to a signalling NAN when read into a little-endian variable,(2) a trap-handler could be installed that converts signalling to quiet NANs,altering their bit pattern and hence their value.Worry (2) is not the case in FBtoC (or indeed in any ordinary floating point environment).  rp 20080328*/include "Tlbx CFByteOrder.incl"begin record FBDoubleSwapRecbegin uniondim as double ddim as UInt64 nend unionend recordbegin record FBSingleSwapRecbegin uniondim as single sdim as UInt32 nend unionend recordlocal fn SwapDoubleBigToHost( a as double ) as double'~'1dim as FBDoubleSwapRec uu.d = au.n = fn CFSwapInt64BigToHost( u.n )end fn = u.dlocal fn SwapDoubleHostToBig( a as double ) as double'~'1dim as FBDoubleSwapRec uu.d = au.n = fn CFSwapInt64HostToBig( u.n )end fn = u.dlocal fn SwapSingleBigToHost( a as single ) as single'~'1dim as FBSingleSwapRec uu.s = au.n = fn CFSwapInt32BigToHost( u.n )end fn = u.slocal fn SwapSingleHostToBig( a as single ) as single'~'1dim as FBSingleSwapRec uu.s = au.n = fn CFSwapInt32HostToBig( u.n )end fn = u.s