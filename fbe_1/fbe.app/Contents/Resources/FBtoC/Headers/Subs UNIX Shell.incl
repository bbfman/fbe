// last mod RP  hacked 11 June 2007 for FBtoC//include "Tlbx StdCLib.incl"include "Tlbx CFBundle.Incl"begin globalsdim as CFBundleRef  gSysBundleend globals_EOF  = -1 // end-of-file char from fgetc// Get Bundle ref for Frameworklocal fn CreateBundleForFramework( framework as str255 ) as CFBundleRef'~'1dim as CFBundleRef   bundledim as CFURLRef      baseURL, bundleURLdim as CFStringRef   frameworkCFStr, msgdim as OSStatus      statusdim as FSRef         frameworksFolderRefbundle = 0frameworkCFStr = fn CFStringCreateWithPascalString( 0, framework, _kCFStringEncodingASCII )status = fn FSFindFolder( _kOnAppropriateDisk,  _kFrameworksFolderType, _true, @frameworksFolderRef )long if ( status == _noErr )baseURL        = fn CFURLCreateFromFSRef( 0, @frameworksFolderRef )bundleURL      = fn CFURLCreateCopyAppendingPathComponent( 0, baseURL, frameworkCFStr, _false )if baseURL then CFRelease( baseURL )bundle = fn CFBundleCreate( 0, bundleURL )if bundleURL then CFRelease( bundleURL )end iflong if ( bundle == 0 )msg = fn CFStringCreateWithFormat( _kCFAllocatorDefault, NULL, @"Framework bundle \"%@\" not found",frameworkCFStr )//shutdown "Framework bundle """ + framework + """ not found"shutdown msgCFRelease( msg )end ifCFRelease( frameworkCFStr )end fn = bundle// function pointer from bundle and name of routinelocal fn GetMachFunctionFromBundle(bndl as ptr, name as str255 ) as pointer'~'1dim as CFStringRef  stringRef, msgdim as ptr          fptrfptr = 0stringRef = fn CFStringCreateWithPascalString( 0, name, _kCFStringEncodingASCII )long if stringReffptr = fn CFBundleGetFunctionPointerForName( bndl, stringRef )end iflong if fptrfptr = [fptr] // de-referencexelse//shutdown "BSD function """ + name + """ not found"msg = fn CFStringCreateWithFormat( _kCFAllocatorDefault, NULL, @"BSD function \"%@\" not found",stringRef )shutdown msgCFRelease(msg)end ifCFRelease( stringRef )end fn = fptrtoolbox fn popen( const char *command, const char *type ) = pointer toolbox fn pclose( pointer stream ) = long/*// glue for calling BSD routinesregister onlocal fn popen( @command as Ptr, @type as Ptr )// open a pipe, then fork & execv tool command in shellbeginassem lwz    r12,^gpopen mr     r31,r2 mtspr  ctr,r12 bctrl mr     r2,r31endassemend fn // pipe in r3local fn pclose( stream as Ptr )beginassem lwz    r12,^gpclose mr     r31,r2 mtspr  ctr,r12 bctrl mr     r2,r31endassemend fn // return code in r3local fn FBUnixOpen( command as Str255 )'~'1dim as Ptr    pipedim as long @ rdTypepipe = 0long if ( gFBSystemVersionHex >= 0x1000 ) // OS X only// load System.framework bundle, where most UNIX/BSD routines liveif ( gSysBundle == _nil ) then gSysBundle = fn CreateBundleForFramework( "System.framework" )// get pointers for our Mach-O functionslong if gSysBundle and ( gpopen == 0 )gpopen  = fn GetMachFunctionFromBundle(gSysBundle, "popen" )gpclose = fn GetMachFunctionFromBundle(gSysBundle, "pclose")end iffn FBPStr2CStr( command ) // PString -> CStringrdType[0] = _"r"rdType[1] = 0pipe = fn popen( command, rdType )end ifend fn = pipelocal fn FBUnixClose( pipe as Ptr )'~'1if pipe then fn pclose( pipe ) // close streamend fn*/