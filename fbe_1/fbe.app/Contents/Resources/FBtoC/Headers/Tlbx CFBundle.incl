/*   Translated to FB using         HeadToHead       by Bernie Wylde         ----------       12 October 2008*//* CFBundle.h Copyright (c) 1999-2007, Apple Inc. All rights reserved.*///include "CFBase.incl"include "Tlbx CFArray.incl"//include "CFDictionary.incl"include "Tlbx CFError.incl"//include "Tlbx CFString.incl"include "Tlbx CFURL.incl"#if ndef _DEFINEDINCARBON#define CFBundleRef as pointer#define CFPlugInRef as pointer/* ===================== Standard Info.plist keys ===================== */// const CFStringRef kCFBundleInfoDictionaryVersionKey;/* The version of the Info.plist format */// const CFStringRef kCFBundleExecutableKey;system CFStringRef kCFBundleExecutableKey/* The name of the executable in this bundle, if any */// const CFStringRef kCFBundleIdentifierKey;system CFStringRef kCFBundleIdentifierKey/* The bundle identifier (for CFBundleGetBundleWithIdentifier()) */// const CFStringRef kCFBundleVersionKey;system CFStringRef kCFBundleVersionKey/* The version number of the bundle. For Mac OS 9 style version numbers (for example "2.5.3d5"), *//* clients can use CFBundleGetVersionNumber() instead of accessing this key directly since that *//* function will properly convert the version string into its compact integer representation. */// const CFStringRef kCFBundleDevelopmentRegionKey;/* The name of the development language of the bundle. */// const CFStringRef kCFBundleNameKey;/* The human-readable name of the bundle. This key is often found in the InfoPlist.strings since it is usually localized. */// const CFStringRef kCFBundleLocalizationsKey AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* Allows an unbundled application that handles localization itself to specify which localizations it has available. *//* ===================== Finding Bundles ===================== */toolbox fn CFBundleGetMainBundle() = CFBundleReftoolbox fn CFBundleGetBundleWithIdentifier( CFStringRef bundleID ) = CFBundleRef/* A bundle can name itself by providing a key in the info dictionary. *//* This facility is meant to allow bundle-writers to get hold of their *//* bundle from their code without having to know where it was on the disk. *//* This is meant to be a replacement mechanism for +bundleForClass: users. *//* Note that this does not search for bundles on the disk; it will locate *//* only bundles already loaded or otherwise known to the current process. */toolbox fn CFBundleGetAllBundles() = CFArrayRef/* This is potentially expensive. Use with care. *//* ===================== Creating Bundles ===================== */toolbox fn CFBundleGetTypeID() = CFTypeIDtoolbox fn CFBundleCreate( CFAllocatorRef allocator, CFURLRef bundleURL ) = CFBundleRef/* Might return an existing instance with the ref-count bumped. */toolbox fn CFBundleCreateBundlesFromDirectory( CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType ) = CFArrayRef/* Create instances for all bundles in the given directory matching the given type *//* (or all of them if bundleType is NULL). Instances are created using CFBundleCreate() and are not released. *//* ==================== Basic Bundle Info ==================== */toolbox fn CFBundleCopyBundleURL( CFBundleRef bundle ) = CFURLReftoolbox fn CFBundleGetValueForInfoDictionaryKey( CFBundleRef bundle, CFStringRef key ) = CFTypeRef/* Returns a localized value if available, otherwise the global value. *//* This is the recommended function for examining the info dictionary. */toolbox fn CFBundleGetInfoDictionary( CFBundleRef bundle ) = CFDictionaryRef/* This is the global info dictionary. Note that CFBundle may add *//* extra keys to the dictionary for its own use. */toolbox fn CFBundleGetLocalInfoDictionary( CFBundleRef bundle ) = CFDictionaryRef/* This is the localized info dictionary. */toolbox CFBundleGetPackageInfo( CFBundleRef bundle, UInt32 *packageType, UInt32 *packageCreator )toolbox fn CFBundleGetIdentifier( CFBundleRef bundle ) = CFStringReftoolbox fn CFBundleGetVersionNumber( CFBundleRef bundle ) = UInt32toolbox fn CFBundleGetDevelopmentRegion( CFBundleRef bundle ) = CFStringReftoolbox fn CFBundleCopySupportFilesDirectoryURL( CFBundleRef bundle ) = CFURLReftoolbox fn CFBundleCopyResourcesDirectoryURL( CFBundleRef bundle ) = CFURLReftoolbox fn CFBundleCopyPrivateFrameworksURL( CFBundleRef bundle ) = CFURLReftoolbox fn CFBundleCopySharedFrameworksURL( CFBundleRef bundle ) = CFURLReftoolbox fn CFBundleCopySharedSupportURL( CFBundleRef bundle ) = CFURLReftoolbox fn CFBundleCopyBuiltInPlugInsURL( CFBundleRef bundle ) = CFURLRef/* ------------- Basic Bundle Info without a CFBundle instance ------------- *//* This API is provided to enable developers to retrieve basic information *//* about a bundle without having to create an instance of CFBundle. *//* Because of caching behavior when a CFBundle instance exists, it will be faster *//* to actually create a CFBundle if you need to retrieve multiple pieces of info. */toolbox fn CFBundleCopyInfoDictionaryInDirectory( CFURLRef bundleURL ) = CFDictionaryReftoolbox fn CFBundleGetPackageInfoInDirectory( CFURLRef url, UInt32 *packageType, UInt32 *packageCreator ) = Boolean/* ==================== Resource Handling API ==================== */toolbox fn CFBundleCopyResourceURL( CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName ) = CFURLReftoolbox fn CFBundleCopyResourceURLsOfType( CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName ) = CFArrayReftoolbox fn CFBundleCopyLocalizedString( CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName ) = CFStringRef// CFBundleCopyLocalizedString(CFBundleGetMainBundle(), (key), (key), NULL)// CFBundleCopyLocalizedString(CFBundleGetMainBundle(), (key), (key), (tbl))// CFBundleCopyLocalizedString((bundle), (key), (key), (tbl))// CFBundleCopyLocalizedString((bundle), (key), (value), (tbl))/* ------------- Resource Handling without a CFBundle instance ------------- *//* This API is provided to enable developers to use the CFBundle resource *//* searching policy without having to create an instance of CFBundle. *//* Because of caching behavior when a CFBundle instance exists, it will be faster *//* to actually create a CFBundle if you need to access several resources. */toolbox fn CFBundleCopyResourceURLInDirectory( CFURLRef bundleURL, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName ) = CFURLReftoolbox fn CFBundleCopyResourceURLsOfTypeInDirectory( CFURLRef bundleURL, CFStringRef resourceType, CFStringRef subDirName ) = CFArrayRef/* =========== Localization-specific Resource Handling API =========== *//* This API allows finer-grained control over specific localizations, *//* as distinguished from the above API, which always uses the user's *//* preferred localizations for the bundle in the current app context. */toolbox fn CFBundleCopyBundleLocalizations( CFBundleRef bundle ) = CFArrayRef/* Lists the localizations that a bundle contains. */toolbox fn CFBundleCopyPreferredLocalizationsFromArray( CFArrayRef locArray ) = CFArrayRef/* Given an array of possible localizations, returns the one or more *//* of them that CFBundle would use in the current application context. *//* To determine the localizations that would be used for a particular *//* bundle in the current application context, apply this function to the *//* result of CFBundleCopyBundleLocalizations(). */toolbox fn CFBundleCopyLocalizationsForPreferences( CFArrayRef locArray, CFArrayRef prefArray ) = CFArrayRef//  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* Given an array of possible localizations, returns the one or more of *//* them that CFBundle would use, without reference to the current application *//* context, if the user's preferred localizations were given by prefArray. *//* If prefArray is NULL, the current user's actual preferred localizations will *//* be used. This is not the same as CFBundleCopyPreferredLocalizationsFromArray(), *//* because that function takes the current application context into account. *//* To determine the localizations that another application would use, apply *//* this function to the result of CFBundleCopyBundleLocalizations(). */toolbox fn CFBundleCopyResourceURLForLocalization( CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName ) = CFURLReftoolbox fn CFBundleCopyResourceURLsOfTypeForLocalization( CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName ) = CFArrayRef/* The localizationName argument to CFBundleCopyResourceURLForLocalization() or *//* CFBundleCopyResourceURLsOfTypeForLocalization() must be identical to one of the *//* localizations in the bundle, as returned by CFBundleCopyBundleLocalizations(). *//* It is recommended that either CFBundleCopyPreferredLocalizationsFromArray() or *//* CFBundleCopyLocalizationsForPreferences() be used to select the localization. *//* =================== Unbundled application info ===================== *//* This API is provided to enable developers to retrieve bundle-related *//* information about an application that may be bundled or unbundled. */toolbox fn CFBundleCopyInfoDictionaryForURL( CFURLRef url ) = CFDictionaryRef//  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* For a directory URL, this is equivalent to CFBundleCopyInfoDictionaryInDirectory(). *//* For a plain file URL representing an unbundled executable, this will attempt to read *//* an info dictionary from the (__TEXT, __info_plist) section, if it is a Mach-o file, *//* or from a 'plst' resource. */toolbox fn CFBundleCopyLocalizationsForURL( CFURLRef url ) = CFArrayRef//  AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;/* For a directory URL, this is equivalent to calling CFBundleCopyBundleLocalizations() *//* on the corresponding bundle. For a plain file URL representing an unbundled executable, *//* this will attempt to determine its localizations using the CFBundleLocalizations and *//* CFBundleDevelopmentRegion keys in the dictionary returned by CFBundleCopyInfoDictionaryForURL,*//* or from a 'vers' resource if those are not present. */toolbox fn CFBundleCopyExecutableArchitecturesForURL( CFURLRef url ) = CFArrayRef//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* For a directory URL, this is equivalent to calling CFBundleCopyExecutableArchitectures() *//* on the corresponding bundle. For a plain file URL representing an unbundled executable, *//* this will return the architectures it provides, if it is a Mach-o file, or NULL otherwise. *//* ==================== Primitive Code Loading API ==================== *//* This API abstracts the various different executable formats supported on *//* various platforms. It can load DYLD, CFM, or DLL shared libraries (on their *//* appropriate platforms) and gives a uniform API for looking up functions. */toolbox fn CFBundleCopyExecutableURL( CFBundleRef bundle ) = CFURLRefbegin enum_kCFBundleExecutableArchitectureI386   = 0x00000007 _kCFBundleExecutableArchitecturePPC    = 0x00000012 _kCFBundleExecutableArchitectureX8664  = 0x01000007 _kCFBundleExecutableArchitecturePPC64  = 0x01000012end enumtoolbox fn CFBundleCopyExecutableArchitectures( CFBundleRef bundle ) = CFArrayRef//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* If the bundle's executable exists and is a Mach-o file, this function will return an array *//* of CFNumbers whose values are integers representing the architectures the file provides. *//* The values currently in use are those listed in the enum above, but others may be added *//* in the future. If the executable is not a Mach-o file, this function returns NULL. */toolbox fn CFBundlePreflightExecutable( CFBundleRef bundle, CFErrorRef *error ) = Boolean//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* This function will return true if the bundle is loaded, or if the bundle appears to be *//* loadable upon inspection. This does not mean that the bundle is definitively loadable, *//* since it may fail to load due to link errors or other problems not readily detectable. *//* If this function detects problems, it will return false, and return a CFError by reference. *//* It is the responsibility of the caller to release the CFError. */toolbox fn CFBundleLoadExecutableAndReturnError( CFBundleRef bundle, CFErrorRef *error ) = Boolean//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* If the bundle is already loaded, this function will return true. Otherwise, it will attempt *//* to load the bundle, and it will return true if that attempt succeeds. If the bundle fails *//* to load, this function will return false, and it will return a CFError by reference. *//* It is the responsibility of the caller to release the CFError. */toolbox fn CFBundleLoadExecutable( CFBundleRef bundle ) = Booleantoolbox fn CFBundleIsExecutableLoaded( CFBundleRef bundle ) = Booleantoolbox CFBundleUnloadExecutable( CFBundleRef bundle )toolbox fn CFBundleGetFunctionPointerForName( CFBundleRef bundle, CFStringRef functionName ) = pointertoolbox CFBundleGetFunctionPointersForNames( CFBundleRef bundle, CFArrayRef functionNames, pointer ftbl )toolbox fn CFBundleGetDataPointerForName( CFBundleRef bundle, CFStringRef symbolName ) = pointertoolbox CFBundleGetDataPointersForNames( CFBundleRef bundle, CFArrayRef symbolNames, pointer stbl )toolbox fn CFBundleCopyAuxiliaryExecutableURL( CFBundleRef bundle, CFStringRef executableName ) = CFURLRef/* This function can be used to find executables other than your main *//* executable. This is useful, for instance, for applications that have *//* some command line tool that is packaged with and used by the application. *//* The tool can be packaged in the various platform executable directories *//* in the bundle and can be located with this function. This allows an *//* app to ship versions of the tool for each platform as it does for the *//* main app executable. *//* ==================== Getting a bundle's plugIn ==================== */toolbox fn CFBundleGetPlugIn( CFBundleRef bundle ) = CFPlugInRef/* ==================== Resource Manager-Related API ==================== */#define CFBundleRefNum as SInt16toolbox fn CFBundleOpenBundleResourceMap( CFBundleRef bundle ) = CFBundleRefNum/* This function opens the non-localized and the localized resource files *//* (if any) for the bundle, creates and makes current a single read-only *//* resource map combining both, and returns a reference number for it. *//* If it is called multiple times, it opens the files multiple times, *//* and returns distinct reference numbers. */toolbox fn CFBundleOpenBundleResourceFiles( CFBundleRef bundle, CFBundleRefNum *refNum, CFBundleRefNum *localizedRefNum ) = SInt32/* Similar to CFBundleOpenBundleResourceMap(), except that it creates two *//* separate resource maps and returns reference numbers for both. */toolbox CFBundleCloseBundleResourceMap( CFBundleRef bundle, CFBundleRefNum refNum )#endif// ndef _DEFINEDINCARBON