/*   Translated to FB using         HeadToHead       by Bernie Wylde         ----------       12 October 2008*//* CFString.h Copyright (c) 1998-2007, Apple Inc. All rights reserved.*/include "Tlbx CFArray.incl"include "Tlbx CFData.incl"include "Tlbx CFDictionary.incl"include "Tlbx CFCharacterSet.incl"include "Tlbx CFLocale.incl"#if ndef _DEFINEDINCARBON/*Please note: CFStrings are conceptually an array of Unicode characters.However, in general, how a CFString stores this array is an implementationdetail. For instance, CFString might choose to use an array of 8-bit characters;to store its contents; or it might use multiple blocks of memory; or whatever.Furthermore, the implementation might change depending on the defaultsystem encoding, the user's language, the OS, or even a given release.What this means is that you should use the following advanced functions with care: CFStringGetPascalStringPtr() CFStringGetCStringPtr() CFStringGetCharactersPtr()These functions are provided for optimization only. They will either return the desiredpointer quickly, in constant time, or they return NULL. They might choose to return NULLfor many reasons; for instance it's possible that for users running in differentlanguages these sometimes return NULL; or in a future OS release the first two mightswitch to always returning NULL. Never observing NULL returns in your usages of thesefunctions does not mean they won't ever return NULL. (But note the CFStringGetCharactersPtr()exception mentioned further below.)In your usages of these functions, if you get a NULL return, use the non-Ptr versionof the functions as shown in this example: Str255 buffer; StringPtr ptr = CFStringGetPascalStringPtr(str, encoding); if (ptr == NULL) { if (CFStringGetPascalString(str, buffer, 256, encoding)) ptr = buffer; }Note that CFStringGetPascalString() or CFStringGetCString() calls might still fail --- butthat will happen in two circumstances only: The conversion from the UniChar contents of CFStringto the specified encoding fails, or the buffer is too small. If they fail, that meansthe conversion was not possible.If you need a copy of the buffer in the above example, you might consider simplycalling CFStringGetPascalString() in all cases --- CFStringGetPascalStringPtr()is simply an optimization.In addition, the following functions, which create immutable CFStrings from developersupplied buffers without copying the buffers, might have to actually copyunder certain circumstances (If they do copy, the buffer will be dealt with by the"contentsDeallocator" argument.): CFStringCreateWithPascalStringNoCopy() CFStringCreateWithCStringNoCopy() CFStringCreateWithCharactersNoCopy()You should of course never depend on the backing store of these CFStrings beingwhat you provided, and in other no circumstance should you change the contentsof that buffer (given that would break the invariant about the CFString being immutable).Having said all this, there are actually ways to create a CFString where the backing storeis external, and can be manipulated by the developer or CFString itself: CFStringCreateMutableWithExternalCharactersNoCopy() CFStringSetExternalCharactersNoCopy()A "contentsAllocator" is used to realloc or free the backing store by CFString.kCFAllocatorNull can be provided to assure CFString will never realloc or free the buffer.Developer can call CFStringSetExternalCharactersNoCopy() to updateCFString's idea of what's going on, if the buffer is changed externally. In thesestrings, CFStringGetCharactersPtr() is guaranteed to return the external buffer.These functions are here to allow wrapping a buffer of UniChar characters in a CFString,allowing the buffer to passed into CFString functions and also manipulated via CFStringmutation functions. In general, developers should not use this technique for all strings,as it prevents CFString from using certain optimizations.*//* Identifier for character encoding; the values are the same as Text Encoding Converter TextEncoding.*/#define CFStringEncoding as UInt32/* Platform-independent built-in encodings; always available on all platforms. Call CFStringGetSystemEncoding() to get the default system encoding.*/begin enum not output_kCFStringEncodingMacRoman      = 0 _kCFStringEncodingWindowsLatin1 = 0x0500  /* ANSI codepage 1252 */_kCFStringEncodingISOLatin1     = 0x0201  /* ISO 8859-1 */_kCFStringEncodingNextStepLatin = 0x0B01  /* NextStep encoding*/_kCFStringEncodingASCII         = 0x0600  /* 0..127 (in creating CFString  values greater than 0x7F are treated as corresponding Unicode value) */_kCFStringEncodingUnicode       = 0x0100  /* kTextEncodingUnicodeDefault + kTextEncodingDefaultFormat (aka kUnicode16BitFormat) */_kCFStringEncodingUTF8          = 0x08000100  /* kTextEncodingUnicodeDefault + kUnicodeUTF8Format */_kCFStringEncodingNonLossyASCII = 0x0BFF /* 7bit Unicode variants used by Cocoa & Java */_kCFStringEncodingUTF16         = 0x0100  /* kTextEncodingUnicodeDefault + kUnicodeUTF16Format (alias of kCFStringEncodingUnicode) */_kCFStringEncodingUTF16BE       = 0x10000100  /* kTextEncodingUnicodeDefault + kUnicodeUTF16BEFormat */_kCFStringEncodingUTF16LE       = 0x14000100  /* kTextEncodingUnicodeDefault + kUnicodeUTF16LEFormat */                                _kCFStringEncodingUTF32         = 0x0c000100  /* kTextEncodingUnicodeDefault + kUnicodeUTF32Format */_kCFStringEncodingUTF32BE       = 0x18000100  /* kTextEncodingUnicodeDefault + kUnicodeUTF32BEFormat */_kCFStringEncodingUTF32LE       = 0x1c000100 /* kTextEncodingUnicodeDefault + kUnicodeUTF32LEFormat */end enum#define CFStringBuiltInEncodings as CFStringEncoding/* CFString type ID */toolbox fn CFStringGetTypeID() = CFTypeIDtoolbox fn CFStringCreateWithPascalString( CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding ) = CFStringRef#endif// ndef _DEFINEDINCARBON/* Macro to allow creation of compile-time constant strings; the argument should be a constant string.CFSTR(), not being a "Copy" or "Create" function, does not return a newreference for you. So, you should not release the return value. This ismuch like constant C or Pascal strings --- when you use "hello world"in a program, you do not free it.However, strings returned from CFSTR() can be retained and released in aproperly nested fashion, just like any other CF type. That is, if you passa CFSTR() return value to a function such as SetMenuItemWithCFString(), thefunction can retain it, then later, when it's done with it, it can release it.At this point non-7 bit characters (that is, characters > 127) in CFSTR() are not supported and using them will lead to unpredictable results. This includes escaped(\nnn) characters whose values are > 127. Even if it works for you in testing, it might not work for a user with a different language preference.*/// CFSTR macro emulationbegin record CFSTRRecdim as CFStringRef  cfStrdim as Str255       send record// RP   25 April 2005    revised to avoid string-copies during search, whose memory access pattern is now more cache-friendlylocal fn CFStr( s as Str255 ) as CFStringRef // note for FBtoC: CFStr, not CFSTR   {30/1/07} RP'~'1begin globalsdim as Handle  sCFSTRh // 'static' var/*Meaning:  n     [string_len    characters      CFStringRef]...Size:     4      1             variable        4*/end globalsdim as UInt32       jdim as CFSTRRec     tempCFSTRRecdim as pointer      p, pp, ssdim as long         lenEntry, idim as CFStringRef  cfStrgif ( sCFSTRh == 0 ) then sCFSTRh = fn NewHandleClear( 4 ) // initialise storage on first call; 4 is room for CFSTR count// search for existing entryp = [sCFSTRh] // de-referencej = p.nil& // CFSTR countp += 8 // p -> first stringwhile ( j )pp = pss = @slenEntry = p.nil``  // length of stored stringi = lenEntrydo // test if s.nil$ == p.nil$if ( pp.nil`` != ss.nil`` ) then goto "CFSTR"pp++ss++i--until ( i < 0 )// found the stringp -= 4 // back off to cfStr locationcfStrg = p.nil& // get return valueexit fn // exit with retrieved CFStringRef// try again"CFSTR"p = lenEntry + 5 + p // 5 == 1 + sizeof( CFStringRef ); now p -> next stringj--wend// no match: add new stringcfStrg = fn CFStringCreateWithPascalString( 0, #s, _kCFStringEncodingMacRoman )long if ( cfStrg )tempCFSTRRec.cfStr = cfStrg// assemble…tempCFSTRRec.s     = s //…the new table entry// append CFSTRRec (truncated to the actual size of s) to the handleif fn PtrAndHand( @tempCFSTRRec, sCFSTRh, s[0] + 5 ) then shutdown @"Out of memory in CFSTR"p = [sCFSTRh]p.nil& = p.nil& + 1// bump CFSTR countxelseshutdown @"CFStringCreateWithPascalString failed in CFSTR"end ifend fn = cfStrg#if ndef _DEFINEDINCARBON/*** Immutable string creation functions ***//* Functions to create basic immutable strings. The provided allocator is used for all memory activity in these functions.*/toolbox fn CFStringCreateWithCString( CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding ) = CFStringRef/* The following takes an explicit length, and allows you to specify whether the data is an external format --- that is, whether to pay attention to the BOM character (if any) and do byte swapping if necessary*/toolbox fn CFStringCreateWithBytes( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation ) = CFStringReftoolbox fn CFStringCreateWithCharacters( CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars ) = CFStringRef/* These functions try not to copy the provided buffer. The buffer will be deallocated with the provided contentsDeallocator when it's no longer needed; to not freethe buffer, specify kCFAllocatorNull here. As usual, NULL means default allocator.NOTE: Do not count on these buffers as being used by the string; in some cases the CFString might free the buffer and use something else(for instance if it decides to always use Unicode encoding internally). NOTE: If you are not transferring ownership of the buffer to the CFString(for instance, you supplied contentsDeallocator = kCFAllocatorNull), it is yourresponsibility to assure the buffer does not go away during the lifetime of the string.If the string is retained or copied, its lifetime might extend in ways you cannotpredict. So, for strings created with buffers whose lifetimes you cannotguarantee, you need to be extremely careful --- do not hand it out to anyAPIs which might retain or copy the strings.*/toolbox fn CFStringCreateWithPascalStringNoCopy( CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator ) = CFStringReftoolbox fn CFStringCreateWithCStringNoCopy( CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator ) = CFStringRef/* The following takes an explicit length, and allows you to specify whether the data is an external format --- that is, whether to pay attention to the BOM character (if any) and do byte swapping if necessary*/toolbox fn CFStringCreateWithBytesNoCopy( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator ) = CFStringRef//  AVAILABLE_MAC_OS_X_VERSION_10_4_toolbox fn CFStringCreateWithCharactersNoCopy( CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator ) = CFStringRef/* Create copies of part or all of the string.*/toolbox fn CFStringCreateWithSubstring( CFAllocatorRef alloc, CFStringRef str, CFRange range ) = CFStringReftoolbox fn CFStringCreateCopy( CFAllocatorRef alloc, CFStringRef theString ) = CFStringRef/* These functions create a CFString from the provided printf-like format string and arguments.*/toolbox fn CFStringCreateWithFormat( CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ... ) = CFStringRef//toolbox fn CFStringCreateWithFormatAndArguments( CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, valist arguments ) = CFStringReftoolbox fn CFStringCreateWithFormatAndArguments( CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, pointer arguments ) = CFStringRef/* Functions to create mutable strings. "maxLength", if not 0, is a hard bound on the length of the string. If 0, there is no limit on the length.*/toolbox fn CFStringCreateMutable( CFAllocatorRef alloc, CFIndex maxLength ) = CFMutableStringReftoolbox fn CFStringCreateMutableCopy( CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString ) = CFMutableStringRef/* This function creates a mutable string that has a developer supplied and directly editable backing store.The string will be manipulated within the provided buffer (if any) until it outgrows capacity; then theexternalCharactersAllocator will be consulted for more memory. When the CFString is deallocated, thebuffer will be freed with the externalCharactersAllocator. Provide kCFAllocatorNull here to prevent the bufferfrom ever being reallocated or deallocated by CFString. See comments at top of this file for more info.*/toolbox fn CFStringCreateMutableWithExternalCharactersNoCopy( CFAllocatorRef alloc, UniChar *chars, CFIndex numChars, CFIndex capacity, CFAllocatorRef externalCharactersAllocator ) = CFMutableStringRef/*** Basic accessors for the contents ***//* Number of 16-bit Unicode characters in the string.*/toolbox fn CFStringGetLength( CFStringRef theString ) = CFIndex/* Extracting the contents of the string. For obtaining multiple characters, callingCFStringGetCharacters() is more efficient than multiple calls to CFStringGetCharacterAtIndex().If the length of the string is not known (so you can't use a fixed size buffer for CFStringGetCharacters()),another method is to use is CFStringGetCharacterFromInlineBuffer() (see further below).*/toolbox fn CFStringGetCharacterAtIndex( CFStringRef theString, CFIndex idx ) = UniChar//toolbox CFStringGetCharacters( CFStringRef theString, CFRange range, UniChar *buffer )toolbox CFStringGetCharacters( CFStringRef theString, CFRange range,  pointer buffer )/*** Conversion to other encodings ***//* These two convert into the provided buffer; they return false if conversion isn't possible(due to conversion error, or not enough space in the provided buffer). These functions do zero-terminate or put the length byte; the provided bufferSize should includespace for this (so pass 256 for Str255). More sophisticated usages can go through CFStringGetBytes().These functions are equivalent to calling CFStringGetBytes() with the range of the string; lossByte = 0; and isExternalRepresentation = false; if successful, they then insert the leading length or terminating zero, as desired.*/toolbox fn CFStringGetPascalString( CFStringRef theString, pointer buffer, CFIndex bufferSize, CFStringEncoding encoding ) = Booleantoolbox fn CFStringGetCString( CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding ) = Boolean/* These functions attempt to return in O(1) time the desired format for the string.Note that although this means a pointer to the internal structure is being returned,this can't always be counted on. Please see note at the top of the file for moredetails.*/toolbox fn CFStringGetPascalStringPtr( CFStringRef theString, CFStringEncoding encoding ) = pointer// ; /* May return NULL at any time; be prepared for NULL */toolbox fn CFStringGetCStringPtr( CFStringRef theString, CFStringEncoding encoding ) = pointer/* May return NULL at any time; be prepared for NULL */toolbox fn CFStringGetCharactersPtr(CFStringRef theString) = pointer/* May return NULL at any time; be prepared for NULL *//* The primitive conversion routine; allows you to convert a string piece at a time into a fixed size buffer. Returns number of characters converted.  Characters that cannot be converted to the specified encoding are represented with the byte specified by lossByte; if lossByte is 0, then lossy conversion is not allowed and conversion stops, returning partial results. Pass buffer==NULL if you don't care about the converted string (but just the convertability, or number of bytes required).  maxBufLength indicates the maximum number of bytes to generate. It is ignored when buffer==NULL. Does not zero-terminate. If you want to create Pascal or C string, allow one extra byte at start or end.  Setting isExternalRepresentation causes any extra bytes that would allow  the data to be made persistent to be included; for instance, the Unicode BOM.*/toolbox fn CFStringGetBytes( CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen ) = CFIndex/* Convenience functions String <-> Data. These generate "external" formats, that is, formats that can be written out to disk. For instance, if the encoding is Unicode, CFStringCreateFromExternalRepresentation() pays attention to the BOM character (if any) and does byte swapping if necessary. Similarly CFStringCreateExternalRepresentation() will always include a BOM character if the encoding is Unicode. See above for description of lossByte.*/toolbox fn CFStringCreateFromExternalRepresentation( CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding ) = CFStringRef// ; /* May return NULL on conversion error */toolbox fn CFStringCreateExternalRepresentation( CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte ) = CFDataRef// ; /* May return NULL on conversion error */ /* Hints about the contents of a string*/toolbox fn CFStringGetSmallestEncoding( CFStringRef theString ) = CFStringEncoding// ; /* Result in O(n) time max */toolbox fn CFStringGetFastestEncoding( CFStringRef theString ) = CFStringEncoding// ; /* Result in O(1) time max *//* General encoding info*/toolbox fn CFStringGetSystemEncoding() = CFStringEncoding// ; /* The default encoding for the system; untagged 8-bit characters are usually in this encoding */toolbox fn CFStringGetMaximumSizeForEncoding( CFIndex length, CFStringEncoding encoding ) = CFIndex// ; /* Max bytes a string of specified length (in UniChars) will take up if encoded *//*** FileSystem path conversion functions ***//* Extract the contents of the string as a NULL-terminated 8-bit string appropriate for passing to POSIX APIs (for example, normalized for HFS+). The string is zero-terminated. false will be returned if the conversion results don't fit into the buffr. Us*/toolbox fn CFStringGetFileSystemRepresentation( CFStringRef string, char *buffer, CFIndex maxBufLen ) = Boolean//  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Get the upper bound on the number of bytes required to hold the file system representation for the string. This result is returned quickly as a very rough approximation, and could be much larger than the actual space required. The result includesspace*/toolbox fn CFStringGetMaximumSizeOfFileSystemRepresentation( CFStringRef string ) = CFIndex//  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Create a CFString from the specified zero-terminated POSIX file system representation. If the conversion fails (possible due to bytes in the buffer not being a valid sequence of bytes for the appropriate character encoding), NULL is returned.*/toolbox fn CFStringCreateWithFileSystemRepresentation( CFAllocatorRef alloc, const char *buffer ) = CFStringRef//  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/*** Comparison functions. ***//* Find and compare flags; these are OR'ed together as compareOptions or searchOptions in the various functions.  This typedef doesn't appear in the functions; instead the argument is CFOptionFlags. */begin enum not output_kCFCompareCaseInsensitive      = 1  _kCFCompareBackwards            = 4  /* Starting from the end of the string */_kCFCompareAnchored             = 8  /* Only at the specified starting point */_kCFCompareNonliteral           = 16  /* If specified  loose equivalence is performed (o-umlaut == o  umlaut) */_kCFCompareLocalized            = 32  /* User_"s default locale is used for the comparisons */_kCFCompareNumerically          = 64 /* Numeric comparison is used; that is  Foo2.txt < Foo7.txt < Foo25.txt *///#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5_kCFCompareDiacriticInsensitive = 128  /* If specified  ignores diacritics (o-umlaut == o) */_kCFCompareWidthInsensitive     = 256  /* If specified  ignores width differences (_"a" == UFF41) */_kCFCompareForcedOrdering       = 512 /* If specified  comparisons are forced to return either kCFCompareLessThan or kCFCompareGreaterThan if the strings are equivalent but not strictly equal  for stability when sorting (e.g. _"aaa" > "AAA"*///#endif MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5   {MN20100310}end enum#define CFStringCompareFlags as CFOptionFlags/* The main comparison routine; compares specified range of the first string to (the full range of) the second string.locale == NULL indicates canonical locale (the return value from CFLocaleGetSystem()).kCFCompareNumerically, added in 10.2, does not work if kCFCompareLocalized is specified on systems before 10.3kCFCompareBackwards and kCFCompareAnchored are not applicable.*/toolbox fn CFStringCompareWithOptionsAndLocale( CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFOptionFlags compareOptions, CFLocaleRef locale ) = CFComparisonResult//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Comparison convenience. Uses the current user locale (the return value from CFLocaleCopyCurrent()) if kCFCompareLocalized.*/toolbox fn CFStringCompareWithOptions( CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFOptionFlags compareOptions ) = CFComparisonResult/* Comparison convenience suitable for passing as sorting functions. kCFCompareNumerically, added in 10.2, does not work if kCFCompareLocalized is specified on systems before 10.3 kCFCompareBackwards and kCFCompareAnchored are not applicable.*/toolbox fn CFStringCompare( CFStringRef theString1, CFStringRef theString2, CFOptionFlags compareOptions ) = CFComparisonResult/* CFStringFindWithOptionsAndLocale() returns the found range in the CFRange * argument; you can pass NULL for simple discovery check. locale == NULL indicates canonical locale (the return value from CFLocaleGetSystem()). If stringToFind is the empty string (zero length), nothing is found. Ignores the kCFCompareNumerically option.*/toolbox fn CFStringFindWithOptionsAndLocale( CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFOptionFlags searchOptions, CFLocaleRef locale, CFRange *result ) = Boolean//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Find convenience. Uses the current user locale (the return value from CFLocaleCopyCurrent()) if kCFCompareLocalized.*/toolbox fn CFStringFindWithOptions( CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFOptionFlags searchOptions, CFRange *result ) = Boolean/* CFStringCreateArrayWithFindResults() returns an array of CFRange pointers, or NULL if there are no matches. Overlapping instances are not found; so looking for "AA" in "AAA" finds just one range. Post 10.1: If kCFCompareBackwards is provided, the scan is done from the end (which can give a different result), and the results are stored in the array backwards (last found range in slot 0). If stringToFind is the empty string (zero length), nothing is found. kCFCompareAnchored causes just the consecutive instances at start (or end, if kCFCompareBackwards) to be reported. So, searching for "AB" in "ABABXAB..." you just get the first two occurrences. Ignores the kCFCompareNumerically option.*/toolbox fn CFStringCreateArrayWithFindResults( CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFOptionFlags compareOptions ) = CFArrayRef/* Find conveniences; see comments above concerning empty string and options.*/toolbox fn CFStringFind( CFStringRef theString, CFStringRef stringToFind, CFOptionFlags compareOptions ) = CFRangetoolbox fn CFStringHasPrefix( CFStringRef theString, CFStringRef prefix ) = Booleantoolbox fn CFStringHasSuffix( CFStringRef theString, CFStringRef suffix ) = Boolean/*! @function CFStringGetRangeOfComposedCharactersAtIndex Returns the range of the composed character sequence at the specified index. @param theString The CFString which is to be searched. If this parameter is not a valid CFString, the behavior is undefined. @param theIndex The index of the character contained in the composed character sequence. If the index is outside the index space of the string (0 to N-1 inclusive, where N is the length of the string), the behavior is undefined. @result The range of the composed character sequence.*/toolbox fn CFStringGetRangeOfComposedCharactersAtIndex( CFStringRef theString, CFIndex theIndex ) = CFRange/*! @function CFStringFindCharacterFromSet Query the range of the first character contained in the specified character set. @param theString The CFString which is to be searched. If this parameter is not a valid CFString, the behavior is undefined. @param theSet The CFCharacterSet against which the membership of characters is checked. If this parameter is not a valid CFCharacterSet, the behavior is undefined. @param range The range of characters within the string to search. If the range location or end point (defined by the location plus length minus 1) are outside the index space of the string (0 to N-1 inclusive, where N is the length of the string), the behavior is undefined. If the range length is negative, the behavior is undefined. The range may be empty (length 0), in which case no search is performed. @param searchOptions The bitwise-or'ed option flags to control the search behavior. The supported options are kCFCompareBackwards andkCFCompareAnchored. If other option flags are specified, the behavior is undefined. @param result The pointer to a CFRange supplied by the caller in which the search result is stored. Note that the length of this range can be more than 1, if for instance the  result is a composed character. If a pointer to an invalid memory is specified, the behavior is undefined. @result true, if at least a character which is a member of the character set is found and result is filled, otherwise, false.*/toolbox fn CFStringFindCharacterFromSet( CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFOptionFlags searchOptions, CFRange *result ) = Boolean/* Find range of bounds of the line(s) that span the indicated range (startIndex, numChars), taking into account various possible line separator sequences (CR, CRLF, LF, and Unicode NextLine, LineSeparator, ParagraphSeparator). All return values are "optional" (provide NULL if you don't want them) lineBeginIndex: index of first character in line lineEndIndex: index of first character of the next line (including terminating line separator characters) contentsEndIndex: index of the first line separator character Thus, lineEndIndex - lineBeginIndex is the number of chars in the line, including the line separators contentsEndIndex - lineBeginIndex is the number of chars in the line w/out the line separators*/toolbox CFStringGetLineBounds( CFStringRef theString, CFRange range, CFIndex *lineBeginIndex, CFIndex *lineEndIndex, CFIndex *contentsEndIndex )/* Same as CFStringGetLineBounds(), however, will only look for paragraphs. Won't stop at Unicode NextLine or LineSeparator characters.*/toolbox CFStringGetParagraphBounds( CFStringRef string, CFRange range, CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex )//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/*** Exploding and joining strings with a separator string ***/toolbox fn CFStringCreateByCombiningStrings( CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString ) = CFStringRef// ; /* Empty array returns empty string; one element array returns the element */toolbox fn CFStringCreateArrayBySeparatingStrings( CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString ) = CFArrayRef// ; /* No separators in the string returns array with that string; string == sep returns two empty strings *//*** Parsing non-localized numbers from strings ***/toolbox fn CFStringGetIntValue( CFStringRef str ) = SInt32// ; /* Skips whitespace; returns 0 on error, MAX or -MAX on overflow */toolbox fn CFStringGetDoubleValue( CFStringRef str ) = double// ; /* Skips whitespace; returns 0.0 on error *//*** MutableString functions ***//* CFStringAppend("abcdef", "xxxxx") -> "abcdefxxxxx" CFStringDelete("abcdef", CFRangeMake(2, 3)) -> "abf" CFStringReplace("abcdef", CFRangeMake(2, 3), "xxxxx") -> "abxxxxxf" CFStringReplaceAll("abcdef", "xxxxx") -> "xxxxx"*/toolbox CFStringAppend( CFMutableStringRef theString, CFStringRef appendedString )toolbox CFStringAppendCharacters( CFMutableStringRef theString, const UniChar *chars, CFIndex numChars )toolbox CFStringAppendPascalString( CFMutableStringRef theString, ConstStr255Param pStr, CFStringEncoding encoding )toolbox CFStringAppendCString( CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding )toolbox CFStringAppendFormat( CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ... )//toolbox CFStringAppendFormatAndArguments( CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, valist arguments )toolbox CFStringInsert( CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr )toolbox CFStringDelete( CFMutableStringRef theString, CFRange range )toolbox CFStringReplace( CFMutableStringRef theString, CFRange range, CFStringRef replacement )toolbox CFStringReplaceAll( CFMutableStringRef theString, CFStringRef replacement )// ; /* Replaces whole string *//* Replace all occurrences of target in rangeToSearch of theString with replacement. Pays attention to kCFCompareCaseInsensitive, kCFCompareBackwards, kCFCompareNonliteral, and kCFCompareAnchored. kCFCompareBackwards can be used to do the replacement starting from the end, which could give a different result. ex. AAAAA, replace AA with B -> BBA or ABB; latter if kCFCompareBackwards kCFCompareAnchored assures only anchored but multiple instances are found (the instances must be consecutive at start or end) ex. AAXAA, replace A with B -> BBXBB or BBXAA; latter if kCFCompareAnchored Returns number of replacements performed.*/toolbox fn CFStringFindAndReplace( CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFOptionFlags compareOptions ) = CFIndex/* This function will make the contents of a mutable CFString point directly at the specified UniChar array. It works only with CFStrings created with CFStringCreateMutableWithExternalCharactersNoCopy(). This function does not free the previous buffer. The string will be manipulated within the provided buffer (if any) until it outgrows capacity; then the externalCharactersAllocator will be consulted for more memory. See comments at the top of this file for more info.*/toolbox CFStringSetExternalCharactersNoCopy( CFMutableStringRef theString, UniChar *chars, CFIndex length, CFIndex capacity )// ; /* Works only on specially created mutable strings! *//* CFStringPad() will pad or cut down a string to the specified size. The pad string is used as the fill string; indexIntoPad specifies which character to start with. CFStringPad("abc", " ", 9, 0) -> "abc " CFStringPad("abc", ". ", 9, 1) -> "abc . . ." CFStringPad("abcdef", ?, 3, ?) -> "abc" CFStringTrim() will trim the specified string from both ends of the string. CFStringTrimWhitespace() will do the same with white space characters (tab, newline, etc) CFStringTrim(" abc ", " ") -> "abc" CFStringTrim("* * * *abc * ", "* ") -> "*abc "*/toolbox CFStringPad( CFMutableStringRef theString, CFStringRef padString, CFIndex length, CFIndex indexIntoPad )toolbox CFStringTrim( CFMutableStringRef theString, CFStringRef trimString )toolbox CFStringTrimWhitespace( CFMutableStringRef theString )toolbox CFStringLowercase( CFMutableStringRef theString, CFLocaleRef locale )toolbox CFStringUppercase( CFMutableStringRef theString, CFLocaleRef locale )toolbox CFStringCapitalize( CFMutableStringRef theString, CFLocaleRef locale )/*! @typedef CFStringNormalizationForm This is the type of Unicode normalization forms as described in Unicode Technical Report #15. To normalize for use with file system calls, use CFStringGetFileSystemRepresentation().*/begin enum_kCFStringNormalizationFormD   = 0  // Canonical Decomposition_kCFStringNormalizationFormKD  _kCFStringNormalizationFormKD  // Compatibility Decomposition_kCFStringNormalizationFormC   _kCFStringNormalizationFormC  // Canonical Decomposition followed by Canonical Composition_kCFStringNormalizationFormKC  _kCFStringNormalizationFormKC // Compatibility Decomposition followed by Canonical Compositionend enum#define CFStringNormalizationForm as CFIndex/*! @function CFStringNormalize Normalizes the string into the specified form as described in Unicode Technical Report #15. @param theString The string which is to be normalized. If this parameter is not a valid mutable CFString, the behavior is undefined. @param theForm The form into which the string is to be normalized. If this parameter is not a valid CFStringNormalizationForm value, the behavior is undefined.*/toolbox CFStringNormalize( CFMutableStringRef theString, CFStringNormalizationForm theForm )/*! @function CFStringFold Folds the string into the form specified by the flags. Character foldings are operations that convert any of a set of characters sharing similar semantics into a single representative from that set. This function can be used to preprocess strings that are to be compared, searched, or indexed. Note that folding does not include normalization, so it is necessary to use CFStringNormalize in addition to CFStringFold in order to obtain the effect of kCFCompareNonliteral. @param theString The string which is to be folded. If this parameter is not a valid mutable CFString, the behavior is undefined. @param theFlag The equivalency flags which describes the character folding form. Only those flags containing the word "insensitive" are recognized here; other flags are ignored.  Folding with kCFCompareCaseInsensitive removes case distinctions in accordance with the mapping specified by ftp://ftp.unicode.org/Public/UNIDATA/CaseFolding.txt. Folding with kCFCompareDiacriticInsensitive removes distinctions of accents and other diacritics. Folding with kCFCompareWidthInsensitive removes character width distinctions by mapping characters in the range U+FF00-U+FFEF to their ordinary equivalents. @param theLocale The locale tailoring the character folding behavior. If NULL, it's considered to be the system locale returned from CFLocaleGetSystem(). If non-NULL and not a valid CFLocale object, the behavior is undefined.*/toolbox CFStringFold( CFMutableStringRef theString, CFOptionFlags theFlags, CFLocaleRef theLocale )//  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/* Perform string transliteration. The transformation represented by transform is applied to the given range of string, modifying it in place. Only the specified range will be modified, but the transform may look at portions of the string outside tht ranYou can pass one of the predefined transforms below, or any valid ICU transform ID as defined in the ICU User Guide. Note that we do not support arbitrary set of ICU transform rules.*/// Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;/* Transform identifiers for CFStringTransform()*/// CF_EXPORT const CFStringRef kCFStringTransformToLatin AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformLatinKatakana AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformHiraganaKatakana AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformLatinHangul AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformLatinHebrew AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformLatinCyrillic AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformToXMLHex AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;// CF_EXPORT const CFStringRef kCFStringTransformStripDiacritics AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;/*** General encoding related functionality ***//* This returns availability of the encoding on the system*/toolbox fn CFStringIsEncodingAvailable( CFStringEncoding encoding ) = Boolean/* This function returns list of available encodings. The returned list is terminated with kCFStringEncodingInvalidId and owned by the system.*/toolbox fn CFStringGetListOfAvailableEncodings = pointer/* Returns name of the encoding; non-localized.*/toolbox fn CFStringGetNameOfEncoding( CFStringEncoding encoding ) = CFStringRef/* ID mapping functions from/to Cocoa NSStringEncoding. Returns kCFStringEncodingInvalidId if no mapping exists.*/toolbox fn CFStringConvertEncodingToNSStringEncoding( CFStringEncoding encoding ) = unsigned longtoolbox fn CFStringConvertNSStringEncodingToEncoding( unsigned long encoding ) = CFStringEncoding/* ID mapping functions from/to Microsoft Windows codepage (covers both OEM & ANSI). Returns kCFStringEncodingInvalidId if no mapping exists.*/toolbox fn CFStringConvertEncodingToWindowsCodepage( CFStringEncoding encoding ) = UInt32toolbox fn CFStringConvertWindowsCodepageToEncoding( UInt32 codepage ) = CFStringEncoding/* ID mapping functions from/to IANA registery charset names. Returns kCFStringEncodingInvalidId if no mapping exists.*/toolbox fn CFStringConvertIANACharSetNameToEncoding( CFStringRef theString ) = CFStringEncodingtoolbox fn CFStringConvertEncodingToIANACharSetName( CFStringEncoding encoding ) = CFStringRef/* Returns the most compatible MacOS script value for the input encoding *//* i.e. kCFStringEncodingMacRoman -> kCFStringEncodingMacRoman *//* kCFStringEncodingWindowsLatin1 -> kCFStringEncodingMacRoman *//* kCFStringEncodingISO_2022_JP -> kCFStringEncodingMacJapanese */toolbox fn CFStringGetMostCompatibleMacStringEncoding( CFStringEncoding encoding ) = CFStringEncoding/* The next two functions allow fast access to the contents of a string,  assuming you are doing sequential or localized accesses. To use, call CFStringInitInlineBuffer() with a CFStringInlineBuffer (on the stack, say), and a range in the string to look at. Then call CFStringGetCharacterFromInlineBuffer() as many times as you want, with a index into that range (relative to the start of that range). These are INLINE functions and will end up calling CFString only  once in a while, to fill a buffer. CFStringGetCharacterFromInlineBuffer() returns 0 if a location outside the original range is specified.*/_kCFStringInlineBufferLength = 64begin record CFStringInlineBufferdim as UniChar        buffer( _kCFStringInlineBufferLength )dim as CFStringRef    theString dim as UniCharPtr     directBuffer        // pointer to UniChardim as CFRange        rangeToBuffer       // Range in string to buffer dim as CFIndex        bufferedRangeStart  // Start of range currently buffered (relative to rangeToBuffer.location) dim as CFIndex        bufferedRangeEnd    // bufferedRangeStart + number of chars actually bufferedend recordtoolbox CFStringInitInlineBuffer( CFStringRef str, CFStringInlineBuffer *buf, CFRange range )toolbox fn CFStringGetCharacterFromInlineBuffer( CFStringInlineBuffer *buf, CFIndex idx ) = UniChar/* Rest of the stuff in this file is private and should not be used directly*//* For debugging only Use CFShow() to printf the description of any CFType; Use CFShowStr() to printf detailed info about a CFString*/toolbox CFShow( CFTypeRef obj )toolbox CFShowStr( CFStringRef str )/* This function is private and should not be used directly *///toolbox fn __CFStringMakeConstantString( const char *cStr ) = CFStringRef// ; /* Private; do not use */#endif// ndef _DEFINEDINCARBON