/*last mod  RP  29 October 2005 File: InternetConfig.h Contains: Internet Config interfaces Version: Technology: based on IC 2.5 alpha Release: Universal Interfaces 3.4 */#if ndef _DEFINEDINCARBON// from MacTypes.h/* moved to Tlbx MacTypes.incl   20090806#define ConstStr255Param as Str255*/// Aliases.hbegin record AliasRecorddim userType as OSType/* appl stored type like creator type */dim aliasSize as unsigned short    /* alias record size in bytes, for appl usage */end record/************************************************************************************************ IC error codes ************************************************************************************************/begin enum_icPrefNotFoundErr        = -666/* preference not found (duh!) */_icPermErr                = -667/* cannot set preference */_icPrefDataErr            = -668/* problem with preference data */_icInternalErr            = -669/* hmm, this is not good */_icTruncatedErr           = -670/* more data was present than was returned */_icNoMoreWritersErr       = -671/* you cannot begin a write session because someone else is already doing it */_icNothingToOverrideErr   = -672/* no component for the override component to capture */_icNoURLErr               = -673/* no URL found */_icConfigNotFoundErr      = -674/* no configuration was found */_icConfigInappropriateErr = -675/* incorrect manufacturer code */_icProfileNotFoundErr     = -676/* profile not found */_icTooManyProfilesErr     = -677 /* too many profiles in database */end enum/************************************************************************************************ IC versions (not necessarily, but historically, from a component) ************************************************************************************************/begin enum_kICComponentInterfaceVersion0 = 0x00000000/* IC >= 1.0 */_kICComponentInterfaceVersion1 = 0x00010000/* IC >= 1.1 */_kICComponentInterfaceVersion2 = 0x00020000/* IC >= 1.2 */_kICComponentInterfaceVersion3 = 0x00030000/* IC >= 2.0 */_kICComponentInterfaceVersion4 = 0x00040000/* IC >= 2.5 */_kICComponentInterfaceVersion  = _kICComponentInterfaceVersion4 /* current version number is 4 */end enum/************************************************************************************************ opaque type for preference reference ************************************************************************************************/#Define ICInstance as ptr'^OpaqueICInstance/************************************************************************************************ a record that specifies a folder, an array of such records, and a pointer to such an array ************************************************************************************************/begin record ICDirSpecdim vRefNum as short dim dirID   as long end record/*#Define ICDirSpecArray[4] as ICDirSpec #Define ICDirSpecArrayPtr as ^ICDirSpecArray */#Define ICDirSpecArrayPtr as ptr /************************************************************************************************ preference attributes type, bit number constants, and mask constants ************************************************************************************************/#Define ICAttr as UInt32 begin enum_kICAttrLockedBit   = 0_kICAttrVolatileBit = 1end enumbegin enum_kICAttrNoChange     = 0xFFFFFFFF/* pass this to ICSetPref to tell it not to change the attributes */_kICAttrLockedMask   = 0x00000001_kICAttrVolatileMask = 0x00000002end enum/************************************************************************************************ permissions for use with ICBegin ************************************************************************************************/#Define ICPerm as UInt8 begin enum_icNoPerm        = 0_icReadOnlyPerm  = 1_icReadWritePerm = 2end enum/************************************************************************************************ a reference to an instance's current configuration ************************************************************************************************//************************************************************************************************ profile IDs ************************************************************************************************/#Define ICProfileID    as long #Define ICProfileIDPtr as ptr //to ICProfileID  begin enum_kICNilProfileID = 0end enum/************************************************************************************************ other constants ************************************************************************************************/begin enum_kICNoUserInteractionBit = 0end enumbegin enum_kICNoUserInteractionMask = 0x00000001end enumbegin enum_kICFileType = _"ICAp"_kICCreator  = _"ICAp"end enum/************************************************************************************************ Apple event constants ************************************************************************************************/begin enum_kInternetEventClass = _"GURL"_kAEGetURL           = _"GURL"_kAEFetchURL         = _"FURL"_keyAEAttaching      = _"Atch"end enum/* AERegistry.i defines a compatible key AEDestination */begin enum_kICEditPreferenceEventClass    = _"ICAp"_kICEditPreferenceEvent         = _"ICAp"_keyICEditPreferenceDestination = _"dest"end enum/************************************************************************************************ constants for use with ICGetVersion ************************************************************************************************/begin enum_kICComponentVersion = 0/* Return a component version, comparable to _kICComponentInterfaceVersion */_kICNumVersion       = 1 /* Return a NumVersion structure */end enum/************************************************************************************************ types and constants for use with _kICDocumentFont, et. al. ************************************************************************************************/begin record ICFontRecorddim size as short dim face as Styledim pad  as char dim font as Str255 end record#Define ICFontRecordPtr    as ptr // toICFontRecord #Define ICFontRecordHandle as Handle // to ICFontRecord /************************************************************************************************ types and constants for use with _kICCharacterSet, et. al. ************************************************************************************************/begin record ICCharTabledim netToMac[255] as unsigned chardim macToNet[255] as unsigned char end record#Define ICCharTablePtr as ptr // to ICCharTable #Define ICCharTableHandle as Handle // to ICCharTable /************************************************************************************************ types and constants for use with _kICHelper, et. al. ************************************************************************************************/begin record ICAppSpecdim fCreator as OSType dim name     as Str63 end record#Define ICAppSpecPtr    as ptr // to ICAppSpec #Define ICAppSpecHandle as Handle // to ICAppSpec begin record ICAppSpecListdim numberOfItems as short dim appSpecs[0]   as ICAppSpec end record#Define ICAppSpecListPtr    as ptr // to ICAppSpecList #Define ICAppSpecListHandle as Handle // to ICAppSpecList /************************************************************************************************ types and constants for use with _kICDownloadFolder, et. al. ************************************************************************************************/begin record ICFileSpecdim vol_name          as Str31 dim vol_creation_date as long dim fss               as FSSpec dim alias             as AliasRecord end record#Define ICFileSpecPtr    as ptr // to ICFileSpec #Define ICFileSpecHandle as Handle // to ICFileSpec begin enum_kICFileSpecHeaderSize = sizeof(ICFileSpec) - sizeof(AliasRecord)end enum/************************************************************************************************ types and constants for use with ICMapFilename, et. al. ************************************************************************************************/#Define ICMapEntryFlags as long #Define ICFixedLength   as short begin record ICMapEntrydim totalLength     as short dim fixedLength     as ICFixedLength dim version         as short dim fileType        as OSType dim fileCreator     as OSType dim postCreator     as OSType dim flags           as ICMapEntryFlags dim extension       as Str255 dim creatorAppName  as Str255 dim postAppName     as Str255 dim MIMEType        as Str255 dim entryName       as Str255 end record#Define ICMapEntryPtr    as ptr // to ICMapEntry #Define ICMapEntryHandle as Handle // to ICMapEntry begin enum_kICMapFixedLength = 22 /* number in fixedLength field*/end enumbegin enum_kICMapBinaryBit       = 0/* file should be transfered in binary as opposed to text mode*/_kICMapResourceForkBit = 1/* the resource fork of the file is significant*/_kICMapDataForkBit     = 2/* the data fork of the file is significant*/_kICMapPostBit         = 3/* post process using post fields*/_kICMapNotIncomingBit  = 4/* ignore this mapping for incoming files*/_kICMapNotOutgoingBit  = 5 /* ignore this mapping for outgoing files*/end enumbegin enum_kICMapBinaryMask       = 0x00000001/* file should be transfered in binary as opposed to text mode*/_kICMapResourceForkMask = 0x00000002/* the resource fork of the file is significant*/_kICMapDataForkMask     = 0x00000004/* the data fork of the file is significant*/_kICMapPostMask         = 0x00000008/* post process using post fields*/_kICMapNotIncomingMask  = 0x00000010/* ignore this mapping for incoming files*/_kICMapNotOutgoingMask  = 0x00000020 /* ignore this mapping for outgoing files*/end enum/************************************************************************************************ types and constants for use with _kICServices, et. al. ************************************************************************************************/#Define ICServiceEntryFlags as short begin record ICServiceEntrydim name  as Str255 dim port  as short dim flags as ICServiceEntryFlags end record#Define ICServiceEntryPtr    as ptr // to ICServiceEntry #Define ICServiceEntryHandle as Handle // toICServiceEntry begin enum_kICServicesTCPBit = 0_kICServicesUDPBit = 1 /* both bits can be set, which means the service is both TCP and UDP, eg daytime*/end enumbegin enum_kICServicesTCPMask = 0x00000001_kICServicesUDPMask = 0x00000002 /* both bits can be set, which means the service is both TCP and UDP, eg daytime*/end enumbegin record ICServicesdim count       as short dim services[0] as ICServiceEntry end record#Define ICServicesPtr    as ptr // to ICServices #Define ICServicesHandle as Handle // to ICServices /************************************************************************************************ keys ************************************************************************************************//*  key reserved for use by Internet Config */stringlist off_kICReservedKey$         = "kICReservedKey"'_kICArchieAll$           = "ArchieAll"' STR# -- formatted, list of Archie servers _kICArchiePreferred$     = "ArchiePreferred"' PString -- formatted, preferred Archie server _kICCharacterSet$        = "CharacterSet"' ICCharTable -- Mac-to-Net and Net-to-Mac character translation _kICDocumentFont$        = "DocumentFont"' ICFontRecord -- font used for proportional text _kICDownloadFolder$      = "DownloadFolder"' ICFileSpec -- where to put newly downloaded files _kICEmail$               = "Email"' PString -- user@host.domain, email address of user, ie return address _kICFTPHost$             = "FTPHost"' PString -- host.domain, default FTP server _kICFTPProxyAccount$     = "FTPProxyAccount"' PString -- second level FTP proxy authorisation _kICFTPProxyHost$        = "FTPProxyHost"' PString -- host.domain _kICFTPProxyPassword$    = "FTPProxyPassword"' PString -- scrambled, password for FTPProxyUser _kICFTPProxyUser$        = "FTPProxyUser"' PString -- first level FTP proxy authorisation _kICFingerHost$          = "FingerHost"' PString -- host.domain, default finger server _kICGopherHost$          = "GopherHost"' PString -- host.domain, default Gopher server _kICGopherProxy$         = "GopherProxy"' PString -- host.domain, see note in Prog Docs _kICHTTPProxyHost$       = "HTTPProxyHost"' PString -- host.domain _kICHelper$              = "Helper"' ICAppSpec -- helpers for URL schemes _kICHelperDesc$          = "HelperDesc"' PString -- description for URL scheme _kICHelperList$          = "HelperList"' ICAppSpecList -- list of common helpers for URL schemes _kICIRCHost$             = "IRCHost"' PString -- host.domain, Internet Relay Chat server _kICInfoMacAll$          = "InfoMacAll"' STR# -- formatted, list of Info-Mac servers _kICInfoMacPreferred$    = "InfoMacPreferred"' PString -- formatted, preferred Info-Mac server _kICLDAPSearchbase$      = "LDAPSearchbase"' PString -- string LDAP thing _kICLDAPServer$          = "LDAPServer"' PString -- host.domain _kICListFont$            = "ListFont"' ICFontRecord -- font used for lists of items (eg news article lists) _kICMacSearchHost$       = "MacSearchHost"' PString -- host for MacSearch queries _kICMailAccount$         = "MailAccount"' PString -- user@host.domain, account from which to fetch mail _kICMailHeaders$         = "MailHeaders"' TEXT -- extra headers for mail messages _kICMailPassword$        = "MailPassword"' PString -- scrambled, password for MailAccount _kICMapping$             = "Mapping"' ICMapEntries -- file type mapping, see documentation _kICNNTPHost$            = "NNTPHost"' PString -- host.domain, NNTP server _kICNTPHost$             = "NTPHost"' PString -- host.domain, Network Time Protocol (NTP) _kICNewMailDialog$       = "NewMailDialog"' Boolean _kICNewMailFlashIcon$    = "NewMailFlashIcon"' Boolean -- how to announce new mail _kICNewMailPlaySound$    = "NewMailPlaySound"' Boolean _kICNewMailSoundName$    = "NewMailSoundName"' PString _kICNewsAuthPassword$    = "NewsAuthPassword"' PString -- scrambled, password for NewsAuthUsername _kICNewsAuthUsername$    = "NewsAuthUsername"' PString -- user name for authorised news servers _kICNewsHeaders$         = "NewsHeaders"' TEXT -- extra headers for news messages _kICNoProxyDomains$      = "NoProxyDomains"' STR# -- list of domains not to be proxied _kICOrganization$        = "Organization"' PString -- for X-Organization string _kICPhHost$              = "PhHost"' PString -- host.domain, default Ph server _kICPlan$                = "Plan"' TEXT -- default response for finger servers _kICPrinterFont$         = "PrinterFont"' ICFontRecord -- font used to print ScreenFont _kICQuotingString$       = "QuotingString"' PString -- used to quote responses in news and mail _kICRealName$            = "RealName"' PString -- real name of user _kICRTSPProxyHost$       = "RTSPProxyHost"' PString -- RTSP Proxy Host_kICSMTPHost$            = "SMTPHost"' PString -- host.domain, SMTP server _kICScreenFont$          = "ScreenFont"' ICFontRecord -- font used for monospaced text (eg news articles) _kICServices$            = "Services"' ICServices -- TCP and IP port-to-name mapping _kICSignature$           = "Signature"' TEXT -- append to news and mail messages _kICSnailMailAddress$    = "SnailMailAddress"' TEXT -- preferred mailing address _kICSocksHost$           = "SocksHost"' PString -- host.domain, remember that host.domain format allows ":port" and " port" _kICTelnetHost$          = "TelnetHost"' PString -- host.domain, default Telnet address _kICUMichAll$            = "UMichAll"' STR# -- formatted, list of UMich servers_kICUMichPreferred$      = "UMichPreferred"' PString -- formatted, preferred UMich server _kICUseFTPProxy$         = "UseFTPProxy"' Boolean _kICUseGopherProxy$      = "UseGopherProxy"' Boolean  _kICUseHTTPProxy$        = "UseHTTPProxy"' Boolean _kICUsePassiveFTP$       = "UsePassiveFTP"' Boolean -- use PASV command for FTP transfers _kICUseRTSPProxy$        = "UseRTSPProxy"' Boolean_kICUseSocks$            = "UseSocks"' Boolean _kICWAISGateway$         = "WAISGateway"' PString -- no idea _kICWWWHomePage$         = "WWWHomePage"' PString -- URL, users default WWW page _kICWebBackgroundColour$ = "WebBackgroundColour"' RGBColor -- background colour for web pages _kICWebReadColor$        = "646F6777쩦ebReadColor"' RGBColor -- colour for read links _kICWebSearchPagePrefs$  = "WebSearchPagePrefs"' PString -- URL, users default search page _kICWebTextColor$        = "WebTextColor"' RGBColor -- colour for normal text _kICWebUnderlineLinks$   = "646F6777쩦ebUnderlineLinks"' Boolean -- whether to underline links _kICWebUnreadColor$      = "646F6777쩦ebUnreadColor"' RGBColor -- colour for unread links _kICWhoisHost$           = "WhoisHost"' PString -- host.domain, default whois server stringlist/************************************************************************************************ FUNCTIONS What do the annotations after each API mean? -------------------------------------------- [r1] Requires IC 1.1 or higher. [r2] Requires IC 1.2 or higher. [r3] Requires IC 2.0 or higher. [r4] Requires IC 2.5 or higher.  IMPORTANT: In IC 2.5, instances automatically use the default configuration. You no longer need to configure an instance explicitly, except if your code might run with an older version of IC. So the following notes only apply to IC 2.0 and earlier. [c1] You must have specified a configuration before calling this routine.  [c2] You must have specified the default configuration before calling this routine.  [c3] You do not need to specify a configuration before calling this routine.  [b1] You must be inside a Begin/End pair when calling this routine.  [b2] You must be inside a Begin/End read/write pair when calling this routine.  [b3] You do not need to be inside a Begin/End pair when calling this routine.  [b4] If you are getting or setting multiple preferences, you should make this call inside a Begin/End pair. If you do not make this call inside a Begin/End pair, the call will automatically do it for you.  [b5] It is illegal to call this routine inside a Begin/End pair. ************************************************************************************************/'~***** Starting Up and Shutting Down ******Toolbox fn ICStart(ICInstance * inst, OSType signature) = OSStatus/* Call this at application initialisation. Set signature to a value * which has been regsitered with DTS to allow for future expansion * of the IC system. Returns inst as a connection to the IC system. */Toolbox fn ICStop(ICInstance inst) = OSStatus/* [b5]  * Call this at application initialisation, after which inst * is no longer valid connection to IC. */Toolbox fn ICGetVersion(ICInstance inst, long whichVersion, UInt32 * version) = OSStatus `0x2F3C, 0x0008, 0x0032, 0x7000, 0xA82A/* [r4] [c3] [b3]  * Returns the version of Internet Config. Pass_kICComponentVersion * to get the version as previously returned by GetComponenVerson. * Pass_kICNumVersion to get a NumVersion structure. */Toolbox fn ICGetConfigName(ICInstance inst, Boolean longname, Str255 name) = OSStatus `0x2F3C, 0x0006, 0x0023, 0x7000, 0xA82A/* [r2] [c1] [b3]  * Returns a string that describes the current configuration at a user * level. Set longname to true if you want a long name, up to 255 * characters, or false if you want a short name, typically about 32 * characters. * The returned string is for user display only. If you rely on the * exact format of it, you will conflict with any future IC * implementation that doesn't use explicit preference files. */'~***** Getting Information ******Toolbox fn ICGetSeed(ICInstance inst, long * seed) = OSStatus `0x2F3C, 0x0004, 0x0004, 0x7000, 0xA82A/* [c3] [b3]  * Returns the current seed for the IC prefs database. * This seed changes each time a non-volatile preference is changed. * You can poll this to determine if any cached preferences change. */Toolbox fn ICGetPerm(ICInstance inst, ICPerm * perm) = OSStatus `0x2F3C, 0x0004, 0x000D, 0x7000, 0xA82A/* [c3] [b3]  * Returns the access permissions currently associated with this instance. * While applications normally_know what permissions they have * this routine is designed for use by override components. */'~***** Reading and Writing Preferences *****Toolbox fn ICBegin(ICInstance inst, ICPerm perm) = OSStatus `0x2F3C, 0x0002, 0x0005, 0x7000, 0xA82A/* [c1] [b5]  * Starting reading or writing multiple preferences. * A call to this must be balanced by a call to ICEnd. * Do not call WaitNextEvent between these calls. * The perm specifies whether you intend to read or read/write. * Only one writer is allowed per instance. * Note that this may open resource files that are not closed * until you call ICEnd. */Toolbox fn ICGetPref(ICInstance inst, ConstStr255Param key, ICAttr * attr, ptr * buf, long * size) = OSStatus `0x2F3C, 0x0010, 0x0006, 0x7000, 0xA82A/* [c1] [b4]  * Reads the preference specified by key from the IC database to the * buffer pointed to by buf and size. * key must not be the empty string. * If buf is nil then no data is returned. * size must be non-negative. * attr and size are always set on return. On errors (except icTruncatedErr) * attr is set to ICattr_no_change and size is set to 0. * size is the actual size of the data. * attr is set to the attributes associated with the preference. * If this routine returns icTruncatedErr then the other returned * values are valid except that only the first size bytes have been * return. size is adjusted to reflect the true size of the preference. * Returns icPrefNotFoundErr if there is no preference for the key. */Toolbox fn ICSetPref(ICInstance inst, ConstStr255Param key, ICAttr attr, ptr * buf, long size) = OSStatus `0x2F3C, 0x0010, 0x0007, 0x7000, 0xA82A/* [c1] [b4]  * Sets the preference specified by key from the IC database to the * value pointed to by buf and size. * key must not be the empty string. * size must be non-negative.  * If buf is nil then the preference value is not set and size is ignored. * If buf is not nil then the preference value is set to the size * bytes pointed to by buf. * If attr is ICattr_no_change then the preference attributes are not set. * Otherwise the preference attributes are set to attr. * Returns icPermErr if the previous ICBegin was passed icReadOnlyPerm. * Returns icPermErr if current attr is locked, new attr is locked and buf <> nil. */Toolbox fn ICFindPrefHandle(ICInstance inst, ConstStr255Param key, ICAttr * attr, Handle prefh) = OSStatus `0x2F3C, 0x000C, 0x0024, 0x7000, 0xA82A/* [r2] [c1] [b4]  * This routine effectively replaces ICGetPrefHandle. * Reads the preference specified by key from the IC database into * a handle, prefh. * key must not be the empty string. * attr is set to the attributes associated with the preference. * You must set prefh to a non-nil handle before calling this routine. * If the preference does not exist, icPrefNotFoundErr is returned. */Toolbox fn ICGetPrefHandle(ICInstance inst, ConstStr255Param key, ICAttr * attr, Handle * prefh) = OSStatus `0x2F3C, 0x000C, 0x001A, 0x7000, 0xA82A/* [r1] [c1] [b4]  * This routine is now obsolete. Use ICFindPrefHandle instead. * Reads the preference specified by key from the IC database into * a newly created handle, prefh. * key must not be the empty string. * attr is set to the attributes associated with the preference. * The incoming value of prefh is ignored. * A new handle is created in the current heap and returned in prefh. * If the routine returns an error, prefh is set to nil. * If the preference does not exist, no error is returned and prefh is set * to an empty handle. */Toolbox fn ICSetPrefHandle(ICInstance inst, ConstStr255Param key, ICAttr attr, Handle prefh) = OSStatus `0x2F3C, 0x000C, 0x001B, 0x7000, 0xA82A/* [r1] [c1] [b4]  * Sets the preference specified by key from the IC database to the * value contained in prefh. * key must not be the empty string. * If prefh is nil then the preference value is not set. * If buf is not nil then the preference value is set to the data * contained in it. * If attr is ICattr_no_change then the preference attributes are not set. * Otherwise the preference attributes are set to attr. * Returns icPermErr if the previous ICBegin was passed icReadOnlyPerm. * Returns icPermErr if current attr is locked, new attr is locked and prefh <> nil. */Toolbox fn ICCountPref(ICInstance inst, long * count) = OSStatus `0x2F3C, 0x0004, 0x0008, 0x7000, 0xA82A/* [c1] [b1]  * Counts the total number of preferences. * If the routine returns an error, count is set to 0. */Toolbox fn ICGetIndPref(ICInstance inst, long index, Str255 key) = OSStatus `0x2F3C, 0x0008, 0x0009, 0x7000, 0xA82A/* [c1] [b1]  * Returns the key of the index'th preference. * index must be positive. * Returns icPrefNotFoundErr if index is greater than the total number of preferences. * If the routine returns an error, key is undefined. */Toolbox fn ICDeletePref(ICInstance inst, ConstStr255Param key) = OSStatus `0x2F3C, 0x0004, 0x000C, 0x7000, 0xA82A/* [c1] [b2]  * Deletes the preference specified by key. * key must not be the empty string. * Returns icPrefNotFound if the preference specified by key is not present. */Toolbox fn ICEnd(ICInstance inst) = OSStatus `0x2F3C, 0x0000, 0x000A, 0x7000, 0xA82A/* [c1] [b1]  * Terminates a preference session, as started by ICBegin. * You must have called ICBegin before calling this routine. */Toolbox fn ICGetDefaultPref(ICInstance inst, ConstStr255Param key, Handle prefH) = OSStatus `0x2F3C, 0x0008, 0x0031, 0x7000, 0xA82A/* [r4] [c3] [b5]  * Returns a default preference value for the specified key. You * must pass in a valid prefH, which is resized to fit the data. */'~***** User Interface Stuff ******Toolbox fn ICEditPreferences(ICInstance inst, ConstStr255Param key) = OSStatus `0x2F3C, 0x0004, 0x000F, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Instructs IC to display the user interface associated with editing * preferences and focusing on the preference specified by key. * If key is the empty string then no preference should be focused upon. * You must have specified a configuration before calling this routine. * You do not need to call ICBegin before calling this routine. * In the current implementation this launches the IC application * (or brings it to the front) and displays the window containing * the preference specified by key. * It may have a radically different implementation in future * IC systems. */'~***** URL Handling ******Toolbox fn ICLaunchURL(ICInstance inst, ConstStr255Param hint, ptr * theData, long length, long * selStart, long * selEnd) = OSStatus `0x2F3C, 0x0014, 0x0011, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Parses a URL out of the specified text and feeds it off to the * appropriate helper. * hint indicates the default scheme for URLs of the form "name@address". * If hint is the empty string then URLs of that form are not allowed. * data points to the start of the text. It must not be nil. * len indicates the length of the text. It must be non-negative. * selStart and selEnd should be passed in as the current selection of * the text. This selection is given in the same manner as TextEdit * ie if selStart = selEnd then there is no selection only an insertion * point. Also selStart  selEnd and 0  selStart  len and 0  selEnd  len. * selStart and selEnd are returned as the bounds of the URL. If the * routine returns an error then these new boundaries may be * invalid but they will be close. * The URL is parsed out of the text and passed off to the appropriate * helper using the GURL AppleEvent. */Toolbox fn ICParseURL(ICInstance inst, ConstStr255Param hint, ptr * theData, long length, long * selStart, long * selEnd, Handle url) = OSStatus `0x2F3C, 0x0018, 0x0010, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Parses a URL out of the specified text and returns it in a canonical form * in a handle. * hint indicates the default scheme for URLs of the form "name@address". * If hint is the empty string then URLs of that form are not allowed. * data points to the start of the text. It must not be nil. * len indicates the length of the text. It must be non-negative. * selStart and selEnd should be passed in as the current selection of * the text. This selection is given in the same manner as TextEdit * ie if selStart = selEnd then there is no selection only an insertion * point. Also selStart  selEnd and 0  selStart  len and 0  selEnd  len. * selStart and selEnd are returned as the bounds of the URL. If the * routine returns an error then these new boundaries may be * invalid but they will be close. * The incoming url handle must not be nil. The resulting URL is normalised * and copied into the url handle, which is resized to fit. */Toolbox fn ICCreateGURLEvent(ICInstance inst, OSType helperCreator, Handle urlH, AppleEvent * theEvent) = OSStatus `0x2F3C, 0x000C, 0x0033, 0x7000, 0xA82A/* [r4] [c1] [b3]  * Creates a GURL Apple event, targetted at the application whose creator * code is helperCreator, with a direct object containing the URL text from urlH. */Toolbox fn ICSendGURLEvent(ICInstance inst, AppleEvent * theEvent) = OSStatus `0x2F3C, 0x0004, 0x0034, 0x7000, 0xA82A/* [r4] [c1] [b3]  * Sends theEvent to the target application. */'~ Routines for interrogating mappings database/* ***** Mappings Routines ******//* ----- High Level Routines -----*/Toolbox fn ICMapFilename(ICInstance inst, ConstStr255Param filename, ICMapEntry * entry) = OSStatus `0x2F3C, 0x0008, 0x0018, 0x7000, 0xA82A/* [r1] [c1] [b4]  * Takes the name of an incoming file and returns the most appropriate * mappings database entry, based on its extension. * filename must not be the empty string. * Returns icPrefNotFoundErr if no suitable entry is found. */Toolbox fn ICMapTypeCreator(ICInstance inst, OSType fType, OSType fCreator, ConstStr255Param filename, ICMapEntry * entry) = OSStatus `0x2F3C, 0x0010, 0x0019, 0x7000, 0xA82A/* [r1] [c1] [b4]  * Takes the type and creator (and optionally the name) of an outgoing * file and returns the most appropriate mappings database entry. * The filename may be either the name of the outgoing file or * the empty string. * Returns icPrefNotFoundErr if no suitable entry found. *//* ----- Mid Level Routines ----- */Toolbox fn ICMapEntriesFilename(ICInstance inst, Handle entries, ConstStr255Param filename, ICMapEntry * entry) = OSStatus `0x2F3C, 0x000C, 0x001C, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Takes the name of an incoming file and returns the most appropriate * mappings database entry, based on its extension. * entries must be a handle to a valid IC mappings database preference. * filename must not be the empty string. * Returns icPrefNotFoundErr if no suitable entry is found. */Toolbox fn ICMapEntriesTypeCreator(ICInstance inst, Handle entries, OSType fType, OSType fCreator, ConstStr255Param filename, ICMapEntry * entry) = OSStatus `0x2F3C, 0x0014, 0x001D, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Takes the type and creator (and optionally the name) of an outgoing * file and returns the most appropriate mappings database entry. * entries must be a handle to a valid IC mappings database preference. * The filename may be either the name of the outgoing file or * the empty string. * Returns icPrefNotFoundErr if no suitable entry found. *//* ----- Low Level Routines ----- */Toolbox fn ICCountMapEntries(ICInstance inst, Handle entries, long * count) = OSStatus `0x2F3C, 0x0008, 0x0012, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Counts the number of entries in the mappings database. * entries must be a handle to a valid IC mappings database preference. * count is set to the number of entries. */Toolbox fn ICGetIndMapEntry(ICInstance inst, Handle entries, long index, long * position, ICMapEntry * entry) = OSStatus `0x2F3C, 0x0010, 0x0013, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Gets the index'th entry in the mappings database. * entries must be a handle to a valid IC mappings database preference. * index must be in the range from 1 to the number of entries in the database. * The value of pos is ignored on input. pos is set to the position of * the index'th entry in the database and is suitable for passing back * into ICSetMapEntry. * Does not return any user data associated with the entry. */Toolbox fn ICGetMapEntry(ICInstance inst, Handle entries, long position, ICMapEntry * entry) = OSStatus `0x2F3C, 0x000C, 0x0014, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Returns the entry located at position pos in the mappings database. * entries must be a handle to a valid IC mappings database preference. * pos should be 0 to get the first entry. To get the subsequent entries, add * entry.total_size to pos and iterate. * Does not return any user data associated with the entry. */Toolbox fn ICSetMapEntry(ICInstance inst, Handle entries, long position, const ICMapEntry * entry) = OSStatus `0x2F3C, 0x000C, 0x0015, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Sets the entry located at position pos in the mappings database. * entries must be a handle to a valid IC mappings database preference. * pos should be either a value returned from ICGetIndMapEntry or a value * calculated using ICGetMapEntry. * entry is a var parameter purely for stack space reasons. It is not * modified in any way. * Any user data associated with the entry is unmodified. */Toolbox fn ICDeleteMapEntry(ICInstance inst, Handle entries, long position) = OSStatus `0x2F3C, 0x0008, 0x0016, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Deletes the mappings database entry at pos. * entries must be a handle to a valid IC mappings database preference. * pos should be either a value returned from ICGetIndMapEntry or a value * calculated using ICGetMapEntry. * Also deletes any user data associated with the entry. */Toolbox fn ICAddMapEntry(ICInstance inst, Handle entries, const ICMapEntry * entry) = OSStatus `0x2F3C, 0x0008, 0x0017, 0x7000, 0xA82A/* [r1] [c1] [b3]  * Adds an entry to the mappings database. * entries must be a handle to a valid IC mappings database preference. * The entry is added to the end of the entries database. * No user data is added. */'~***** Profile Management Routines *****Toolbox fn ICGetCurrentProfile(ICInstance inst, ICProfileID * currentID) = OSStatus `0x2F3C, 0x0004, 0x0025, 0x7000, 0xA82A/* [r3] [c1] [b3]  * Returns the profile ID of the current profile. */Toolbox fn ICSetCurrentProfile(ICInstance inst, ICProfileID newID) = OSStatus `0x2F3C, 0x0004, 0x0026, 0x7000, 0xA82A/* [r3] [c1] [b3]  * Sets the current profile to the profile specified in newProfile. */Toolbox fn ICCountProfiles(ICInstance inst, long * count) = OSStatus `0x2F3C, 0x0004, 0x0027, 0x7000, 0xA82A/* [r3] [c1] [b1]  * Returns the total number of profiles. */Toolbox fn ICGetIndProfile(ICInstance inst, long index, ICProfileID * thisID) = OSStatus `0x2F3C, 0x0008, 0x0028, 0x7000, 0xA82A/* [r3] [c1] [b1]  * Returns the profile ID of the index'th profile. index must be positive. * Returns icProfileNotFoundErr if index is greater than the total number * of profiles. */Toolbox fn ICGetProfileName(ICInstance inst, ICProfileID thisID, Str255 name) = OSStatus `0x2F3C, 0x0008, 0x0029, 0x7000, 0xA82A/* [r3] [c1] [b3]  * Returns the name of a profile given its ID. The name may not uniquely * identify the profile. [That's what the profile ID is for!] The name * is assumed to be in the system script. */Toolbox fn ICSetProfileName(ICInstance inst, ICProfileID thisID, ConstStr255Param name) = OSStatus `0x2F3C, 0x0008, 0x002A, 0x7000, 0xA82A/* [r3] [c1] [b3]  * This routine sets the name of the specified profile. Profile names * need not be unique. The name should be in the system script. */Toolbox fn ICAddProfile(ICInstance inst, ICProfileID prototypeID, ICProfileID * newID) = OSStatus `0x2F3C, 0x0008, 0x002B, 0x7000, 0xA82A/* [r3] [c1] [b2]  * If prototypeID = _kICNilProfileID, this routine * creates a default profile, otherwise it creates a * profile by cloning the prototype profile. The ID * of the new profile is returned in newID. * The new profile will be give a new, unique, name. * This does not switch to the new profile. */Toolbox fn ICDeleteProfile(ICInstance inst, ICProfileID thisID) = OSStatus `0x2F3C, 0x0004, 0x002C, 0x7000, 0xA82A/* [r3] [c1] [b2]  * This routine deletes the profile specified by * thisID. Attempting to delete the current profile * or the last profile will return error. */#endif // _DEFINEDINCARBON