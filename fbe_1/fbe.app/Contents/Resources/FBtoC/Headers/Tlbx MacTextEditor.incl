/*     File:       HIToolbox/MacTextEditor.h     Contains:   Interfaces for MLTE - TextEdit replacementlast modified  RP    29 Oct 2005 to include some of the 10.3 HIView supportCurrently lacks much 10.3, and all the wonderful 10.4, support for HITextView*/include "Tlbx HIView.Incl"// miscellaneous stuff *not* fromMacTextEditor.h//#define FourCharCode as UInt32//#define ByteCount    as UInt32#if def _DEFINEDINCARBON#define ATSUStyle    as pointer // opaque// from MacErrors.h (for reference)/*  kTXNEndIterationErr           = -22000,  kTXNCannotAddFrameErr         = -22001,  kTXNInvalidFrameIDErr         = -22002,  kTXNIllegalToCrossDataBoundariesErr = -22003,  kTXNUserCanceledOperationErr  = -22004,  kTXNBadDefaultFileTypeWarning = -22005,  kTXNCannotSetAutoIndentErr    = -22006,  kTXNRunIndexOutofBoundsErr    = -22007,  kTXNNoMatchErr                = -22008,  kTXNAttributeTagInvalidForRunErr = -22009, //dataValue is set to this per invalid tag  kTXNSomeOrAllTagsInvalidForRunErr = -22010,  kTXNInvalidRunIndex           = -22011,  kTXNAlreadyInitializedErr     = -22012,  kTXNCannotTurnTSMOffWhenUsingUnicodeErr = -22013,  kTXNCopyNotAllowedInEchoModeErr = -22014,  kTXNDataTypeNotAllowedErr     = -22015,  kTXNATSUIIsNotInstalledErr    = -22016,  kTXNOutsideOfLineErr          = -22017,  kTXNOutsideOfFrameErr         = -22018*///MacTextEditor.h#define TXNObject as pointer //to OpaqueTXNObject#define TXNFontMenuObject as pointer //to OpaqueTXNFontMenuObject#define TXNFrameID as UInt32#define TXNVersionValue as UInt32begin enum_kTXNWillDefaultToATSUIBit = 0_kTXNWillDefaultToCarbonEventBit = 1end enum#define TXNFeatureBits as OptionBitsbegin enum_kTXNWillDefaultToATSUIMask = 1<<_kTXNWillDefaultToATSUIBit_kTXNWillDefaultToCarbonEventMask = 1<<_kTXNWillDefaultToCarbonEventBitend enumbegin enum_kTXNWantMoviesBit = 0_kTXNWantSoundBit = 1_kTXNWantGraphicsBit = 2_kTXNAlwaysUseQuickDrawTextBit = 3_kTXNUseTemporaryMemoryBit = 4end enum#define TXNInitOptions as OptionBitsbegin enum_kTXNWantMoviesMask = 1 << _kTXNWantMoviesBit_kTXNWantSoundMask = 1 << _kTXNWantSoundBit_kTXNWantGraphicsMask = 1 << _kTXNWantGraphicsBit_kTXNAlwaysUseQuickDrawTextMask = 1 << _kTXNAlwaysUseQuickDrawTextBit_kTXNUseTemporaryMemoryMask = 1 << _kTXNUseTemporaryMemoryBitend enumbegin enum_kTXNDrawGrowIconBit = 0_kTXNShowWindowBit = 1_kTXNWantHScrollBarBit = 2_kTXNWantVScrollBarBit = 3_kTXNNoTSMEverBit = 4_kTXNReadOnlyBit = 5_kTXNNoKeyboardSyncBit = 6_kTXNNoSelectionBit = 7_kTXNSaveStylesAsSTYLResourceBit = 8_kOutputTextInUnicodeEncodingBit = 9_kTXNDoNotInstallDragProcsBit = 10_kTXNAlwaysWrapAtViewEdgeBit = 11_kTXNDontDrawCaretWhenInactiveBit = 12_kTXNDontDrawSelectionWhenInactiveBit = 13_kTXNSingleLineOnlyBit = 14_kTXNDisableDragAndDropBit = 15_kTXNUseQDforImagingBit = 16_kTXNMonostyledTextBit = 17end enum/* *  TXNFrameOptions *   *  Summary: *    Defines the initial behavior of an MLTE object created with *    TXNNewObject. *   *  Discussion: *    These masks can be combined and passed to TXNNewObject to define *    the initial behavior of a new object. */#define TXNFrameOptions as OptionBitsbegin enum not output/*   * Indicates that the frame will have a size box.   */_kTXNDrawGrowIconMask = 1 << _kTXNDrawGrowIconBit/*   * Indicates that the window associated with the text object will be   * displayed when the object is created.  The application no longer   * needs to call the ShowWindow function from the Window Manager;   * MLTE will do this for you.   */_kTXNShowWindowMask = 1 << _kTXNShowWindowBit/*   * Indicates that the frame will have a horizontal scrollbar.   */_kTXNWantHScrollBarMask = 1 << _kTXNWantHScrollBarBit/*   * Indicates that the frame will have a vertical scrollbar.   */_kTXNWantVScrollBarMask = 1 << _kTXNWantVScrollBarBit/*   * Indicates that the Text Services Manager will not be used.  You   * cannot use this mask when your application accepts Unicode input.   */_kTXNNoTSMEverMask = 1 << _kTXNNoTSMEverBit/*   * Indicates that the text object will be read-only.   */_kTXNReadOnlyMask = 1 << _kTXNReadOnlyBit/*   * Indicates that keyboard synchronization will not occur.   */_kTXNNoKeyboardSyncMask = 1 << _kTXNNoKeyboardSyncBit/*   * Indicates that the user shouldn`t be able to set the insertion   * point or make a selection.   */_kTXNNoSelectionMask = 1 << _kTXNNoSelectionBit/*   * Indicates that the text style will be saved as a   * kTXNMultipleStylesPerTextDocumentResType resource.  You can set   * this to assure compatibility with SimpleText.  If you use   * kTXNMultipleStylesPerTextDocumentResType resources to save style   * info, your documents can have as many styles as you`d like.    * However tabs are not saved.  If you don`t use this mask, plain   * text files are saved as kTXNSingleStylePerTextDocumentResType   * resources, and only the first style in the document is saved.    * (Your application is expected to apply all style changes to the   * entire document.)  If you save files with a   * kTXNSingleStylePerTextDocumentResType resource, their output is   * similar to those output by CodeWarrior, BBEdit, and MPW.   */_kTXNSaveStylesAsSTYLResourceMask = 1 << _kTXNSaveStylesAsSTYLResourceBit/*   * Indicates that plain text will be saved as Unicode.   */_kOutputTextInUnicodeEncodingMask = 1 << _kOutputTextInUnicodeEncodingBit/*   * Indicates that MLTE will not install its own drag handler for the   * text object.  This can be used if the client wants to install   * their own handler.   */_kTXNDoNotInstallDragProcsMask = 1 << _kTXNDoNotInstallDragProcsBit/*   * Indicates that lines will wrap at the edge of the view rectangle.   */_kTXNAlwaysWrapAtViewEdgeMask = 1 << _kTXNAlwaysWrapAtViewEdgeBit/*   * Indicates that the caret shouldn`t be drawn when the text object   * doesn`t have focus.   */_kTXNDontDrawCaretWhenInactiveMask = 1 << _kTXNDontDrawCaretWhenInactiveBit/*   * Indicates that the selection (if one) shouldn`t be drawn when the   * text object doesn`t have focus.   */_kTXNDontDrawSelectionWhenInactiveMask = 1 << _kTXNDontDrawSelectionWhenInactiveBit/*   * Indicates that the text object will not scroll vertically,   * horizontal scrolling will stop when the end of the text is visible   * (plus any right margin), and there will be no limit to the width   * of the text.   */_kTXNSingleLineOnlyMask = 1 << _kTXNSingleLineOnlyBit/*   * Indicates that drag and drop will not be allowed in the text   * object.   */_kTXNDisableDragAndDropMask = 1 << _kTXNDisableDragAndDropBit/*   * Indicates that QuickDraw will be used for imaging instead of the   * default CoreGraphics (Quartz). [X-only]   */_kTXNUseQDforImagingMask = 1 << _kTXNUseQDforImagingBit/*   * Indicates that the text object will keep in single style no matter   * what kind of changes made to the object.   */_kTXNMonostyledTextMask = 1 << _kTXNMonostyledTextBitend enumbegin enum_kTXNSetFlushnessBit = 0_kTXNSetJustificationBit = 1_kTXNUseFontFallBackBit = 2_kTXNRotateTextBit = 3_kTXNUseVerticalTextBit = 4_kTXNDontUpdateBoxRectBit = 5_kTXNDontDrawTextBit = 6_kTXNUseCGContextRefBit = 7_kTXNImageWithQDBit = 8_kTXNDontWrapTextBit = 9end enum/* *  TXNTextBoxOptions *   *  Summary: *    Defines how text will be drawn by one of the TXNxxxDrawTextBox *    API. *   *  Discussion: *    These masks can be combined and added to a TXNTextBoxOptionsData *    structure to be passed to a TXNxxxDrawTextBox API. */#define TXNTextBoxOptions as OptionBitsbegin enum not output/*   * Indicates that the text will be flush according to the line   * direction.   */_kTXNSetFlushnessMask = 1 << _kTXNSetFlushnessBit/*   * Indicates that the text will be justified in the direction that   * the text is displayed.  Horizontal text will be justified   * horizontally, but not vertically.  Vertical text will be justified   * vertically, but not horizontally.   */_kTXNSetJustificationMask = 1 << _kTXNSetJustificationBit/*   * Indicates that ATSUI transient font matching (that searches for a   * font that has a matching character) will be used.   */_kTXNUseFontFallBackMask = 1 << _kTXNUseFontFallBackBit/*   * Indicates that the text will be rotated.  The amount of rotation   * is given in the rotation field of the TXNTextBoxOptionsData   * structure and is in units of degrees (negative values indicate   * clockwise rotation).   */_kTXNRotateTextMask = 1 << _kTXNRotateTextBit/*   * Indicates that the text will be displayed vertically from top to   * bottom.   */_kTXNUseVerticalTextMask = 1 << _kTXNUseVerticalTextBit/*   * Indicates that the specified rectangle will not be updated.  If   * you use this mask when you call a TXNDrawxxxTextBox function, the   * funtion does not update the right coordinate (bottom coordinate if   * kTXNUseVerticalTextMask is used) of the specified rectangle to   * accommodate the longest line for text.   */_kTXNDontUpdateBoxRectMask = 1 << _kTXNDontUpdateBoxRectBit/*   * Indicates that the size of the text will be returned but the text   * box will not be drawn.   */_kTXNDontDrawTextMask = 1 << _kTXNDontDrawTextBit/*   * Indicates that the client has provided a CGContext to be used for   * CG imaging inside the text box. [X-only]   */_kTXNUseCGContextRefMask = 1 << _kTXNUseCGContextRefBit/*   * Indicates that imaging will be done using QuickDraw instead of the   * default CoreGraphics. [X-only]   */_kTXNImageWithQDMask = 1 << _kTXNImageWithQDBit/*   * Indicates that text should not be wrapped. [X-only]   */_kTXNDontWrapTextMask = 1 << _kTXNDontWrapTextBitend enumbegin record TXNTextBoxOptionsDatadim as TXNTextBoxOptions optionTagsdim as Fract flushnessdim as Fract justificationdim as Fixed rotationdim options as pointer //to void/* for future use*/end record begin enum not output_kTXNFontContinuousBit = 0_kTXNSizeContinuousBit = 1_kTXNStyleContinuousBit = 2_kTXNColorContinuousBit = 3end enum#define TXNContinuousFlags as OptionBitsbegin enum not output_kTXNFontContinuousMask = 1 << _kTXNFontContinuousBit_kTXNSizeContinuousMask = 1 << _kTXNSizeContinuousBit_kTXNStyleContinuousMask = 1 << _kTXNStyleContinuousBit_kTXNColorContinuousMask = 1 << _kTXNColorContinuousBitend enumbegin enum not output_kTXNIgnoreCaseBit = 0_kTXNEntireWordBit = 1_kTXNUseEncodingWordRulesBit = 31end enum#define TXNMatchOptions as OptionBitsbegin enum not output_kTXNIgnoreCaseMask = 1 << _kTXNIgnoreCaseBit_kTXNEntireWordMask = 1 << _kTXNEntireWordBit_kTXNUseEncodingWordRulesMask = (1 << _kTXNUseEncodingWordRulesBit)end enum#define TXNFileType as OSTypebegin enum not output_kTXNTextensionFile = _"txtn"_kTXNTextFile = _"TEXT"_kTXNPictureFile = _"PICT"_kTXNMovieFile = _"MooV"_kTXNSoundFile = _"sfil"_kTXNAIFFFile = _"AIFF"_kTXNUnicodeTextFile = _"utxt"end enum/* Only kTXNTextEditStyleFrameType is supported at this time */#define TXNFrameType as UInt32begin enum not output_kTXNTextEditStyleFrameType = 1_kTXNPageFrameType = 2/* not supported*/_kTXNMultipleFrameType = 3/* not supported*/end enum#define TXNDataType as OSTypebegin enum not output_kTXNTextData = _"TEXT"_kTXNPictureData = _"PICT"_kTXNMovieData = _"moov"_kTXNSoundData = _"snd"_kTXNUnicodeTextData = _"utxt"end enum#define TXNControlTag as FourCharCodebegin enum not output_kTXNLineDirectionTag = _"lndr"_kTXNJustificationTag = _"just"_kTXNIOPrivilegesTag = _"iopv"_kTXNSelectionStateTag = _"slst"_kTXNInlineStateTag = _"inst"_kTXNWordWrapStateTag = _"wwrs"_kTXNKeyboardSyncStateTag = _"kbsy"_kTXNAutoIndentStateTag = _"auin"_kTXNTabSettingsTag = _"tabs"_kTXNRefConTag = _"rfcn"_kTXNMarginsTag = _"marg"_kTXNFlattenMoviesTag = _"flat"_kTXNDoFontSubstitution = _"fSub"/*note : this could degrade performance greatly in the case of large documents.*/_kTXNNoUserIOTag = _"nuio"_kTXNUseCarbonEvents = _"cbcb"_kTXNDrawCaretWhenInactiveTag = _"dcrt"_kTXNDrawSelectionWhenInactiveTag = _"dsln"_kTXNDisableDragAndDropTag = _"drag"_kTXNSingleLevelUndoTag = _"undo"_kTXNVisibilityTag = _"visb"/*set the visibility state of the object*/end enum#define TXNActionKey as UInt32begin enum not output_kTXNTypingAction = 0_kTXNCutAction = 1_kTXNPasteAction = 2_kTXNClearAction = 3_kTXNChangeFontAction = 4_kTXNChangeFontColorAction = 5_kTXNChangeFontSizeAction = 6_kTXNChangeStyleAction = 7_kTXNAlignLeftAction = 8_kTXNAlignCenterAction = 9_kTXNAlignRightAction = 10_kTXNDropAction = 11_kTXNMoveAction = 12_kTXNFontFeatureAction = 13_kTXNFontVariationAction = 14_kTXNUndoLastAction = 1024/*use if none of the above apply*/end enumbegin enum not output_kTXNClearThisControl = 0xFFFFFFFF_kTXNClearTheseFontFeatures = 0x80000000end enum/*  convenience constants for TXNGet/SetTXNControls   kTXNIOPrivilegesTag*/begin enum not output_kTXNReadWrite = _false_kTXNReadOnly = _trueend enum/* kTXNSelectionStateTag*/begin enum not output_kTXNSelectionOn = _true_kTXNSelectionOff = _falseend enum/* kTXNInlineStateTag*/begin enum not output_kTXNUseInline = _false_kTXNUseBottomline = _trueend enum/* kTXNWordWrapStateTag*/begin enum_kTXNAutoWrap = _false_kTXNNoAutoWrap = _trueend enum/* kTXNKeyboardSyncStateTag*/begin enum not output_kTXNSyncKeyboard = _false_kTXNNoSyncKeyboard = _trueend enum/* kTXNAutoIndentStateTag*/begin enum not output_kTXNAutoIndentOff = _false_kTXNAutoIndentOn = _trueend enum/* kTXNDrawCaretWhenInactiveTag*/begin enum not output_kTXNDontDrawCaretWhenInactive = _false_kTXNDrawCaretWhenInactive = _trueend enum/* kTXNDrawSelectionWhenInactiveTag*/begin enum not output_kTXNDontDrawSelectionWhenInactive = _false_kTXNDrawSelectionWhenInactive = _trueend enum/* kTXNDisableDragAndDropTag*/begin enum not output_kTXNEnableDragAndDrop = _false_kTXNDisableDragAndDrop = _trueend enum#define TXNTabType as SInt8begin enum not output_kTXNRightTab = -1_kTXNLeftTab = 0_kTXNCenterTab = 1end enumbegin record TXNTabdim as SInt16 valuedim as TXNTabType tabTypedim as UInt8 fillerend record begin enum not output_kTXNLeftToRight = 0_kTXNRightToLeft = 1end enumbegin enum not output_kTXNFlushDefault = 0/*flush according to the line direction */_kTXNFlushLeft = 1_kTXNFlushRight = 2_kTXNCenter = 4_kTXNFullJust = 8_kTXNForceFullJust = 16/*flush left for all scripts */end enumbegin record TXNMarginsdim as SInt16 topMargin, leftMargin, bottomMargin, rightMarginend record begin record TXNControlDatabegin union dim as UInt32 uValuedim as SInt32 sValuedim as TXNTab tabValuedim marginsPtr as pointer //to TXNMarginsend union end record #define TXNScrollBarState as Booleanbegin enum not output_kScrollBarsAlwaysActive = _true_kScrollBarsSyncWithFocus = _falseend enum/*  kTXNNoFontVariations is returned in the dataValue field when the caller as asked  to see if the variation is continuous and there was no variation in the continuous range*/begin enum not output_kTXNDontCareTypeSize = 0xFFFFFFFF_kTXNDontCareTypeStyle = 0xFF_kTXNIncrementTypeSize = 0x00000001_kTXNDecrementTypeSize = 0x80000000_kTXNUseScriptDefaultValue = -1_kTXNNoFontVariations = 0x7FFFend enum#define TXNOffset as UInt32begin enum not output_kTXNUseCurrentSelection = 0xFFFFFFFF_kTXNStartOffset = 0_kTXNEndOffset = 0x7FFFFFFFend enumbegin enum not output_kTXNSingleStylePerTextDocumentResType = _"MPSR"_kTXNMultipleStylesPerTextDocumentResType = _"styl"end enum#define TXNObjectRefcon as pointer // to void/*constants for TXNShowSelection*/begin enum not output_kTXNShowStart = _false_kTXNShowEnd = _trueend enum#define TXNErrors as OSStatus/*default constants for TXTNInit.  *///#define kTXNDefaultFontName             ((StringPtr)NULL)_kTXNDefaultFontName = _nilbegin enum not output_kTXNDefaultFontSize = 0x000C0000 // 12 ptend enumbegin enum not output_kTXNDefaultFontStyle = 0 // normalend enum#define TXNHyperLinkState as UInt32begin enum not output_kTXNLinkNotPressed = 0_kTXNLinkWasPressed = 1_kTXNLinkTracking = 3end enum#define TXNTypeRunAttributes as FourCharCodebegin enum not output_kTXNQDFontNameAttribute = _"fntn"_kTXNQDFontFamilyIDAttribute = _"font"_kTXNQDFontSizeAttribute = _"size"_kTXNQDFontStyleAttribute = _"face"_kTXNQDFontColorAttribute = _"klor"_kTXNTextEncodingAttribute = _"encd"_kTXNATSUIFontFeaturesAttribute = _"atfe"_kTXNATSUIFontVariationsAttribute = _"atva"_kTXNURLAttribute = _"urla"end enum/*  kTXNQDFontSizeAttributeSize is obsolete and incorrect  font sizes are always returned as a Fixed value, just as  they are passed to MLTE.  Use kTXNFontSizeAttributeSize.*/#define TXNTypeRunAttributeSizes as ByteCountbegin enum not output_kTXNQDFontNameAttributeSize = sizeof(Str255)_kTXNQDFontFamilyIDAttributeSize = sizeof(SInt16)//_kTXNQDFontSizeAttributeSize = sizeof(SInt16)_kTXNQDFontStyleAttributeSize = sizeof(Style)_kTXNQDFontColorAttributeSize = sizeof(RGBColor)_kTXNTextEncodingAttributeSize = sizeof(TextEncoding)_kTXNFontSizeAttributeSize = sizeof(Fixed)end enum#define TXNPermanentTextEncodingType as UInt32begin enum not output_kTXNSystemDefaultEncoding = 0_kTXNMacOSEncoding = 1_kTXNUnicodeEncoding = 2end enum#define TXTNTag as FourCharCodebegin record TXNATSUIFeaturesdim as ItemCount featureCountdim featureTypes as pointer //to ATSUFontFeatureTypedim featureSelectors as pointer // to ATSUFontFeatureSelectorend record begin record TXNATSUIVariationsdim as ItemCount variationCount dim variationAxis as pointer //to ATSUFontVariationAxisdim variationValues as pointer //to ATSUFontVariationValueend record begin record TXNAttributeDatabegin union dim dataPtr as pointer //to voiddim as UInt32 dataValuedim atsuFeatures as pointer //to TXNATSUIFeaturesdim atsuVariations as pointer //to TXNATSUIVariationsdim as CFURLRef urlReferenceend union end record begin record TXNTypeAttributesdim as TXTNTag tag dim as ByteCount size dim as TXNAttributeData dataend record begin record TXNMacOSPreferredFontDescriptiondim as UInt32 fontIDdim as Fixed pointSizedim as TextEncoding encodingdim as Style fontStyleend record begin record TXNMatchTextRecorddim iTextPtr as pointer //to voiddim as SInt32 iTextToMatchLength dim as TextEncoding iTextEncoding end record /*constants & typedefs for setting the background*/#define TXNBackgroundType as UInt32begin enum not output_kTXNBackgroundTypeRGB = 1end enum/*   The TXNBackgroundData is left as a union so that it can be expanded   in the future to support other background types*/begin record TXNBackgroundDatabegin union dim as RGBColor colorend union end record begin record TXNBackgrounddim as TXNBackgroundType bgType dim as TXNBackgroundData bg end record begin record TXNLongRectdim as SInt32  top, left, bottom, rightend record /*  options for TXNGet/ClearActionChangeCount to decide what type(s) of action   count to use */begin enum not output_kTXNTextInputCountBit = 0_kTXNRunCountBit = 1end enum#define TXNCountOptions as OptionBitsbegin enum not output_kTXNTextInputCountMask = 1 << _kTXNTextInputCountBit_kTXNRunCountMask = 1 << _kTXNRunCountBit_kTXNAllCountMask = _kTXNTextInputCountMask or _kTXNRunCountMaskend enum#define TXNScrollUnit as UInt32begin enum not output_kTXNScrollUnitsInPixels = 0_kTXNScrollUnitsInLines = 1_kTXNScrollUnitsInViewRects = 2end enum#define TXNScrollBarOrientation as UInt32begin enum not output_kTXNHorizontal = 0_kTXNVertical = 1end enum/*typedef CALLBACK_API( OSStatus , TXNFindProcPtr )(const TXNMatchTextRecord *matchData, TXNDataType iDataType, TXNMatchOptions iMatchOptions, const void *iSearchTextPtr, TextEncoding encoding, TXNOffset absStartOffset, ByteCount searchTextLength,ÂTXNOffset *oStartMatch, TXNOffset *oEndMatch, Boolean *ofound, UInt32 refCon);typedef CALLBACK_API( CFStringRef , TXNActionKeyMapperProcPtr )(TXNActionKey actionKey, UInt32 commandID);typedef CALLBACK_API( void , TXNScrollInfoProcPtr )(SInt32 iValue, SInt32 iMaximumValue, TXNScrollBarOrientation iScrollBarOrientation, SInt32 iRefCon);typedef STACK_UPP_TYPE(TXNFindProcPtr)                          TXNFindUPP;typedef STACK_UPP_TYPE(TXNActionKeyMapperProcPtr)               TXNActionKeyMapperUPP;typedef STACK_UPP_TYPE(TXNScrollInfoProcPtr)                    TXNScrollInfoUPP;*//* *  NewTXNFindUPP() *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   available as macro/inline *///toolbox fn NewTXNFindUPP( TXNFindProcPtr userRoutine) = TXNFindUPPtoolbox fn NewTXNFindUPP( proc userRoutine) = proc //TXNFindUPP/* *  NewTXNActionKeyMapperUPP() *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   available as macro/inline *///toolbox fn NewTXNActionKeyMapperUPP( TXNActionKeyMapperProcPtr userRoutine) = TXNActionKeyMapperUPPtoolbox fn NewTXNActionKeyMapperUPP( proc userRoutine) = proc // TXNActionKeyMapperUPP/* *  NewTXNScrollInfoUPP() *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib on Mac OS X *    Non-Carbon CFM:   available as macro/inline *///toolbox fn NewTXNScrollInfoUPP( TXNScrollInfoProcPtr userRoutine) = TXNScrollInfoUPPtoolbox fn NewTXNScrollInfoUPP( proc userRoutine) = proc //TXNScrollInfoUPP/* *  DisposeTXNFindUPP() *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   available as macro/inline *///toolbox DisposeTXNFindUPP( TXNFindUPP userUPP)toolbox DisposeTXNFindUPP( proc userUPP)/* *  DisposeTXNActionKeyMapperUPP() *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   available as macro/inline *///toolbox DisposeTXNActionKeyMapperUPP( TXNActionKeyMapperUPP userUPP)toolbox DisposeTXNActionKeyMapperUPP( proc userUPP)/* *  DisposeTXNScrollInfoUPP() *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib on Mac OS X *    Non-Carbon CFM:   available as macro/inline *///toolbox DisposeTXNScrollInfoUPP( TXNScrollInfoUPP userUPP)toolbox DisposeTXNScrollInfoUPP( proc userUPP)/* *  InvokeTXNFindUPP() *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   available as macro/inline *//*toolbox fn InvokeTXNFindUPP( const TXNMatchTextRecord * matchData, TXNDataType iDataType, TXNMatchOptions iMatchOptions, const void * iSearchTextPtr, TextEncoding encoding, ÂTXNOffset absStartOffset, ByteCount searchTextLength, TXNOffset * oStartMatch,ÂTXNOffset * oEndMatch, Boolean * ofound, UInt32 refCon, TXNFindUPP userUPP) = OSStatus*//* *  InvokeTXNActionKeyMapperUPP() *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   available as macro/inline *///toolbox fn InvokeTXNActionKeyMapperUPP( TXNActionKey actionKey, UInt32 commandID, TXNActionKeyMapperUPP userUPP) = CFStringRef/* *  InvokeTXNScrollInfoUPP() *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib on Mac OS X *    Non-Carbon CFM:   available as macro/inline *///toolbox InvokeTXNScrollInfoUPP( SInt32 iValue, SInt32 iMaximumValue, TXNScrollBarOrientation iScrollBarOrientation, SInt32 iRefCon, TXNScrollInfoUPP userUPP)/*  These are currently the only settings for the flags field of TXNCarbonEventInfo  If you want the AppleEventHandlers removed use kTXNNoAppleEventHandlersMask.  If you want to subsequently restart AppleEvent Handlers after removing  your Texthandlers. Use kTXNRestartAppleEventHandlersMask.*/begin enum not output_kTXNNoAppleEventHandlersBit = 0_kTXNRestartAppleEventHandlersBit = 1end enumbegin enum not output_kTXNNoAppleEventHandlersMask = 1 << _kTXNNoAppleEventHandlersBit_kTXNRestartAppleEventHandlersMask = 1 << _kTXNRestartAppleEventHandlersBitend enum/*dictionary keys currently supported in the TXNCarbonEventInfo dictionary*/' kTXNTextHandlerKey = CFSTR("TextInput") ' kTXNWindowEventHandlerKey = CFSTR("WindowEvent") ' kTXNWindowResizeEventHandlerKey = CFSTR("WindowResize") ' kTXNCommandTargetKey = CFSTR("CommandTarget") ' kTXNCommandUpdateKey = CFSTR("CommandUpdate") ' kTXNFontMenuRefKey = CFSTR("FontMenuRef") ' kTXNFontMenuObjectKey = CFSTR("FontMenuObject") ' kTXNActionKeyMapperKey = CFSTR("ActionKeyMapper") ' kTXNWheelMouseEventHandlerKey = CFSTR("WheelMouseEvent") /* use this to pass an EventTargetRef to MLTE via the TXNSetTXNControl... call*/begin record TXNCarbonEventInfodim as Boolean useCarbonEventsdim as UInt8 fillerdim as UInt16 flagsdim as CFDictionaryRef fDictionaryend record /*  *****************************************************************************************************   Allocates a new frame (i.e. new is called to allocate a TXNObject) and returns a pointer to the object    in the newDoc parameter.   Input:            iFileSpec:  If not NULL the file is read to obtain the document contents  after the object is                 successfully allocated.  If NULL you start with an empty document.                    iWindow:        Required.  The window in which the document is going to be  displayed.                    iFrame:     If text-area does not fill the entire window.  This specifies the area to fill.  Can be NULL.                  In  which case, the windowÕs portRect is used as the frame.                                    iFrameOptions:  Specify the options to be supported by this frame.  The available options are support                     for cutting and pasting  movies and sound, handle scrollbars and handle grow box in  the                     frame.    iFrameType:     Specify the type of frame to be used.  In MLTE version 1.1 and earlier, only                     kTXNTextEditStyleFrameType is supported.       iFileType:  Specify the primary file type.  If you  use  kTextensionTextFile files will be saved                 in a private format (see xxx).  If you  want saved files to be plain text files you should                 specify `TEXT` here. If you specify `TEXT` here you can use the frameOptions parameter to                 specify  whether the TEXT files should be saved  with `MPSR` resources or `styl` resources.                  These are resources which contain style information for a  file, and they  both have there                 own limitations.  If you use `styl` resources to save style info your documents can have as                 many styles as you like however tabs will not be saved.  If you use `MPSR` resources only the                 first style in the document  will be saved (you as client are expected to apply all style                  changes to the entire document).  If you  truly want  rich documents which can potentially                 contain graphics and sound you should specify kTextensionTextFileOutput.  If you want a plain                 text editor like SimpleText specify that style information by saved via ÔstylÕ resources.                  If you want files similar to those output by CW IDE, BBEdit, and MPW specify that style                 information be saved in a ÔMPSRÕ resource.      Output:        OSStatus:   function  result.  If anything goes wrong the error is returned.  Success must be complete.                  That is if everything  works, but there is a failure reading a specified file the  object                 is freed.    oTXNObject:     Pointer to the opaque datastructure allocated by the function.  Most of the subsequent                     functions require that such a pointer be passed in.                    oTXNFrameID:    Unique ID for the frame. <Note in version 1.0 this value is always set to 0>    iRefCon:        Caller can set this to any value.  It is retained by the                    TXNNewObject which can later be asked to return it.  ***************************************************************************************************************//* *  TXNNewObject() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNNewObject( const FSSpec * iFileSpec, WindowRef iWindow, const Rect * iFrame, TXNFrameOptions iFrameOptions, TXNFrameType iFrameType, TXNFileType iFileType, TXNPermanentTextEncodingType iPermanentEncoding, TXNObject * oTXNObject,ÂTXNFrameID * oTXNFrameID, TXNObjectRefcon iRefCon) = OSStatus/* can be NULL *//* can be NULL *//*  *************************************************************************************************   Delete a previously allocated TXNObject and all associated data structures.  If the frameType is    multiple frames all frames are released.           Input:    iTXNObject: opaque structure to free.  ***************************************************************************************************//* *  TXNDeleteObject() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNDeleteObject( TXNObject iTXNObject)/*  *************************************************************************************************                            Changes the frame`s size to match the new width and height.   Input:        iTXNObject:     opaque Textension structure.        iWidth:         New width in pixels.        iHeight:        New height in pixels.        iTXNFrameID:    FrameID that specifies the frame to move.  **************************************************************************************************//* *  TXNResizeFrame() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNResizeFrame( TXNObject iTXNObject, UInt32 iWidth, UInt32 iHeight, TXNFrameID iTXNFrameID)/*  *************************************************************************************************                            Changes the frame`s bounds to match the Rect.    Input:        iTXNObject :                                opaque Textension structure.                (iTop, iLeft, iBottom, iRight):     Rect of the view                 iTXNFrameID:        FrameID that specifies the frame to move.  **************************************************************************************************//* *  TXNSetFrameBounds() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNSetFrameBounds( TXNObject iTXNObject, SInt32 iTop, SInt32 iLeft, SInt32 iBottom, SInt32 iRight, TXNFrameID iTXNFrameID)/*  ****************************************************************************************************    Initialize the Textension library.  Should be called as soon as possible after the Macintosh toolbox    is initialized.   Input:    iDefaultFonts:      A table of font information including fontFamily ID, point size,                        style, and script code. The table can be NULL or can have                        an entry for any script for which you would like to to                        designate a default font.  Only a valid script number is                        required.  You can designate that Textension should use                        the default for a give script by setting the field to kTXNUseScriptDefaultValue (-1).                                               For example, if you wanted to specify New York as the default   font to use for Roman scripts, but were happy with the    default style and size you would call the function like this:        TXNMacOSPreferredFontDescription    defaults;    GetFNum( "\pNew York", &defaults.fontFamilyID );    defaults.pointSize = kTXNDefaultFontSize;    defaults.fontStyle = kTXNDefaultFontStyle;    defaults.script = smRoman;    status = TXNInitTextension( &defaults, 1, 0 );    iCountDefaultFonts: Count of entries in the iDefaultFonts parameter.                                                        iUsageFlags:        Specify whether sound and movies should be supported.   Output:    OSStatus:       Function result.  NoErr if everything initialized correctly.  Variety of                    possible MacOS errors if something goes wrong.  *********************************************************************************************|*//* *  TXNInitTextension() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNInitTextension( const TXNMacOSPreferredFontDescription iDefaultFonts[], ItemCount iCountDefaultFonts, TXNInitOptions iUsageFlags) = OSStatus/* can be NULL */toolbox fn TXNInitTextension( pointer, ItemCount iCountDefaultFonts, TXNInitOptions iUsageFlags) = OSStatus/* can be NULL *//*  *************************************************************************************   Close the Textension library.  It is necessary to call this function so that Textension    can correctly close down any TSM connections and do other clean up.  ***************************************************************************************//* *  TXNTerminateTextension() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNTerminateTextension( )/*  **************************************************************************************    Process a keydown event. Note that if CJK script is installed and current font is     CJK inline input will take place. This is always the case unless the application has     requested the bottomline window or has turned off TSM (see initialization options above).           Input:        iTXNObject:     opaque struct to apply keydown to.                    iEvent:     the keydown event.    ****************************************************************************************//* *  TXNKeyDown() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNKeyDown( TXNObject iTXNObject, const EventRecord * iEvent)/*  ***************************************************************************************    Handle switching the cursor.  If over text area set to i-beam.  Over graphics, sound,    movie, scrollbar or outside of window set to arrow.        Input:        iTXNObject:         Opaque struct obtained from TXNNewObject.        ioCursorRgn:        Region to be passed to WaitNextEvent.  Resized  accordingly by                         TXNAdjustCursor.  ****************************************************************************************//* *  TXNAdjustCursor() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNAdjustCursor( TXNObject iTXNObject, RgnHandle ioCursorRgn)/*  ****************************************************************************************                          Process click in content region.  Takes care of scrolling, selecting text,  playing     sound and movies, drag & drop, and double-clicks.    Input:        iTXNObject:     Opaque struct obtained from TXNNewObject.        iEvent:     the mousedown event  ******************************************************************************************//* *  TXNClick() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNClick( TXNObject iTXNObject, const EventRecord * iEvent)/*  ********************************************************************************************        Call this when WaitNextEvent returns false or there is no active TSNObject .     The TXNObject parameter can be NULL which allows a client to call this function at any     time.  This is necessary to insure input methods enough time to be reasonably responsive.    NOTE : You do not need to call this when working on Carbon, TSM events are passed directly           to the text object.    Input:        iTXNObject:         The currently active TXNObject or NULL.        ioEvent:            The event record.  Usually a NULL event.  If the                             event is not an NULL event on entry, and an input                            method consumes the event the event should return                            as a NULL event.    Output:        Boolean:        True if TSM handled this event.  False if TSM did not handle this event.  ***********************************************************************************************//* *  TXNTSMCheck() *   *  Availability: *    Mac OS X:         not available *    CarbonLib:        not available *    Non-Carbon CFM:   in Textension 1.0 and later *//*  ***********************************************************************************************                           Selects everything in a frame.    Input:        iTXNObject: opaque TXNObject   ***********************************************************************************************   *//* *  TXNSelectAll() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNSelectAll( TXNObject iTXNObject)/*  ***********************************************************************************************                           Focues the TXNObject.  Scrollbars and insertion point are made active  if iBecomingFocused    is true, and inactive if false.        Input:        iTXNObject:         opaque TXNObject                iBecomingFocused:   true if becoming active.  false otherwise.  ************************************************************************************************  *//* *  TXNFocus() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNFocus( TXNObject iTXNObject, Boolean iBecomingFocused)/*  ************************************************************************************************                          Handle update event (i.e. draw everything in a frame.) This function calls the Toolbox    BeginUpdate - EndUpdate functions for the window that was passed to TXNNewObject.  This    makes it inappropriate for windows that contain something else besides the TXNObject.    Input:        iTXNObject: opaque TXNObject   *************************************************************************************************//* *  TXNUpdate() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNUpdate( TXNObject iTXNObject)/*  *************************************************************************************************    Redraw the TXNObject including any scrollbars associated with the text frame.  Call this function    in response to an update event for a window that contains multiple TXNObjects or some other graphic    element.  The caller is responsible for calling BeginUpdate/EndUpdate in response to the update    event.    Input:        iTXNObject:     opaque TXNObject to draw        iDrawPort:  Can be NULL. If NULL the port is drawn to the port currently attached to the                     iTXNObject.  If not NULL drawing goes to the iDrawPort.  If drawing is done                    to the iDrawPort selection is not updated.  This works this way so that it                    is possible to Draw a TXNObject to a static port (i.e. print the thing without                     reflowing the text to match the paper size which is what TXNPrint does)                     and not have a line drawn where the selection would be.  If you pass an                     iDrawPort to an active TXNObject (i.e. editable) the selection will not be updated. In                     this case the selection will behave oddly until text is typed which will serve                    to realign the selection.  Bottom-line don`t pass a port in unless you want                    static text (printed or non-editable)  **************************************************************************************************//* *  TXNDraw() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox TXNDraw( TXNObject iTXNObject, GWorldPtr iDrawPort)/* can be NULL */toolbox TXNDraw( TXNObject iTXNObject, pointer iDrawPort)/* can be NULL *//*  *************************************************************************************************    Force a frame to be updated.  Very much like toolbox call InvalRect.        Input:        iTXNObject: opaque TXNObject   **************************************************************************************************                        *//* *  TXNForceUpdate() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNForceUpdate( TXNObject iTXNObject)/*  **************************************************************************************************    Depending on state of window get the appropriate sleep time to be passed to WaitNextEvent.    Input:        iTXNObject: opaque TXNObject obtained from TXNNewObject            Output:            UInt32: function result appropriate sleep time.  ****************************************************************************************************//* *  TXNGetSleepTicks() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNGetSleepTicks( TXNObject iTXNObject) = UInt32/*  ***************************************************************************************************    Do necessary Idle time processing. Typically flash the cursor. If a TextService is active    pass a NULL event to the Text Service so it gets  time.    Input:        iTXNObject: opaque TXNObject obtained from TXNNewObject  *****************************************************************************************************//* *  TXNIdle() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNIdle( TXNObject iTXNObject)/*  *********************************************************************************************************    Handle mouse-down in grow region.     Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject        iEvent:     The mousedown event  **********************************************************************************************************//* *  TXNGrowWindow() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNGrowWindow( TXNObject iTXNObject, const EventRecord * iEvent)/*  ********************************************************************************************************    Handle mousedown in zoom.    Input:        iTXNObject:     opaque TXNObject obtained from  TXNNewObject        iPart:      Value returned by FindWindow  **********************************************************************************************************//* *  TXNZoomWindow() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNZoomWindow( TXNObject iTXNObject, SInt16 iPart)/*  *******************************************************************************************************    Use this to determine if the Undo item in Edit menu should be highlighted or not.  Tells you if last    command was undoable.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject    Output:        Boolean     function result.  If True the last command is undoable and the undo item in the menu                     should be active.  If false last command cannot be undone and undo should be grayed                     in the menu.        oTXNActionKey The key code that the caller can use to pick a string to describe the undoable                      action in the undo item.  Pass in NULL if the string isn`t needed.  **********************************************************************************************************//* *  TXNCanUndo() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNCanUndo( TXNObject iTXNObject, TXNActionKey * oTXNActionKey) = Boolean/* can be NULL *//*  ********************************************************************************************************    Undo the last command.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject  **********************************************************************************************************//* *  TXNUndo() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNUndo( TXNObject iTXNObject)/*  *********************************************************************************************************    Use this to determine if the current item on the undo stack is redoable.  If it returns true.    than the redo item in the edit menu should be active.        Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject.        oTXNActionKey The key code that the caller can use to pick a string to describe the redoable                      action in the redo item.  Pass in NULL if the string isn`t needed.*//***********************************************************************************************************//* *  TXNCanRedo() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNCanRedo( TXNObject iTXNObject, TXNActionKey * oTXNActionKey) = Boolean/* can be NULL *//*  ********************************************************************************************************    Redo the last command.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject  **********************************************************************************************************//* *  TXNRedo() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNRedo( TXNObject iTXNObject)/*  *********************************************************************************************************    Cut the current selection to the clipboard.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject    Output:        OSStatus:   function result.  Variety of memory or scrap MacOS errors.  ***********************************************************************************************************//* *  TXNCut() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNCut( TXNObject iTXNObject) = OSStatus/*  *********************************************************************************************************    TXNCopy        Copy current selection       Input:        iTXNObject:         current document                      **********************************************************************************************************                        *//* *  TXNCopy() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNCopy( TXNObject iTXNObject) = OSStatus/*  ***********************************************************************************************************    TXNPaste        Paste the clipboard       Input:        iTXNObject:         current document                      ***********************************************************************************************************//* *  TXNPaste() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNPaste( TXNObject iTXNObject) = OSStatus/*  **********************************************************************************************************    TXNClear        clear the current selection       Input:        iTXNObject:         current document                      ***********************************************************************************************************//* *  TXNClear() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNClear( TXNObject iTXNObject) = OSStatus/*  *********************************************************************************************************    TXNGetSelection        Get the absolute offsets of the current selection.          Embedded graphics, sound, etc. each count as one character.       Input:        iTXNObject:         current document        Output:        oStartOffset:   absolute beginning of the current selection.        oEndOffset:     end of current selection.  *********************************************************************************************************                     *//* *  TXNGetSelection() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNGetSelection( TXNObject iTXNObject, TXNOffset * oStartOffset, TXNOffset * oEndOffset)/*  *****************************************************************************************************    Scroll the current selection into view.    Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject        iShowEnd:   If true the end of the selection is scrolled into view. If false the                    beginning of selection is scrolled into view.  ****************************************************************************************************                      *//* *  TXNShowSelection() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNShowSelection( TXNObject iTXNObject, Boolean iShowEnd)/*  *****************************************************************************************************    Call to find out if the current selection is empty. Use this to determine if Paste, Cut, Copy,     Clear should be highlighted in Edit menu.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject    Output:        Boolean:    function result.  True if current selection is empty (i.e. start offset == end offset).                      False if selection is not empty.  *********************************************************************************************************//* *  TXNIsSelectionEmpty() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNIsSelectionEmpty( TXNObject iTXNObject) = Boolean/*  ********************************************************************************************************    Set the current selection.        Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject        iStartOffset:   new beginning        iEndOffset:     new end  *********************************************************************************************************//* *  TXNSetSelection() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNSetSelection( TXNObject iTXNObject, TXNOffset iStartOffset, TXNOffset iEndOffset) = OSStatus/*  *******************************************************************************************************    TXNGetContinuousTypeAttributes        Test the current selection to see if type size, style, color and/or font are continuous.         That is is the current selection made up of one font, one font size, one Style, and/or one color.          On return examine the flags to see if the attributes specified were continuous.  If an attribute        is continuous then the dataValue field in the TXNTypeAttributes can be examined to get the continous        value.  Remember that for color you pass a ptr to an RGBColor in attr[0].data.dataPtr.    Input:        iTXNObject:             current document        oContinuousFlags:   Bits which can be examined to see if type size, style, color, and/or font are continuous                                                        e.g                             if (  TXNGetContinuousTypeAttributes( txnObject, &flags, 1, &attr ) == noErr )                            {                                    if ( flags & kTXNFontContinuousMask )                                        ....check a font name        ioCount:            Count of TXNTypeAttributes records in the ioTypeAttributes array.        ioTypeAttributes:   Array of TXNTypeAttributes that indicate the type attributes the                            caller is interested in.  For example, if you wanted to know if                            the current selection was continuous in terms of being all                            one same font size you could do something like this.                                                        TXNTypeAttributes       attr[1] = { TXNFontSizeAttribute, sizeof(Fixed),{ 0 } }                                                        on return  from the function if size is continuous (i.e. if the bit 3 of flags is set)                            then the third field (attr[0].data.dataValue) will contain the size of the font as a Fixed value.                                      ************************************************************************************************************//* *  TXNGetContinuousTypeAttributes() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNGetContinuousTypeAttributes( TXNObject iTxnObject, TXNContinuousFlags * oContinuousFlags, ItemCount iCount, TXNTypeAttributes ioTypeAttributes[]) = OSStatus/* can be NULL */toolbox fn TXNGetContinuousTypeAttributes( TXNObject iTxnObject, TXNContinuousFlags * oContinuousFlags, ItemCount iCount, pointer ) = OSStatus/* can be NULL *//*  *************************************************************************************************    TXNSetTypeAttributes        Set the current ranges font information.  Values are passed        in the attributes array.  Values <= sizeof(UInt32) are passed        by value. > sizeof(UInt32) are passed as a pointer.  That is        the TXNTypeAttributes` 3rd field is a union that servers as        either a 32-bit integer where values can be written or a 32-bit pointer         a value.    Input:        iTXNObject:         current document        iAttrCount:     Count of type attributes in the TXNTypeAttributes array.        iAttributes:    Attributes that caller would like to set.        iStartOffset:   Start of the range where text attributes should be changed.        iEndOffset:     End of the range.        Output:        OSStatus:           various MacOS  errs.  Notably memory manager and paramErrs.                           *************************************************************************************************                         *//* *  TXNSetTypeAttributes() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNSetTypeAttributes( TXNObject iTXNObject, ItemCount iAttrCount, const TXNTypeAttributes iAttributes[], TXNOffset iStartOffset, TXNOffset iEndOffset) = OSStatustoolbox fn TXNSetTypeAttributes( TXNObject iTXNObject, ItemCount iAttrCount, pointer, TXNOffset iStartOffset, TXNOffset iEndOffset) = OSStatus/* *  TXNSetTXNObjectControls() *   *  Summary: *    Sets formatting and privileges attributes (such as justification, *    line direction, tab values, and read-only status) that apply to *    the entire text object. *   *  Discussion: *    On systems that use Apple Type Services for Unicode Imaging *    (ATSUI), the ATSUI line control attribute tags can be passed to *    this function in the iControlTag parameter. This is the case for *    all the ATSUI tags except kATSULineRotationTag. ATSUI tags are *    applied to the entire text object. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      The text object that identifies the document for which you want *      to set formatting and privileges attributes. *     *    iClearAll: *      A Boolean value. If you set this to true, all formatting and *      privileges attributes are reset to their default value. That *      is, true clears existing tags and resets each to its default *      value. *     *    iControlCount: *      The number of items in the iControlTags array. *     *    iControlTags: *      An array of values that specifies kind of data that is passed *      in the iControlData parameter. See ÒFormatting and Privileges *      SettingsÓ for a description of possible values. On systems that *      use Apple Type Services for Unicode Imaging (ATSUI), you can *      also pass ATSUI attribute tag constants. See the ATSUI *      documentation for a description of the ATSUI constants. Can be *      NULL if iClearAll is true. *     *    iControlData: *      An array of TXNControlData unions that contain the information *      your application wants to set. The value you supply to the *      iControlTags parameter specifies how the union of type *      TXNControlData is treated. You must make sure that the value *      you assign to the iControlData parameter is the appropriate *      type implied by the value you passed in the iControlTags *      parameter. Can be NULL if iClearAll is true. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNSetTXNObjectControls( TXNObject iTXNObject, Boolean iClearAll, ItemCount iControlCount, const TXNControlTag iControlTags[], const TXNControlData iControlData[]) = OSStatus/* can be NULL */toolbox fn TXNSetTXNObjectControls( TXNObject iTXNObject, Boolean iClearAll, ItemCount iControlCount, pointer, pointer) = OSStatus/* can be NULL *//* can be NULL *//* *  TXNGetTXNObjectControls() *   *  Summary: *    Gets the current formatting and privileges attributes (such as *    justification, line direction, tab values, and read-only status) *    for a text object. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      The text object that identifies the document to be activated. *     *    iControlCount: *      The number of items in the iControlTags array. *     *    iControlTags: *      An array of values that specify the kind of formatting *      information you want returned in the oControlData array. See *      ÒFormatting and Privileges SettingsÓ for a description of *      possible values. *     *    oControlData: *      An array of TXNControlData unions. On return, the array *      contains the information that was requested through the *      iControlTags array. Your application must allocate the *      oControlData array. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNGetTXNObjectControls( TXNObject iTXNObject, ItemCount iControlCount, const TXNControlTag iControlTags[], TXNControlData oControlData[]) = OSStatus/* can be NULL */toolbox fn TXNGetTXNObjectControls( TXNObject iTXNObject, ItemCount iControlCount, pointer, pointer ) = OSStatus/* can be NULL *//*  ******************************************************************************************************    TXNCountRunsInRange        Given a range specified by the starting and ending offset return a count of the runs in that        range.  Run in this case means changes in TextSyles or a graphic or sound.        Result:            OSStatus:       paramerr mostly        Input:            iTXNObject          The TXNObject you are interested in.            iStartOffset        start of range            iEndOffset          end of range                Output:            oRunCount           count of runs in the range  ********************************************************************************************************//* *  TXNCountRunsInRange() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNCountRunsInRange( TXNObject iTXNObject, TXNOffset iStartOffset, TXNOffset iEndOffset, ItemCount * oRunCount) = OSStatus/* *  TXNGetIndexedRunInfoFromRange() *   *  Summary: *    Gets information about a run in a range of data. *   *  Discussion: *    You should first call the TXNCountRunsInRange function to get the *    count. The TXNTypeAttributes structure must specify the text *    attribute in which the application is interested. In other words, *    the tag field must be set. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      The text object for the current text area. *     *    iIndex: *      The value that corresponds to the run for which you want to get *      information. You call the TXNCountRunsInRange function to get *      the number of runs in a range. The iIndex parameter is *      zero-based, so its possible values are from 0 to the number of *      runs in a range minus 1. *     *    iStartOffset: *      The offset at which you want to start to obtain run information. *     *    iEndOffset: *      The offset at which you want run information to end. *     *    oRunStartOffset: *      On return, a pointer to a value that identifies the start of *      run relative to the beginning of the text, not the beginning of *      the range you specified in the iStartOffset parameter. *     *    oRunEndOffset: *      On return, a pointer to a value that identifies the end of the *      run relative to the beginning of the text, not the beginning of *      the range you specified in the iStartOffset parameter. *     *    oRunDataType: *      On return, a pointer to a value that identifies the type of *      data in the run. See ÒSupported Data TypesÓ for a description *      of possible values. *     *    iTypeAttributeCount: *      The number of font attributes. *     *    ioTypeAttributes: *      A pointer to a structure of type TXNTypeAttributes. On input, *      you specify the attribute (such as color) in the tag field and *      the attribute size in the size field. You can pass NULL for the *      data field. On return, the data field contains the attribute *      data. The data field is a union that serves either as a 32-bit *      integer or a 32-bit pointer, depending on the size field. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNGetIndexedRunInfoFromRange( TXNObject iTXNObject, ItemCount iIndex, TXNOffset iStartOffset, TXNOffset iEndOffset, TXNOffset * oRunStartOffset, TXNOffset * oRunEndOffset, TXNDataType * oRunDataType, ItemCount iTypeAttributeCount,ÂTXNTypeAttributes * ioTypeAttributes) = OSStatus/* can be NULL *//* can be NULL *//* can be NULL *//* can be NULL *//*  **********************************************************************************************************    TXNDataSize    Return the size in bytes of the characters in a given TXNObject.    Result:        ByteCount:          The bytes required to hold the characters    Input:        iTXNObject:         The TXNObject      ***********************************************************************************************************//* *  TXNDataSize() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNDataSize( TXNObject iTXNObject) = ByteCount/*  ***********************************************************************************************************    Copy the data in the range specified by startOffset and endOffset. This function should be used    in conjunction with TXNNextDataRun.  The client would call TXNCountRunsInRange to the number of data    runs in a given range.  The client can then walk the runs with the function TXNGetIndexedRunInfoFromRange.    TXNGetIndexedRunInfoFromRange lets you examine each runs type and text attributes.      For each data run of interest (i.e. one whose data the caller wanted to look at)     the client would call TXNGetData. The handle passed to TXNGetData should not be allocated.      TXNGetData takes care of allocating the dataHandle as necessary.  However, the caller is  responsible     for disposing the handle.      No effort is made to insure that data copies align on a word boundary.  Data is simply copied as    specified in the offsets.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject.        iStartOffset:   absolute offset from which data copy should begin.        iEndOffset: absolute offset at which data copy should end.                            Output:        OSStatus    Memory errors or  TXN_IllegalToCrossDataBoundaries if offsets specify a range that                     crosses a data type boundary.        oDataHandle: If noErr a new handle containing the requested data. The caller is responsible                     for disposing the handle.  Note that the handle is a copy so it can be safely                     disposed at any time.  ***********************************************************************************************************//* *  TXNGetData() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNGetData( TXNObject iTXNObject, TXNOffset iStartOffset, TXNOffset iEndOffset, Handle *oDataHandle ) = OSStatus/*  ***********************************************************************************************************    Copy the data in the range specified by startOffset and endOffset.     The handle passed to TXNGetDataEncoded should not be allocated.      TXNGetData takes care of allocating the dataHandle as necessary.  However, the caller is  responsible     for disposing the handle.      No effort is made to insure that data copies align on a word boundary.  Data is simply copied as    specified in the offsets.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject.        iStartOffset:   absolute offset from which data copy should begin.        iEndOffset: absolute offset at which data copy should end.        iEncoding : should be kTXNTextData or kTXNUnicodeTextData                   Output:        OSStatus    Memory errors or  TXN_IllegalToCrossDataBoundaries if offsets specify a range that                 crosses a data type boundary.        oDataHandle:        If noErr a new handle containing the requested data.  ***********************************************************************************************************//* *  TXNGetDataEncoded() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNGetDataEncoded( TXNObject iTXNObject, TXNOffset iStartOffset, TXNOffset iEndOffset, Handle *oDataHandle, TXNDataType iEncoding) = OSStatus/*  *********************************************************************************************************    Replace the specified range with the contents of the specified file.  The data fork of the file     must be opened by the caller.    Input:        iTXNObject:     opaque TXNObject obtained from  TXNNewObject        fileSpec:   HFS file reference obtained when file is opened.        fileType:   files type.        iFileLength: The length of data in the file that should be considered data.  This                     parameter is available to enable callers to embed text inside their                     own private data structures.  Note that if the data is in the Textension(txtn)                     format this parameter is ignored since length, etc. information is                     part of the format. Further note that if you you just want Textension                     to read a file and you are not interested in embedding you can just pass                     kTXNEndOffset(0x7FFFFFFF), and Textension will use the file manager to                     determine the files length.        iStartOffset:   start position at which to insert the file into the document.        iEndOffset:     end position of range being replaced by the file.    Output:        OSStatus:   File manager error or noErr.  ************************************************************************************************************//* *  TXNSetDataFromFile() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNSetDataFromFile( TXNObject iTXNObject, SInt16 iFileRefNum, OSType iFileType, ByteCount iFileLength, TXNOffset iStartOffset, TXNOffset iEndOffset) = OSStatus/* *  TXNSetData() *   *  Summary: *    Replaces a range of data (text, graphics, and so forth). *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      The text object that identifies the document in which you want *      to replace data. *     *    iDataType: *      The type of the replacement data. See ÒSupported Data TypesÓ *      for a description of possible values. *     *    iDataPtr: *      A pointer to the data that will replace the data that is in the *      range specified by the iStartOffset and iEndOffset parameters.  *      Can be NULL if the start and end offsets are different. *     *    iDataSize: *      The size of the data to which iDataPtr points. *     *    iStartOffset: *      The beginning of the range of data to replace. You can use the *      TXNGetSelection function to get the absolute offsets of the *      current selection. *     *    iEndOffset: *      The end of the range to replace. You can use the *      TXNGetSelection function to get the absolute offsets of the *      current selection. If you want to insert text, the ending and *      starting offsets should be the same value. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNSetData( TXNObject iTXNObject, TXNDataType iDataType,  pointer iDataPtr, ByteCount iDataSize, TXNOffset iStartOffset, TXNOffset iEndOffset) = OSStatus/* can be NULL *//*  ************************************************************************************************************                              Retrieve number of times document has been changed.  That is for every committed command     (keydown, cut, copy) the value returned is count of those. This is useful for deciding if  the Save     item in the File menu should be active.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject                                Output:        ItemCount:  count of changes.  This is total changes since document  was created or last saved.                      Not count since this routine was last called or anything like that.  ************************************************************************************************************//* *  TXNGetChangeCount() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNGetChangeCount( TXNObject iTXNObject) = ItemCount/*  *********************************************************************************************************    Save the contents of the document as the given type.     Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iType:              The type of file to create.        iResType:           When saving file as plain TEXT the type of resource to                            save style information.  Use kTXNMultipleStylesPerTextDocumentResType                            if your document contains multiple styles and you want a SimpleText                            like document.  Use kTXNSingleStylePerTextDocumentResType if the                             document has a single style and you would like a BBEdit, MPW, CW type                            of document.        iPermanentEncoding: The encoding in which the document should be saved (Unicode, Text or System                            default).        iFileSpecification:  The file specification to which the document should be saved. The                             file must have been opened by the caller.  The file specification is remembered by the TXNObject                             and is used for any subsequent calls to TXNRevert.        iDataReference:     The data fork ref num.  This is used to write data to the data fork of the                            file. The data is written beginning at the current mark.          iResourceReference: The resource fork ref num.  If the caller has specified that style information be                            saved as a resource (MPW or SimpleText) than this should be a valid reference to                            an open resource fork.  If the txtn format is being used than this input value                            is ignored.    Output:        OSStatus        The result of writing the file.  **********************************************************************************************************    *//* *  TXNSave() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNSave( TXNObject iTXNObject, TXNFileType iType, OSType iResType, TXNPermanentTextEncodingType iPermanentEncoding, const FSSpec * iFileSpecification, SInt16 iDataReference, SInt16 iResourceReference)Â= OSStatus/*  ***********************************************************************************************************    Revert  to the last saved version of this document.  If the file was not previously saved the document    is reverted to an empty document.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject    Output:        OSStatus:   File manager errors, paramErr, or noErr.  **********************************************************************************************************                    *//* *  TXNRevert() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNRevert( TXNObject iTXNObject) = OSStatus/*  *********************************************************************************************************                     Display the Page Setup dialog of the current default printer and react to any changes     (i.e. Reformat the text if the page layout changes.)    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject.        Output:        OSStatus:   Print Manager errors, paramErr, noErr.  ***********************************************************************************************************//* *  TXNPageSetup() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNPageSetup( TXNObject iTXNObject) = OSStatus/*  **********************************************************************************************************    Print the document.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject.    Output:        OSStatus:   Print Manager errors, paramErr, noErr.  ***********************************************************************************************************//* *  TXNPrint() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNPrint( TXNObject iTXNObject) = OSStatus/*  ***********************************************************************************************************                               Test to see if the current scrap contains data that is supported by Textension.  Used to determine    if Paste item in Edit menu should be active or inactive. The types of data supported depends on what     data types were specified in the TXNInitTextension options.    Output:        Boolean:        function result.  True if data type in Clipboard is supported.  False if                         not a supported data type.  If result is True the Paste item in the menu can                         be highlighted.  ***********************************************************************************************************//* *  TXNIsScrapPastable() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNIsScrapPastable( ) = Boolean/*  ***********************************************************************************************************    Convert the Textension private scrap to the public clipboard.  This should be called on suspend     events and before the application displays a dialog that might support cut and paste.  Or more     generally, whenever someone other than the Textension Shared Library needs access to the scrap data.    Output:         OSStatus:  Function result.  Memory Manager errors, Scrap Manager errors, noErr.  *************************************************************************************************************//* *  TXNConvertToPublicScrap() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNConvertToPublicScrap( ) = OSStatus/*  ***********************************************************************************************************    Convert the  public clipboard to our private scrap .  This should be called on resume     events and after an application has modified the scrap. Before doing work we check the validity of the public     scrap (date modification and type)    Output:         OSStatus:  Function result.  Memory Manager errors, Scrap Manager errors, noErr.  ************************************************************************************************************  *//* *  TXNConvertFromPublicScrap() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNConvertFromPublicScrap( ) = OSStatus/*  ************************************************************************************************************    Get the  rectangle describing the current view into the document. The coordinates of this rectangle will be     local to the the window.    Input:        iTXNObject:     opaque TXNObject obtained from TXNNewObject.    Output:        oViewRect:      the requested view rectangle.  **************************************************************************************************************//* *  TXNGetViewRect() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox TXNGetViewRect( TXNObject iTXNObject, Rect * oViewRect)/*  !! TXNSetViewRect is now deprecated for 10.2 and later.  Please use TXNSetFrameBounds or TXNSetRectBounds API !!  *************************************************************************************************                            Set the rectangle describing the current view into the document. This   will change how much text is viewable.  Not where a line of text wraps.   That is controlled by TXNSetFrameBoundsSize.   Input:        iTXNObject :    opaque Textension structure.                iViewRect:      Rect of the view               **************************************************************************************************//* *  TXNSetViewRect() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   in Textension 1.3 and later */toolbox TXNSetViewRect( TXNObject iTXNObject, const Rect * iViewRect)/*  ***********************************************************************************************************    Find a piece of text or a graphics object.    Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iMatchTextDataPtr   ptr to a MatchTextRecord which contains the text to match, the length of that text                            and the TextEncoding the text is encoded in.  This must be there if you are looking                            for Text, but can be NULL if you are looking for a graphics object.        iDataType           The type of data to find.  This can be any of the types defined in TXNDataType enum                            (TEXT, PICT, moov, snd ).  However, if PICT, moov, or snd is passed then the default                            behavior is to match on any non-Text object.  If you really want to find a specific                            type you can provide a custom find callback or ignore matches which aren`t the precise                            type you are interested in.        iStartSearchOffset  The offset at which a search should begin. The constant kTXNStartOffset specifies the start                            of the objects data.        iEndSearchOffset    The offset at which the search should end. The constant kTXNEndOffset specifies the end                            of the objects data.        iFindProc           A custom callback.  If will be called to match things rather than the default matching                            behavior.        iRefCon             This can be use for whatever the caller likes.  It is passed to the FindProc (if a FindProc                            is provided.    Output:        oStartMatchOffset   absolute offset to start of match.  set to 0xFFFFFFFF if not match.        oEndMatchOffset     absolute offset to end of match.  Set to 0xFFFFFFFF is no match.    The default matching behavior is pretty simple for Text a basic binary compare is done.  If the matchOptions say     to ignore case the characters to be searched are duplicated and case neutralized.  This naturally can fail due    to lack of memory if there is a large amount of text.  It also slows things down.  If MatchOptions say    find an entire word that once a match is found an effort is made to determine if the match is a word.  The default    behavior is to test the character before and after the to see if it is White space.  If the kTXNUseEncodingWordRulesBit    is set than the Script Manager`s FindWord function is called to make this determination.    If the caller is looking for a non-text type than each non-text type in the document is returned.    If more elaborate ( a regular expression processor or whatever ) is what you want then that is what the FindProc is    for.  ********************************************************************************************************************//* *  TXNFind() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNFind( TXNObject iTXNObject, const TXNMatchTextRecord * iMatchTextDataPtr, TXNDataType iDataType, TXNMatchOptions iMatchOptions, TXNOffset iStartSearchOffset, TXNOffset iEndSearchOffset, proc iFindProc,Â SInt32 iRefCon, TXNOffsetÂ* oStartMatchOffset, TXNOffset * oEndMatchOffset) = OSStatus/* can be NULL *//*  ***************************************************************************************************************   TXNSetFontDefaults       For a given TXNObject specify the font defaults for each script.   Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iCount:             count of FontDescriptions.        iFontDefaults:      array of FontDescriptions.   Output:        OSStatus:           function result ( memory error, paramErr )  *****************************************************************************************************************//* *  TXNSetFontDefaults() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNSetFontDefaults( TXNObject iTXNObject, ItemCount iCount, const TXNMacOSPreferredFontDescription iFontDefaults[]) = OSStatustoolbox fn TXNSetFontDefaults( TXNObject iTXNObject, ItemCount iCount, pointer ) = OSStatus/*  ***************************************************************************************************************   TXNGetFontDefaults       For a given TXNObject make a copy of the font defaults.   Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iCount:             count of FontDescriptions in the array.        iFontDefaults:      array of FontDescriptins to be filled out.   Output:        OSStatus:           function result ( memory error, paramErr )    To determine how many font descriptions need to be in the array you should call this function with    a NULL for the array.  iCount will return with the number of font defaults currently stored.  *****************************************************************************************************************//* *  TXNGetFontDefaults() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNGetFontDefaults( TXNObject iTXNObject, ItemCount * ioCount, TXNMacOSPreferredFontDescription ioFontDefaults[]) = OSStatus/* can be NULL */toolbox fn TXNGetFontDefaults( TXNObject iTXNObject, ItemCount * ioCount,  pointer ) = OSStatus/* can be NULL *//*  ****************************************************************************************************************    TXNAttachObjectToWindow    If a TXNObject was initialized with a NULL window pointer use this function to attach a window    to that object.  In version 1.0 of Textension attaching a TXNObject to more than one window    is not supported.  Note that if a CGContextRef was passed to the TXNObject previously thru the    API TXNSetTXNObjectControls, that CGContextRef will be ignored.  The CGContextRef associated with    the iWindow will be used instead.  You may revert back to the previous CGContextRef by calling the    API TXNSetTXNObjectControls with the desired CGContextRef again after calling TXNAttachObjectToWindow.        Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iWindow:            GWorldPtr that the object should be attached to        iIsActualWindow:    Let the library know if the GWorldPtr is actually                            a WindowRef or actually a GWorldPtr.  This is important                            if the client is taking advantage of the editing packages                            scrollbar support.    Output:        OSStatus:           function result.  paramErrs.   *****************************************************************************************************************//* *  TXNAttachObjectToWindow() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNAttachObjectToWindow( TXNObject iTXNObject, WindowRef iWindow, Boolean iIsActualWindow) = OSStatus/*  ****************************************************************************************************************    TXNIsObjectAttachedToWindow    A utility function that allows a caller to check a TXNObject to see if it is attached    to a window.    Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.    Output:        Boolean:            function result.  True is object is attached.                            False if TXNObject is not attached.  *****************************************************************************************************************//* *  TXNIsObjectAttachedToWindow() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNIsObjectAttachedToWindow( TXNObject iTXNObject) = Boolean/*  ****************************************************************************************************************    TXNDragTracker    If you ask that Drag handling procs not be installed.  Call this when your drag tracker is called    and you want Textension to take over    Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iTXNFrameID:            TXNFrameID obtained from TXNNewObject        iMessage:           drag message obtained from Drag Manager        iWindow :           WindowRef obtained from Drag Manager        iDragReference:     dragReference obtained from Drag Manager        iDifferentObjectSameWindow: Pass true if the drag is still in the same window                                   that it started in. False if the drag has moved into                                   a different window.    Output:        OSErr:              function result.  OSErr is used over                            OSStatus so that it matches the Drag Manager definition of Tracking callback  *****************************************************************************************************************//* *  TXNDragTracker() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later *///toolbox fn TXNDragTracker( TXNObject iTXNObject, TXNFrameID iTXNFrameID, DragTrackingMessage iMessage, WindowRef iWindow, Ptr iDragReference, Boolean iDifferentObjectSameWindow) = OSErrtoolbox fn TXNDragTracker( TXNObject iTXNObject, TXNFrameID iTXNFrameID, SInt16 iMessage, WindowRef iWindow, pointer iDragReference, Boolean iDifferentObjectSameWindow) = OSErr/*  ****************************************************************************************************************    TXNDragReceiver    If you ask that Drag handling procs not be installed.  Call this when your drag receiver is called    and you want Textension to take over    Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iTXNFrameID         TXNFrameID obtained from TXNNewObject        iWindow             WindowRef obtained from Drag Manager        iDragReference      dragReference obtained from Drag Manager        iDifferentObjectSameWindow: Pass true if the drag is still in the same window                                   that it started in. False if the drag has moved into                                   a different window.    Output:        OSErr:              function result.  OSErr is used over                            OSStatus so that it matches the Drag Manager definition of Tracking callback  *****************************************************************************************************************//* *  TXNDragReceiver() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNDragReceiver( TXNObject iTXNObject, TXNFrameID iTXNFrameID, WindowRef iWindow, pointer iDragReference, Boolean iDifferentObjectSameWindow) = OSErr/*  ****************************************************************************************************************    TXNActivate    Make the TXNObject object active in the sense that it can be scrolled if it has scrollbars.  If the TXNScrollBarState parameter    is true than the scrollbars will be active even when the TXNObject is not focused (i.e. insertion point not active)        This function should be used if you have multiple TXNObjects in a window, and you want them all to be scrollable    even though only one at a time can have the keyboard focus.    Input:        iTXNObject:         opaque TXNObject obtained from TXNNewObject.        iTXNFrameID         TXNFrameID obtained from TXNNewObject        iActiveState        Boolean if true Scrollbars active even though TXNObject does not have the keyboard focus.                              if false scrollbars are synced with active state (i.e. a focused object has an                            active insertion point or selection and active scrollbars. An unfocused object has inactive                            selection (grayed or framed selection) and inactive scrollbars.  The latter state is the                             default and usually the one you use if you have one TXNObject in a window.    Output:        OSStatus:           function result.  ParamErr if bad iTXNObject or frame ID.  *****************************************************************************************************************//* *  TXNActivate() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNActivate( TXNObject iTXNObject, TXNFrameID iTXNFrameID, TXNScrollBarState iActiveState) = OSStatus/*  *****************************************************************************************************************    TXNSetBackgound    Set the type of background the TXNObject`s text, etc. is drawn onto.  At this point the background    can be a color or a picture.          Input:        iTXNObject:         opaque TXNObject obtained from IncomingDataFilter callback.        iBackgroundInfo:    struct containing information that describes the background    Output:        OSStatus:           function result.  paramErrs.  *********************************************************************************************************************//* *  TXNSetBackground() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNSetBackground( TXNObject iTXNObject, const TXNBackground * iBackgroundInfo) = OSStatus/*  *****************************************************************************************************************    TXNEchoMode    Put the TXNObject into echo mode.  What that means is that all characters in the TXNObject have the character    `echoCharacter` substituted for the actual glyph when drawing occurs. Note that the echoCharacter is typed    as a UniChar, but this is done merely to facilitate passing any 2 byte character.  The encoding parameter    actually determines the encoding used to locate a font and display a character.  Thus if you wanted to    display the diamond found in the Shift-JIS encoding for MacOS you would pass in 0x86A6 for the character    but an encoding that was built to represent the MacOS Japanese encoding.        Input:        iTXNObject:         opaque TXNObject obtained from IncomingDataFilter callback.        iEchoCharacter:     character to use in substitution        iEncoding:          encoding from which character is drawn.        iOn:                true if turning EchoMode on.  False if turning it off.    Output:        OSStatus:           function result.  paramErrs.  *********************************************************************************************************************//* *  TXNEchoMode() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNEchoMode( TXNObject iTXNObject, UniChar iEchoCharacter, TextEncoding iEncoding, Boolean iOn) = OSStatus/*  ********************************************************************************************************************    TXNNewFontMenuObject    Get a FontMenuObject.  Caller can extract a fontmenu from this object and pass this object to the active    TXNObject to handle events in the font menu.    Input:        iFontMenuHandle:    An empty menu handle (well the title is there) that the caller created via                            NewMenu or GetNewMenu. This menu handle should not be disposed before                            the returned TXNFontMenuObject has been disposed via TXNDisposeFontMenuObject.        iMenuID:            The MenuID for iFontMenuHandle.        iStartHierMenuID:   The first MenuID to use if any hierarchical menus need to be created. TXNNewFontMenuObject                            uses SetMenuItemHierarchicalID when creating hierarchial menus.  The iStartHierMenuID must                            therefor follow the rules for this function.  On systems less than system 8.5 the submenuID                            must be less than 255.  For systems above system 8.5 the range can be as large can be as large                            32767.  However, it is important to remember that TXNNewFontMenuObject only uses iStartHierMenuID                            as a starting id when adding hierarchical menus.  Therefore provide plenty of room to increment                            this value. For example, on a system less than 8.5 it would be good to start at 175.  On systems greater                            than 8.5 it is probably a good idea to not use a value higher than 32000.             Output:        OSStatus:           function result.  memory, parameter errors.        TXNFontMenuObject:  A font menu object  **********************************************************************************************************************//* *  TXNNewFontMenuObject() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNNewFontMenuObject( MenuRef iFontMenuHandle, SInt16 iMenuID, SInt16 iStartHierMenuID, TXNFontMenuObject * oTXNFontMenuObject) = OSStatus/*  *********************************************************************************************************************    TXNGetFontMenuHandle    Get the MenuRef from the TXNFontMenuObject.    Input:        iTXNFontMenuObject:     A Font Menu Object obtained from TXNNewFontMenuObject.    Output:        OSStatus:           function result. parameter errors.        oFontMenuHandle:    The returned font menu. (returned value could be NULL)  **********************************************************************************************************************//* *  TXNGetFontMenuHandle() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNGetFontMenuHandle( TXNFontMenuObject iTXNFontMenuObject, MenuRef * oFontMenuHandle) = OSStatus' TXNGetFontMenuRef = TXNGetFontMenuHandle /*  *********************************************************************************************************************    TXNDisposeFontMenuObject    Dispose a TXNFontMenuObject and its font menu handle    Input:        iTXNFontMenuObject:     A Font Menu Object obtained from TXNNewFontMenuObject.    Output:        OSStatus:   function result. parameter errors.  **********************************************************************************************************************//* *  TXNDisposeFontMenuObject() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNDisposeFontMenuObject( TXNFontMenuObject iTXNFontMenuObject) = OSStatus/*  *********************************************************************************************************************    TXNDoFontMenuSelection        Given the menuID and menu item returned by MenuSelect determine the selected font        and change the current selection to be that Font.  If the input TXNObject is        not active a parameter error is returned.    Input:        iTXNObject: An opaque TXNObject obtained from TXNNewObject.        iTXNFontMenuObject:     A Font Menu Object obtained from TXNNewFontMenuObject.        iMenuID:    SInt16 the ID of the selected menu.        iMenuItem:  The item that was selected.    Output:        OSStatus:   ParamErr and memory errors are possible.  ***********************************************************************************************************************//* *  TXNDoFontMenuSelection() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNDoFontMenuSelection( TXNObject iTXNObject, TXNFontMenuObject iTXNFontMenuObject, SInt16 iMenuID, SInt16 iMenuItem) = OSStatus/* *  TXNPrepareFontMenu() *   *  Summary: *    Prepares a Font menu for display. *   *  Discussion: *    You should call the TXNPrepareFontMenu function just before your *    application opens the Font menu for your user. If the text *    objectÕs current selection is a single font, MLTE places a *    checkmark next to the menu item for that font. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      The text object that identifies the document with the Font menu *      you want to prepare. Pass NULL to display an inactive menu *      (dimmed). *     *    iTXNFontMenuObject: *      A Font menu object. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNPrepareFontMenu( TXNObject iTXNObject, TXNFontMenuObject iTXNFontMenuObject) = OSStatus/* can be NULL *//*  **********************************************************************************************************************    TXNVersionValue        Get the version number and a set of feature bits.  TXNVersionValue uses a NumVersion structure.        See MacTypes.h for the format of the version.  Currently there are two feature bits:  one for         ATSUI default, another one for CarbonEvent default.    Input:        NONE            Output:        TXNVersionValue:    Current version.        TXNFeatureBits*:    Pointer to a bit mask.  See TXNFeatureMask enum above. If kTXNWillDefaultToATSUIBit                            is set it means that by default MLTE will use ATSUI to image and measure text and will                            default to using Unicode to store characters.  If kTXNWillDefaultToCarbonEventBit is set,                            then MLTE will use carbon events by default and apple event will not be supported.  ***********************************************************************************************************************//* *  TXNVersionInformation() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.0 and later *    Non-Carbon CFM:   in Textension 1.0 and later */toolbox fn TXNVersionInformation( TXNFeatureBits * oFeatureFlags) = TXNVersionValue/*  ****************************************************************************************    TXNPointToOffset                Input:        iTXNObject: An opaque TXNObject obtained from TXNNewObject.        iPoint:     a point (in local coord.)    Output:        TXNOffset   :   Offset corresponding to the point        OSStatus:   Memory, out of bounds errors.(if the point is out of the ViewRect)  *****************************************************************************************//* *  TXNPointToOffset() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.1 and later *    Non-Carbon CFM:   in Textension 1.1 and later */toolbox fn TXNPointToOffset( TXNObject iTXNObject, Point iPoint, TXNOffset * oOffset) = OSStatus/*  ****************************************************************************************    TXNOffsetToPoint                Input:        iTXNObject: An opaque TXNObject obtained from TXNNewObject.        iOffset:    an offset    Output:        Point   :   Point corresponding to the offset iOffset.        OSStatus:   Memory, out of bounds errors.  *****************************************************************************************//* *  TXNOffsetToPoint() *   *  Mac OS X threading: *    Not thread safe *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.1 and later *    Non-Carbon CFM:   in Textension 1.1 and later */toolbox fn TXNOffsetToPoint( TXNObject iTXNObject, TXNOffset iOffset, Point * oPoint) = OSStatus/* *  TXNDrawUnicodeTextBox() *   *  Summary: *    Draws a Unicode string in the specified rectangle. *   *  Discussion: *    Client is supposed to do an EraseRect if needed. The drawing will *    be clipped to the rect unless the client specifies a rotation. *    Use kTXNUseVerticalTextMask to display text vertically (no need *    to use the kTXNRotateTextMask flag in this case). *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iText: *      Ptr to a Unicode string (UTF16 chars). *     *    iLen: *      Number of UniChars in iText (this is not the size of iText). *     *    ioBox: *      On input the text box where the text will be displayed. On *      return will be updated to reflect the minimum bounding Rect *      that will enclose the text (unless kTXNDontUpdateBoxRectMask is *      used). *     *    iStyle: *      Style to use to display the text. *     *    iOptions: *      Can be used to specify non-default behavior. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.1 and later *    Non-Carbon CFM:   in Textension 1.1 and later *////toolbox fn TXNDrawUnicodeTextBox( const UniChar iText[], UniCharCount iLen, Rect * ioBox, ATSUStyle iStyle, const TXNTextBoxOptionsData * iOptions) = OSStatus/* can be NULL */toolbox fn TXNDrawUnicodeTextBox( pointer, UniCharCount iLen, Rect * ioBox, ATSUStyle iStyle, const TXNTextBoxOptionsData * iOptions) = OSStatus/* can be NULL *//* can be NULL *//* *  TXNDrawCFStringTextBox() *   *  Summary: *    Draws a CFString in the specified rectangle. *   *  Discussion: *    Client is supposed to do an EraseRect if needed. The drawing will *    be clipped to the rect unless the client specifies a rotation. *    Use kTXNUseVerticalTextMask to display text vertically (no need *    to use the kTXNRotateTextMask flag in this case). *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iText: *      A CFStringRef (see CFBase.h and CFString.h). *     *    ioBox: *      On input the text box where the text will be displayed. On *      return will be updated to reflect the minimum bounding Rect *      that will enclose the text (unless kTXNDontUpdateBoxRectMask is *      used). *     *    iStyle: *      Style to use to display the text. *     *    iOptions: *      Can be used to specify non-default behavior. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.1 and later *    Non-Carbon CFM:   not available */toolbox fn TXNDrawCFStringTextBox( CFStringRef iText, Rect * ioBox, ATSUStyle iStyle, const TXNTextBoxOptionsData * iOptions) = OSStatus/* can be NULL *//* can be NULL *//* *  TXNGetLineCount() *   *  Summary: *    Get the total number of lines in the TXNObject. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    oLineTotal: *      On return the total number of lines in the object. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.1 and later *    Non-Carbon CFM:   in Textension 1.1 and later */toolbox fn TXNGetLineCount( TXNObject iTXNObject, ItemCount * oLineTotal) = OSStatus/* *  TXNGetLineMetrics() *   *  Summary: *    Get the metrics for the specified line. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iLineNumber: *      The line we want the metrics for (0 based). *     *    oLineWidth: *      On return the width of the line (in Fixed format). *     *    oLineHeight: *      On return the height (ascent + descent) of the line (in Fixed *      format). *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.1 and later *    Non-Carbon CFM:   in Textension 1.1 and later */toolbox fn TXNGetLineMetrics( TXNObject iTXNObject, UInt32 iLineNumber, Fixed * oLineWidth, Fixed * oLineHeight) = OSStatus/* *  TXNGetActionChangeCount() *   *  Summary: *    Retrieves the number of times the specified action(s) have *    occurred. *   *  Discussion: *    Explicit call to TXNClearActionChangeCount is needed when the *    counter(s) have to be reset. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iOptions: *      Specify the the type of action changes to be include when *      retrieving the count.  Choose from the TXNOptions. *     *    oCount: *      The number of counts returned by the function. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   in Textension 1.3 and later */toolbox fn TXNGetActionChangeCount( TXNObject iTXNObject, TXNCountOptions iOptions, ItemCount * oCount) = OSStatus/* *  TXNClearActionChangeCount() *   *  Summary: *    Reset the specified action counter(s) to zero. *   *  Discussion: *    Use kAllCountMask to reset everything. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iOptions: *      Specify the the type of action changes to be include when *      resetting the count.  Choose from the TXNOptions. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   in Textension 1.3 and later */toolbox fn TXNClearActionChangeCount( TXNObject iTXNObject, TXNCountOptions iOptions) = OSStatus/* *  TXNIsObjectAttachedToSpecificWindow() *   *  Summary: *    Determines whether the given object is attached to the given *    window. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iWindow: *      The window to check attachment against. *     *    oAttached: *      true if the object is attached to the given window, false *      otherwise. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.0 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.3 and later *    Non-Carbon CFM:   in Textension 1.2 and later */toolbox fn TXNIsObjectAttachedToSpecificWindow( TXNObject iTXNObject, WindowRef iWindow, Boolean * oAttached) = OSStatus/* *  TXNSetRectBounds() *   *  Summary: *    Set the View rectangle and or the Destination rectangle. *   *  Discussion: *    The View rectangle controls the text you see.  The Destination *    rectangle controls how text is laid out.  The Scrollbar is drawn *    inside the View rectangle. You only need to pass in pointers for *    the rectangles you want to set. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iViewRect: *      The new view rectangle.  If you do not want to change the view *      rectangle pass NULL. *     *    iDestinationRect: *      The new destination rectangle.  Pass NULL if you don`t want to *      change the destination retangle. *     *    iUpdate: *      If you would like the the text and where the scrollbars are *      placed recalculated and redrawn pass true.  If you prefer to *      wait on this pass false. *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.5 and later *    Non-Carbon CFM:   not available */toolbox TXNSetRectBounds( TXNObject iTXNObject, const Rect * iViewRect, const TXNLongRect * iDestinationRect, Boolean iUpdate)/* can be NULL *//* can be NULL *//* *  TXNGetRectBounds() *   *  Summary: *    Get the values for the current View rectangle, Destination *    rectangle and Text rectangle. *   *  Discussion: *    You only need to pass in pointers for the rectangles you`re *    interested in. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    oViewRect: *      The current view rectangle *     *    oDestinationRect: *      The current destination rectangle *     *    oTextRect: *      The smallest rectangle needed to contain the current text.  *      This rectangle is calculated by walking the lines of text and *      measuring each line.  So this can be expensive.  The width of *      this rectangle will be the width of the longest line in the *      text. *   *  Result: *    An operating system status code. *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.5 and later *    Non-Carbon CFM:   not available */toolbox fn TXNGetRectBounds( TXNObject iTXNObject, Rect * oViewRect, TXNLongRect * oDestinationRect, TXNLongRect * oTextRect) = OSStatus/* can be NULL *//* can be NULL *//* can be NULL *//* *  TXNRecalcTextLayout() *   *  Summary: *    Recalculates the text layout based on the new View and *    Destination rectangles. *   *  Discussion: *    Call this if you called TXNSetRectBounds with the iUpdate *    parameter set to false. It will also recalcuate where the *    scrollbars, if any, should be placed. Finally an update event *    will be generated so that the TXNObject is redrawn. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *   *  Availability: *    Mac OS X:         in version 10.1 and later in Carbon.framework *    CarbonLib:        in CarbonLib 1.5 and later *    Non-Carbon CFM:   not available */toolbox TXNRecalcTextLayout( TXNObject iTXNObject)/* *  TXNScroll() *   *  Discussion: *    TXNScroll scrolls the text within a view rectangle of the *    specified object by the designated number of units.  For example, *    you might want to scroll the text in an object in response to *    user input in a control other than the standard scrollbars that *    MLTE supplies. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iVerticalScrollUnit: *      Specifies what units the values in ioVerticalDelta are in.  If *      iVerticalScrollUnit is equal to kTXNScrollUnitsArePixels the *      value is treated as pixels.  If the value is *      kTXNScrollUnitsAreLines the value is treated as a count of *      lines. Note that using this value is the slowest because each *      line must be measured before it scrolls.  Finally if *      kTXNScrollUnitsAreViewRects the value is treated as the height *      of the current viewRect. *     *    iHorizontalScrollUnit: *      Specifies what units the values in iDh are in.  If *      iHorizontalScrollUnit is equal to kTXNScrollUnitsArePixels the *      value is treated as pixels.  If the value is *      kTXNScrollUnitsAreLines the value is treated as a count of *      lines. Note that using this value for horizontal scrolling *      means that 16 pixels will be used to represent a line.  Finally *      if kTXNScrollUnitsAreViewRects the value is treated as the *      width of the current viewRect. *     *    ioVerticalDelta: *      The vertical amount to scroll.  The values in ioVerticalDelta *      can be treated as pixels, lines or viewrects.  See the *      discussion of the TXNScrollUnit parameters for more information *      for this.  On return this will contain the number of pixels *      actually scrolled in the vertical direction. A positive value *      moves the text down. *     *    ioHorizontalDelta: *      The horizontal amount to scroll. The values in *      ioHorizontalDelta can specify a scroll amount that is pixels, *      lines or view rects.  Set TXNScrollUnit discussion for more *      information. On return this will contain the number of pixels *      actually scrolled in the horizontal direction. A positive value *      moves the text to the right. *   *  Availability: *    Mac OS X:         in version 10.2 and later in Carbon.framework *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later *    Non-Carbon CFM:   in Textension not yet available */toolbox fn TXNScroll( TXNObject iTXNObject, TXNScrollUnit iVerticalScrollUnit, TXNScrollUnit iHorizontalScrollUnit, SInt32 * ioVerticalDelta, SInt32 * ioHorizontalDelta) = OSStatus/* *  TXNRegisterScrollInfoProc() *   *  Discussion: *    If your application is drawing and handling its own scrolling *    widgets use this function to register a TXNScrollInfoUPP.  If you *    register a TXNScrollInfoUPP it will be called every time MLTE *    would normally update the values and maximum values of an MLTE *    scrollbar. For example when the user types the return key to add *    a new line at the end of their text MLTE will calculate a new *    maximum value.  If you have registered a TXNScrollInfoUPP it will *    be called with this nex maximum value. To turn off the callbacks *    call TXNRegisterScrollInfoProc with a value of NULL for the *    iTXNScrollInfoUPP. *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *     *    iTXNScrollInfoUPP: *      A universal procedure pointer. *     *    iRefCon: *      A refcon that is passed to the callback. *   *  Availability: *    Mac OS X:         in version 10.2 and later in Carbon.framework *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later *    Non-Carbon CFM:   in Textension not yet available */toolbox TXNRegisterScrollInfoProc( TXNObject iTXNObject, proc iTXNScrollInfoUPP, SInt32 iRefCon)toolbox fn HITextViewCreate(Â  const HIRect *    inBoundsRect, Â  OptionBits        inOptions,Â  TXNFrameOptions   inTXNFrameOptions,Â  HIViewRef *       outTextView) = OSStatus // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATERtoolbox fn HITextViewGetTXNObject( HIViewRef inTextView ) = TXNObjecttoolbox fn TXNSetDataFromCFURLRef(Â   TXNObject iTXNObject,Â   CFURLRef iURL,Â   TXNOffset iStartOffset,Â   TXNOffset iEndOffset ) = OSStatus // AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4/* *  TXNClearUndo() *   *  Summary: *    Purge the undo stack *   *  Mac OS X threading: *    Not thread safe *   *  Parameters: *     *    iTXNObject: *      Opaque TXNObject obtained from TXNNewObject. *   *  Availability: *    Mac OS X:         in version 10.2 and later in Carbon.framework *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later *    Non-Carbon CFM:   in Textension not yet available */toolbox fn TXNClearUndo( TXNObject iTXNObject) = OSStatusbegin enum not output_kTXNSupportEditCommandProcessing = 1 << 0_kTXNSupportEditCommandUpdating = 1 << 1_kTXNSupportSpellCheckCommandProcessing = 1 << 2_kTXNSupportSpellCheckCommandUpdating = 1 << 3_kTXNSupportFontCommandProcessing = 1 << 4_kTXNSupportFontCommandUpdating = 1 << 5end enum#define TXNCommandEventSupportOptions as UInt32toolbox fn TXNSetCommandEventSupport( TXNObject iTXNObject, TXNCommandEventSupportOptions iOptions ) = OSStatus // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATERtoolbox fn TXNGetCommandEventSupport( TXNObject iTXNObject, TXNCommandEventSupportOptions *oOptions) = OSStatus // AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER#endif