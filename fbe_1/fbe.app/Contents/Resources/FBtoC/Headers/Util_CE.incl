/*Util_CE.inclA simplified method to implement Carbon Events in your code. See demos in FB_5_x_y_Examples > CarbonEvents.bw:20081002All the routines here are public.You are encouraged to read through the file in search of useful functions.   rp 20090103update 20120424 bw - store events as CFData instead of handle*/include "Tlbx CarbonEvents.incl"begin globalsdim as CFMutableDataRef sCEEventTypeDataend globals'~CEAddEvent/*Add a class/kind event to our private queue, which is empty by default.Typical usage:// the queue is empty at app startupfn CEAddEvent( _kEventClassWindow, _kEventWindowClose )... as many as you want...fn CEAddEvent( _kEventClassControl, _kEventControlHit )// install them on a windowfn CEInstallWindowEventHandler( w, @fn MyWindowCEHandler, 0, 0 )// the queue is now empty againfn CEAddEvent( _kEventClassControl, _kEventControlDraw )... as many as you want...fn CEAddEvent( _kEventClassControl, _kEventControlHit )// install them on a controlfn CEInstallControlEventHandler( c, @fn MyControlCEHandler, 0, 0 )...*/local fn CEAddEvent( eventClass as UInt32, eventKind as UInt32 )'~'1dim as EventTypeSpec   eventSpeceventSpec.eventClass = eventClasseventSpec.eventKind = eventKindif ( sCEEventTypeData == NULL )sCEEventTypeData = fn CFDataCreateMutable( _kCFAllocatorDefault, 0 )end ifCFDataAppendBytes( sCEEventTypeData, @eventSpec, sizeof( eventSpec ) )end fn'~CEInstall/*These routines install our private queue of class/kind events on the appropriate target, then empty the queue.The userFn parameter is required: it is either a direct function address (obtained with @fn) or a UPP.The userData parameter is declared as pointer but can be any 4-byte integer (Handle, HIViewRef, long...).Its value is available in your handler function either to ignore or to use for any purpose you choose.Unless you Really Know what you are doing, set the outHandlerRef parameter to 0.*/local fn CEInstallEventHandler( target as EventTargetRef, userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1dim as ptr        eventsdim as CFIndex    lengthdim as OSStatus   err : err = _nilHandleErrlong if ( sCEEventTypeData )length = fn CFDataGetLength( sCEEventTypeData )events = fn malloc( length )CFDataGetBytes( sCEEventTypeData, fn CFRangeMake( 0, length ), events )err = fn InstallEventHandler( target, userFn, ( length / sizeof( EventTypeSpec ) ), #events, #userData, #outHandlerRef )free( events )CFRelease( sCEEventTypeData )sCEEventTypeData = 0end ifend fn = errlocal fn CEInstallApplicationEventHandler( userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1end fn = fn CEInstallEventHandler( fn GetApplicationEventTarget(), #userFn, #userData, #outHandlerRef )local fn CEInstallWindowEventHandler( w as WindowRef, userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1end fn = fn CEInstallEventHandler( fn GetWindowEventTarget( w ), #userFn, #userData, #outHandlerRef )local fn CEInstallControlEventHandler( c as ControlRef, userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1end fn = fn CEInstallEventHandler( fn GetControlEventTarget( c ), #userFn, #userData, #outHandlerRef )// rarely usedlocal fn CEInstallMenuEventHandler( m as MenuRef, userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1end fn = fn CEInstallEventHandler( fn GetMenuEventTarget( m ), #userFn, #userData, #outHandlerRef )// rarely usedlocal fn CEInstallUserFocusEventHandler( userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1end fn = fn CEInstallEventHandler( fn GetUserFocusEventTarget(), #userFn, #userData, #outHandlerRef )local fn CEInstallEventMonitorEventHandler( userFn as pointer, userData as pointer, outHandlerRef as ^EventHandlerRef )'~'1end fn = fn CEInstallEventHandler( fn GetEventMonitorTarget(), #userFn, #userData, #outHandlerRef )'~CEParam/*Functions you can call from your handler routines, to simplify them.All functions are wrappers for GetEventParameter(), and return its error code (0 ==_noErr)*/local fn CEParamGetHICommand( theEvent as EventRef, @command as ^HICommandExtended )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamDirectObject, _typeHICommand, #0, sizeof( HICommandExtended ), #0, #command )// Try to get the wRef from kEventParamDirectObject. If that's not successful, try kEventParamWindowRef.local fn CEParamGetWindowRef( theEvent as EventRef, @w as ^WindowRef )'~'1dim as OSStatus   errerr = fn GetEventParameter( theEvent, _kEventParamDirectObject, _typeWindowRef, #0, sizeof( WindowRef ), #0, #w )long if ( err )err = fn GetEventParameter( theEvent, _kEventParamWindowRef, _typeWindowRef, #0, sizeof( WindowRef ), #0, #w )end ifend fn = errlocal fn CEParamGetAttributes( theEvent as EventRef, @attributes as ^UInt32 )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamAttributes, _typeUInt32, #0, sizeof( UInt32 ), #0, #attributes )local fn CEParamGetCurrentRectBounds( theEvent as EventRef, @bounds as ^Rect )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamCurrentBounds, _typeQDRectangle, #0, sizeof( Rect ), #0, #bounds )local fn CEParamGetCurrentHIRectBounds( theEvent as EventRef, @bounds as ^HIRect )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamCurrentBounds, _typeHIRect, #0, sizeof( HIRect ), #0, #bounds )// Try to get the cRef from kEventParamDirectObject. If that's not successful, try kEventParamControlRef.local fn CEParamGetControlRef( theEvent as EventRef, @c as ^ControlRef )'~'1dim as OSStatus   errerr = fn GetEventParameter( theEvent, _kEventParamDirectObject, _typeControlRef, #0, sizeof( ControlRef ), #0, #c )long if ( err )err = fn GetEventParameter( theEvent, _kEventParamControlRef, _typeControlRef, #0, sizeof( ControlRef ), #0, #c )end ifend fn = errlocal fn CEParamGetHIPointMouseLocation( theEvent as EventRef, @hiPt as ^HIPoint )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamMouseLocation, _typeHIPoint, #0, sizeof( HIPoint ), #0, #hiPt )local fn CEParamGetClickCount( theEvent as EventRef, @numClicks as ^long )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamClickCount, _typeLongInteger, #0, sizeof( long ), #0, #numClicks )local fn CEParamGetKeyCode( theEvent as EventRef, @keyCode as ^UInt32 )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamKeyCode, _typeUInt32, #0, sizeof( UInt32 ), #0, #keyCode )local fn CEParamGetKeyModifiers( theEvent as EventRef, @modifiers as ^UInt32 )'~'1end fn = fn GetEventParameter( theEvent, _kEventParamKeyModifiers, _typeUInt32, #0, sizeof( UInt32 ), #0, #modifiers )'~CETimerbegin globalsdim as EventLoopTimerRef sCETimer(255) // privateend globals/*id is 0-255, but you will rarely want more than 1 or 2 timers.None of the functions returns an error code.Typical usage:fn CETimerInstall( 0, 0.0, 0.5, @fn MyCETimerRoutine, 0 )*/// sometimes usefullocal fn CETimerRemove( id as UInt8 )'~'1if ( sCETimer(id) ) then fn RemoveEventLoopTimer( sCETimer(id) )sCETimer(id) = 0end fn// create a new timerlocal fn CETimerInstall( id as UInt8, initialDelay as double, interval as double, userFn as pointer, userData as pointer )'~'1dim as EventLoopTimerRef   timerReffn CETimerRemove( id )fn InstallEventLoopTimer( fn GetMainEventLoop(), initialDelay, interval, userFn, #userData, @timerRef )sCETimer(id) = timerRefend fn// rarely neededlocal fn CETimerSetNextFireTime( id as UInt8, nextFireInterval as EventTimerInterval )'~'1if ( sCETimer(id) ) then fn SetEventLoopTimerNextFireTime( sCETimer(id), nextFireInterval )end fn