/*   CFPrefs.incl   by Robert Purves & Bernie Wylde,   May 2005   FBtoC mods: 18 July 2007  bw   Changes 20081204  bw     - CFPrefsSynchronize changed to CFPrefsAppSynchronize     - Two new functions CFPrefsCopyAppValue & CFPrefsSetAppValue   Changes 20100221  Brian     - Pascal string handling removed throughout include - all keys and values passed are now CFStrings     - CFPrefsSetPString & CFPrefsGetPString are removed. CFPrefsCopyAppValue & CFPrefsSetAppValue perform the function     - Some calling parameters might have changed slightly. Check the demos or this include.     */include "Tlbx CFPreferences.incl"begin globalsdim as CFStringRef   sCFPrefsApplicationIDend globalslocal fn CFPrefsSetApplicationID( appID as CFStringRef )'~'1if ( sCFPrefsApplicationID == 0 ) then sCFPrefsApplicationID = appIDend fnlocal fn CFPrefsGetApplicationID as CFStringRef'~'1if ( sCFPrefsApplicationID == 0 ) then fn CFPrefsSetApplicationID( kCFPreferencesCurrentApplication )end fn = sCFPrefsApplicationID// write to disk now; not normally necessarylocal fn CFPrefsAppSynchronize as Boolean '~'1end fn = fn CFPreferencesAppSynchronize( fn CFPrefsGetApplicationID() )local fn CFPrefsCopyAppValue( keyStr as CFStringRef ) as CFTypeRef'~'1end fn = fn CFPreferencesCopyAppValue( keyStr, fn CFPrefsGetApplicationID() )local fn CFPrefsSetAppValue( keyStr as CFStringRef, value as CFTypeRef )'~'1long if ( keyStr )CFPreferencesSetAppValue( keyStr, value, fn CFPrefsGetApplicationID() )end ifend fnlocal fn CFPrefsGetBool( keyStr as CFStringRef, @value as ^Boolean, default as Boolean )'~'1dim as Boolean       fromPrefs : fromPrefs = _falsevalue.nil` = fn CFPreferencesGetAppBooleanValue( keyStr, fn CFPrefsGetApplicationID(), @fromPrefs )if ( fromPrefs == _false ) then value.nil` = defaultend fn = fromPrefslocal fn CFPrefsSetBool( key as CFStringRef, value as Boolean )'~'1long if ( value )fn CFPrefsSetAppValue( key, kCFBooleanTrue )xelsefn CFPrefsSetAppValue( key, kCFBooleanFalse )end ifend fnlocal fn CFPrefsGetLong( keyStr as CFStringRef, @value as ^long, default as long )'~'1dim as Boolean       fromPrefs : fromPrefs = _falsevalue.nil& = fn CFPreferencesGetAppIntegerValue( keyStr, fn CFPrefsGetApplicationID(), @fromPrefs )if ( fromPrefs == _false ) then value.nil& = defaultend fn = fromPrefslocal fn CFPrefsSetLong( key as CFStringRef, setVal as long )'~'1dim as CFNumberRef   valueRefvalueRef = fn CFNumberCreate( _nil, _kCFNumberIntType, @setVal )long if ( valueRef )fn CFPrefsSetAppValue( key, valueRef )CFRelease( valueRef )end ifend fnlocal fn CFPrefsGetDbl( key as CFStringRef, @value as ^double, default as double )'~'1dim as CFNumberRef   valueRefdim as Boolean       fromPrefs : fromPrefs = _falsevalueRef = fn CFPrefsCopyAppValue( key )long if ( valueRef )long if (fn CFGetTypeID( valueRef ) == fn CFNumberGetTypeID() )fromPrefs = fn CFNumberGetValue( valueRef, _kCFNumberFloat64Type, #value )end ifCFRelease( valueRef )end ifif ( fromPrefs == _false ) then value.nil# = defaultend fn = fromPrefslocal fn CFPrefsSetDbl( key as CFStringRef, setVal as double )'~'1dim as CFNumberRef   valueRefvalueRef = fn CFNumberCreate( _nil, _kCFNumberFloat64Type, @setVal )long if ( valueRef )fn CFPrefsSetAppValue( key, valueRef )CFRelease( valueRef )end ifend fnlocal fn CFPrefsGetRect( key as CFStringRef, r as ^Rect, default as ^Rect )'~'1dim as CFStringRef Ê valuedim as CFArrayRef Ê Êarraydim as Boolean Ê Ê Ê fromPrefs : fromPrefs = _falsevalue = fn CFPrefsCopyAppValue( key )long if ( value )array = fn CFStringCreateArrayBySeparatingStrings( _kCFAllocatorDefault, value, @"," )long if ( array )long if ( fn CFArrayGetCount( array ) == 4 ) // specific to Rect - needs 4 integers ( 0 to 3 )r.top Ê Ê= fn CFStringGetIntValue( fn CFArrayGetValueAtIndex( array, 0 ) )r.left Ê = fn CFStringGetIntValue( fn CFArrayGetValueAtIndex( array, 1 ) )r.bottom = fn CFStringGetIntValue( fn CFArrayGetValueAtIndex( array, 2 ) )r.right Ê= fn CFStringGetIntValue( fn CFArrayGetValueAtIndex( array, 3 ) )fromPrefs = _trueend ifCFRelease( array )end ifCFRelease( value )end ifif ( fromPrefs == _false ) then BlockMove( default, r, sizeof( Rect ) )end fn = fromPrefslocal fn CFPrefsSetRect( key as CFStringRef, r as ^Rect )'~'1dim as CFStringRef   stringstring = fn CFStringCreateWithFormat( _kCFAllocatorDefault, #0, @"%d,%d,%d,%d", r.top,r.left,r.bottom,r.right )fn CFPrefsSetAppValue( key, string )// bw:20100221CFRelease( string )end fn// CFPrefsGetBytes takes no default parameter.local fn CFPrefsGetBytes( key as CFStringRef, p as pointer, maxSize as long )'~'1dim as CFDataRef     dataRefdim as CFIndex       sizedim as Boolean       fromPrefs : fromPrefs = _falsedataRef = fn CFPrefsCopyAppValue( key )long if ( dataRef )long if ( fn CFGetTypeID( dataRef) == fn CFDataGetTypeID() )size = fn CFDataGetLength( dataRef )long if ( size <= maxSize )CFDataGetBytes( dataRef, fn CFRangeMake( 0, size ), p )fromPrefs = _trueend ifend ifCFRelease( dataRef )end ifend fn = fromPrefslocal fn CFPrefsSetBytes( key as CFStringRef, p as pointer, size as long )'~'1dim as CFDataRef   dataRefdataRef = fn CFDataCreate( 0, p, size )long if ( dataRef )fn CFPrefsSetAppValue( key, dataRef )CFRelease( dataRef )end ifend fn// CFPrefsGetHandle takes no default parameter.// It provides a new Handle (containing the pref data) or 0 on failure.// The caller is responsiblefor disposing of the Handle.local fn CFPrefsGetHandle( key as CFStringRef, @value as ^Handle )'~'1dim as CFDataRef   dataRefdim as CFIndex     sizedim as Handle      hdim as Boolean     fromPrefs : fromPrefs = _falsedataRef = fn CFPrefsCopyAppValue( key )long if ( dataRef )long if (fn CFGetTypeID( dataRef) == fn CFDataGetTypeID() )size = fn CFDataGetLength( dataRef )h = fn NewHandle( size )long if ( h )CFDataGetBytes( dataRef, fn CFRangeMake( 0, size ), [h] )fromPrefs = _truevalue.nil& = hend ifend ifCFRelease( dataRef )end ifif ( fromPrefs == _false ) then value.nil& = 0end fn = fromPrefs// the Handle is unchanged by CFPrefsSetHandle()local fn CFPrefsSetHandle( key as CFStringRef, h as Handle )'~'1dim as pointer   p : p = [h]fn CFPrefsSetBytes( key, p, fn GetHandleSize( h ) )end fnlocal fn CFPrefsGetDate( key as CFStringRef, @value as ^double, default as double )'~'1dim as CFDateRef   dateRefdim as Boolean     fromPrefs : fromPrefs = _falsedateRef = fn CFPrefsCopyAppValue( key )long if ( dateRef )long if (fn CFGetTypeID( dateRef ) == fn CFDateGetTypeID() )value.nil# = fn CFDateGetAbsoluteTime( dateRef )fromPrefs = _trueend ifCFRelease( dateRef )end ifif ( fromPrefs == _false ) then value.nil# = defaultend fn = fromPrefslocal fn CFPrefsSetDate( key as CFStringRef, value as double )'~'1dim as CFDateRef   dateRefdateRef = fn CFDateCreate( 0, value )long if ( dateRef )fn CFPrefsSetAppValue( key, dateRef )CFRelease( dateRef )end ifend fn// 10.5local fn CFPrefsGetCGRect( key as CFStringRef, r as ^CGRect, default as ^CGRect )'~'1dim as CFDictionaryRef ÊÊdictdim as Boolean ÊÊÊÊÊÊÊÊÊÊfromPrefs : fromPrefs = _falsedict = fn CFPrefsCopyAppValue( key )long if ( dict )fromPrefs = fn CGRectMakeWithDictionaryRepresentation( dict, #r )CFRelease( dict )end ifif ( fromPrefs == _false ) then BlockMove( default, r, sizeof( CGRect ) )end fn = fromPrefs// 10.5local fn CFPrefsSetCGRect( key as CFStringRef, rPtr as ^CGRect )'~'1dim as CFDictionaryRef ÊÊdictdim as CGRect            r : r = rPtrdict = fn CGRectCreateDictionaryRepresentation( r )long if ( dict )fn CFPrefsSetAppValue( key, dict )CFRelease( dict )end ifend fn