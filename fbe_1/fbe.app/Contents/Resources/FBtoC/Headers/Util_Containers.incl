/*   Util_Containers.incl   Bernie Wylde 20081020   Update 20110929 bw: - ContainerCreateCFString now returns immutable string - Function added, ContainerCreateCFMutableString - Changed first param of ContainerCreateWithCFString from CFMutableStringRef to CFStringRef - Some calls to above functions changed   Brian 20170906 - updated to use pointers instead of Handles.*/'~Container to/from CFString//local fn ContainerCreateCFString( p as pointer ) as CFStringRef'~'1//dim as Handle   h :  h = [p]//end fn = fn CFStringCreateWithBytes( _kCFAllocatorDefault, #[h], fn GetHandleSize( h ), _kCFStringEncodingMacRoman, _false )// make these Containers.c functions available#if def _LP64toolbox fn CtnrRequestedSize( pointer ) = SInt64  toolbox fn FBNewContainer(SInt64 length) = pointer#elsetoolbox fn CtnrRequestedSize( pointer ) = UInt32  toolbox fn FBNewContainer(UInt32 length) = pointer#endiftoolbox CtnrFree( pointer )//ContainerCreateCFString - create a CFString from container's contentslocal fn ContainerCreateCFString( inPtr as pointer ) as CFStringRef'~'1dim as pointer   p :  p = [inPtr]end fn = fn CFStringCreateWithBytes( _kCFAllocatorDefault, #p, fn CtnrRequestedSize( #p ), _kCFStringEncodingMacRoman, _false )// ContainerCreateCFMutableString - create a mutable CFString from container's contentslocal fn ContainerCreateCFMutableString( p as pointer ) as CFMutableStringRef'~'1dim as CFStringRef          stringdim as CFMutableStringRef   mutString : mutString = NULLstring = fn ContainerCreateCFString( p )long if ( string )mutString = fn CFStringCreateMutableCopy( _kCFAllocatorDefault, 0, string )CFRelease( string )end ifend fn = mutString//ContainerCreateWithCFString - create a new container from string's contentsvoid local fn ContainerCreateWithCFString( string as CFStringRef, inPtr as pointer )'~'1dim as CFIndex   lengthdim as pointer   ptrToContainerlength = fn CFStringGetLength( string )ptrToContainer = [inPtr]if ( ptrToContainer ) then fn CtnrFree( ptrToContainer )ptrToContainer = fn FBNewContainer( length )inPtr.0& = ptrToContainerfn CFStringGetBytes( string, fn CFRangeMake( 0, length ), _kCFStringEncodingMacRoman, 0, _false, #ptrToContainer, length, #0 )end fn'~Container to/from pointer#if def _LP64// builds container from the pointervoid local fn ContainerFromPointer( myCont as pointer to pointer, p as pointer, size as SInt64 )'~'1 myCont.nil& = fn FBNewContainer( size )fn memmove( myCont.nil&, p, size )end fn#elsevoid local fn ContainerFromPointer( myCont as pointer to pointer, p as pointer, size as UInt32 )'~'1 myCont.nil& = fn FBNewContainer( size )fn memmove( myCont.nil&, p, size )end fn#endif// returns a pointer to a containerlocal fn ContainerToPointer( myCont as pointer to pointer ) as pointer'~'1dim as pointer pp = [myCont]end fn = p'~Find/*   ContainerFind*/local fn ContainerFind( p as pointer, stringToFind as CFStringRef, startLocation as CFindex, searchOptions as CFOptionFlags )'~'1dim as CFRange       rangedim as CFStringRef   stringrange.location = _kCFNotFoundstring = fn ContainerCreateCFString( p )long if ( string )fn CFStringFindWithOptions( string, stringToFind, fn CFRangeMake( startLocation, fn CFStringGetLength( string ) - startLocation ), searchOptions, @range )CFRelease( string )end ifend fn = range.locationlocal fn ContainerFindPascalString( p as pointer, find as Str255, startLocation as CFindex, searchOptions as CFOptionFlags )'~'1dim as CFStringRef   stringToFinddim as CFIndex       locationstringToFind = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, find, _kCFStringEncodingMacRoman )location = fn ContainerFind( p, stringToFind, startLocation, searchOptions )CFRelease( stringToFind )end fn = location/*   ContainerFindAndReplace*/local fn ContainerFindAndReplace( p as pointer, stringToFind as CFStringRef, replacementString as CFStringRef, rangeLocation as CFIndex, rangeLength as CFIndex, compareOptions as CFOptionFlags )'~'1dim as CFMutableStringRef   stringdim as CFIndex              count : count = 0string = fn ContainerCreateCFMutableString( p )long if ( string )count = fn CFStringGetLength( string )long if ( rangeLocation < count )if ( rangeLength == 0 ) then rangeLength = countif ( rangeLength > ( count - rangeLocation ) ) then rangeLength = count - rangeLocationcount = fn CFStringFindAndReplace( string, stringToFind, replacementString, fn CFRangeMake( rangeLocation, rangeLength ), compareOptions )fn ContainerCreateWithCFString( string, p )end ifCFRelease( string )end ifend fn = countlocal fn ContainerFindAndReplacePascalString( p as pointer, find as Str255, replace as Str255, rangeLocation as CFIndex, rangeLength as CFIndex, compareOptions as CFOptionFlags )'~'1dim as CFStringRef   stringToFind, replacementStringdim as CFIndex       countstringToFind = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, find, _kCFStringEncodingMacRoman )replacementString = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, replace, _kCFStringEncodingMacRoman )count = fn ContainerFindAndReplace( p, stringToFind, replacementString, rangeLocation, rangeLength, compareOptions )CFRelease( stringToFind )CFRelease( replacementString )end fn = count'~Replace/*   ContainerReplace*/void local fn ContainerReplace( p as pointer, rangeLocation as CFIndex, rangeLength as CFIndex, replacementString as CFStringRef )'~'1dim as CFMutableStringRef   stringdim as CFIndex              countstring = fn ContainerCreateCFMutableString( p )long if ( string )count = fn CFStringGetLength( string )long if ( rangeLocation < count )if ( rangeLength == 0 ) then rangeLength = countif ( rangeLength > ( count - rangeLocation ) ) then rangeLength = count - rangeLocationCFStringReplace( string, fn CFRangeMake( rangeLocation, rangeLength ), replacementString )fn ContainerCreateWithCFString( string, p )end ifCFRelease( string )end ifend fnvoid local fn ContainerReplacePascalString( p as pointer, rangeLocation as CFIndex, rangeLength as CFIndex, replacement as Str255 )'~'1dim as CFMutableStringRef   replacementStringreplacementString = (CFMutableStringRef)fn CFStringCreateWithPascalString( _kCFAllocatorDefault, replacement, _kCFStringEncodingMacRoman )long if ( replacementString )fn ContainerReplace( p, rangeLocation, rangeLength, replacementString )CFRelease( replacementString )end ifend fn'~Trim/*   ContainerTrim*/void local fn ContainerTrim( p as pointer, trimString as CFStringRef )'~'1dim as CFMutableStringRef   stringstring = fn ContainerCreateCFMutableString( p )long if ( string )CFStringTrim( string, trimString )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fnvoid local fn ContainerTrimPascalString( p as pointer, trim as Str255 )'~'1dim as CFStringRef   trimStringtrimString = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, trim, _kCFStringEncodingMacRoman )fn ContainerTrim( p, trimString )CFRelease( trimString )end fn/*   ContainerTrimSpace*/void local fn ContainerTrimSpace( p as pointer )'~'1fn ContainerTrim( p, @" " )end fn/*   ContainerTrimWhiteSpace*/void local fn ContainerTrimWhiteSpace( p as pointer )'~'1dim as CFMutableStringRef   stringstring = fn ContainerCreateCFMutableString( p )long if ( string )CFStringTrimWhiteSpace( string )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fn'~Uppercase/Lowercase/Capitalize/*   ContainerUppercase*/void local fn ContainerUppercase( p as pointer )'~'1dim as CFMutableStringRef   stringdim as CFLocaleRef          localeRefstring = fn ContainerCreateCFMutableString( p )long if ( string )localeRef = fn CFLocaleCopyCurrent()CFStringUppercase( string, localeRef )CFRelease( localeRef )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fn/*   ContainerLowercase*/void local fn ContainerLowercase( p as pointer )'~'1dim as CFMutableStringRef   stringdim as CFLocaleRef          localeRefstring = fn ContainerCreateCFMutableString( p )long if ( string )localeRef = fn CFLocaleCopyCurrent()CFStringLowercase( string, localeRef )CFRelease( localeRef )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fn/*   ContainerCapitalize*/void local fn ContainerCapitalize( p as pointer )'~'1dim as CFMutableStringRef   stringdim as CFLocaleRef          localeRefstring = fn ContainerCreateCFMutableString( p )long if ( string )localeRef = fn CFLocaleCopyCurrent()CFStringCapitalize( string, localeRef )CFRelease( localeRef )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fn'~Delete/Insert/Append/*   ContainerDelete*/void local fn ContainerDelete( p as pointer, rangeLocation as CFIndex, rangeLength as CFIndex )'~'1dim as CFMutableStringRef   stringdim as CFIndex              countstring = fn ContainerCreateCFMutableString( p )long if ( string )count = fn CFStringGetLength( string )long if ( rangeLocation < count )if ( rangeLength == 0 ) then rangeLength = countif ( rangeLength > ( count - rangeLocation ) ) then rangeLength = count - rangeLocationCFStringDelete( string, fn CFRangeMake( rangeLocation, rangeLength ) )fn ContainerCreateWithCFString( string, p )end ifCFRelease( string )end ifend fn/*   ContainerInsert*/void local fn ContainerInsert( p as pointer, index as CFIndex, insertString as CFStringRef )'~'1dim as CFMutableStringRef   stringdim as CFIndex              countstring = fn ContainerCreateCFMutableString( p )long if ( string )count = fn CFStringGetLength( string )if ( index >= count ) then index = countCFStringInsert( string, index, insertString )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fnvoid local fn ContainerInsertPascalString( p as pointer, index as CFIndex, insert as Str255 )'~'1dim as CFStringRef   insertStringinsertString = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, insert, _kCFStringEncodingMacRoman )fn ContainerInsert( p, index, insertString )CFRelease( insertString )end fn/*   ContainerAppend*/void local fn ContainerAppend( p as pointer, appendedString as CFStringRef )'~'1dim as CFMutableStringRef   stringstring = fn ContainerCreateCFMutableString( p )long if ( string )CFStringAppend( string, appendedString )fn ContainerCreateWithCFString( string, p )CFRelease( string )end ifend fnlocal fn ContainerAppendPascalString( p as pointer, appended as Str255 )'~'1dim as CFStringRef   appendedStringappendedString = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, appended, _kCFStringEncodingMacRoman )fn ContainerAppend( p, appendedString )CFRelease( appendedString )end fn'~Split/*   ContainerCreateDynamicArray*/void local fn ContainerCreateDynamicArray( p as pointer, separator as Str255, dynNum as UInt8 )'~'1dim as Str255        sdim as CFArrayRef    array : array = 0dim as CFStringRef   string, separatorString, tempdim as CFIndex       count, indexdim as pointer       basestring = fn ContainerCreateCFString( p )long if ( string )separatorString = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, separator, _kCFStringEncodingMacRoman )long if ( separatorString )array = fn CFStringCreateArrayBySeparatingStrings( _kCFAllocatorDefault, string, separatorString )long if ( array )count = fn CFArrayGetCount( array )long if ( count )BeginCCodeFBKillDynamicArray( dynNum );FBGrowDynamicArray( dynNum, count );base = gFBDynArrayInfo[dynNum].base;gFBDynArrayInfo[dynNum].lastElem = count - 1;EndCfor index = 0 to count - 1temp = fn CFArrayGetValueAtIndex( array, index )long if ( temp )long if ( fn CFStringGetPascalString( temp, @s, 256, _kCFStringEncodingMacRoman ) )BlockMoveData( @s, base, 256 )base += 256end ifend ifnext indexend ifCFRelease( array )end ifCFRelease( separatorString )end ifCFRelease( string )end ifend fn'~Read/Write URLvoid local fn ContainerWriteToURL( cPtr as ^ptr, url as CFURLRef )'~'1BeginCCodevoid *p = (void *)*cPtr;NSUInteger size = CtnrRequestedSize(p);NSData *data = [NSData dataWithBytes:p length:size];if ( data ) [data writeToURL:(NSURL *)url atomically:YES];EndCend fnvoid local fn ContainerReadFromURL( cPtr as ^ptr, url as CFURLRef )'~'1BeginCCodeNSData *data = [NSData dataWithContentsOfURL:(NSURL *)url];if ( data ) {     NSUInteger size = [data length];     void *p = malloc(size);     [data getBytes:p length:size];     ContainerFromPointer( cPtr, p, size );      free( p );}EndCend fn