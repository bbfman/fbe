begin record FileScanRecdim scanSpec  as FSSpec' 70 bytesdim ScanIndex as long' File Indexdim Type      as OSType' File TypeDIM Creator   as OSType' Creator Typedim DataLen   as long' Data Fork Sizedim RsrcLen   as long ' Resource Fork Sizedim CDate     as long' Creation Datedim MDate     as long' Modification Datedim BDate     as long' Backup Datedim FndrLoc   as long' Finder Locationdim FndrFlags as word' File Flagsdim FileAttr  as word' File Attributesdim recursive as word' True if recursive scanend record_ScanRecSize = sizeof(FileScanRec)#if def _FBtoC_ioFlUsrWdsFDFlagsKludge = _ioFlUsrWds + _FDFlags_ioDrUsrWdsFDLocationKludge = _ioDrUsrWds + _FDLocation_ioFlUsrWdsfdTypeKludge = _ioFlUsrWds + _fdType_ioFlUsrWdsfdcreatorKludge = _ioFlUsrWds + _fdcreator#endifclear localdim pb.128dim OSErr%dim @ sp as FileScanReclocal fn ScanFolder( @Fssptr as ^FileScanRec)'~'1sp = Fssptrsp.ScanIndex++pb.ioVRefNum%   = sp.scanSpec.vrefnumpb.ioDirID&     = sp.scanSpec.paridpb.ioNamePtr&   =@sp.scanSpec.namepb.ioFDirIndex% = sp.ScanIndexOSErr% = FN pbGETCATINFOsync( (ptr)@pb )long if OSErr% = _noErr#if def _FBtoCsp.FndrFlags = pb.ioFlUsrWdsFDFlagsKludge%#elsesp.FndrFlags = pb.ioFlUsrWds.FDFlags%#endifsp.FileAttr  = pb.ioFlAttrib`LONG IF (pb.ioFlAttrib` and 16)sp.Type  = _"fldr"sp.Creator   = _"----"// ******* New stuff for you to check *******#if def _FBtoCsp.FndrLoc   = pb.ioDrUsrWdsFDLocationKludge&#elsesp.FndrLoc   = pb.ioDrUsrWds.FDLocation&#endifsp.CDate     = pb.ioDrCrDat&sp.MDate     = pb.ioDrMdDat&sp.BDate     = pb.ioDrBkDat&sp.DataLen   = pb.ioDrNmFls% // number of files in directory!!!// ******* New stuff for you to check *******OSErr% = 1xelse#if def _FBtoC // workaround for bug #83sp.Type      = pb.ioFlUsrWdsfdTypeKludge&sp.Creator   = pb.ioFlUsrWdsfdcreatorKludge&sp.FndrLoc   = pb.ioDrUsrWdsFDLocationKludge&#elsesp.Type      = pb.ioFlUsrWds.fdType&sp.Creator   = pb.ioFlUsrWds.fdcreator&sp.FndrLoc   = pb.ioFlUsrWds.FDLocation&#endifsp.CDate     = pb.ioFlCrDat&sp.MDate     = pb.ioFlMdDat&sp.BDate     = pb.ioFlBkDat&sp.DataLen   = pb.ioFlLgLen&sp.RsrcLen   = pb.ioFlRLgLen&sp.FileAttr  = pb.ioFlAttrib`end iflong if sp.recursive'Date { 2/21/02 }sp.scanSpec.parID   = pb.ioDirID&sp.scanSpec.vRefNum = pb.ioVRefNum%end ifBlockMove @sp, Fssptr, _ScanRecSize end ifEND FN = OSErr%/* Return _zTrue if fs (file or folder) exists, else _false*/local fn FSFileExists( fs as ^FSSpec )'~'1dim as FSSpec tempSpecend fn = ( _noErr == fn FSMakeFSSpec( fs.vRefNum, fs.parID, fs.name, @tempSpec ) )local fn FileExists( name as Str255, vRefNum as short, dirID as long )'~'1dim as FSSpec tempSpecend fn = ( _noErr == fn FSMakeFSSpec( vRefNum, dirID, name, @tempSpec ) )_blockSize = 8192 'Buffer sizelocal modedim blockptr as ptrdim bytes&dim as short err,donelocal fn FBCopyFork( @srcPB as ptr, @dstPB as ptr )'~'1blockptr = fn newptrclear(_blockSize) 'Data buffersrcPB.ioPosOffset& = 0dstPB.ioPosOffset& = 0srcPB.ioPosMode%   = 0dstPB.ioPosMode%   = 0done = _FalsedosrcPB.ioReqCount& =_blockSizesrcPB.ioBuffer&   = blockptrerr = fn pbREADsync(srcPB)'Read from sourcebytes& = srcPB.ioActCount&if err = _eoferr then done = _zTrue : err = _noErrlong if err = _noErrlong if bytes&dstPB.ioReqCount& = bytes&'Write actual bytes readdstPB.ioBuffer&   = blockptrerr = fn pbWritesync(dstPB)end ifend ifuntil done or errdisposeptr(blockptr)'dump data bufferfn pbclosesync(srcPB)'Close Sourcefn pbclosesync(dstPB)'Close Destend fn = errclear local modedim @sVol%,dvol%,sDir&,dDir&dim srcPB.128dim dstPB.128dim as short errdim FndrInfo.16dim crDate&,mdDate&local fn CopyFile(SrcName$,SrcVol%,SrcDir&,DesName$,DstVol%,DstDir&)'~'1sVol% = SrcVol% : sDir& = SrcDir&srcPB.ioVRefNum%   = sVol%srcPB.ioWDDirID&   = sDir&srcPB.ioNamePtr&   = @SrcName$err = fn PBHGetFInfoSync( (ptr)@srcPB )long if err = _noErrFndrInfo;16 = @srcPB.ioFlUsrWds%'Save File InfocrDate&     = srcPB.ioFlCrDat&mdDate&     = srcPB.ioFlMdDat&'~'1dVol% = DstVol% : dDir& = DstDir&srcPB.ioVRefNum% = sVol%srcPB.ioWDDirID& = sDir&srcPB.ioNamePtr& = @SrcName$srcPB.ioPermssn` =_fsRdPermerr = fn pbhopensync( (ptr)@srcPB )long if err = _noErrdstPB.ioVRefNum% = dVol%dstPB.ioWDDirID& = dDir&dstPB.ioNamePtr& = @DesName$dstPB.ioPermssn` =_fsWrPermfn pbhdeletesync( (ptr)@dstPB )fn pbhcreatesync( (ptr)@dstPB )err = fn pbhopensync( (ptr)@dstPB )long if err = _noErrfn FBCopyFork(srcPB,dstPB)xelsefn pbclosesync( (ptr)@srcPB )end ifend if'~'1srcPB.ioVRefNum% = sVol%srcPB.ioWDDirID& = sDir&srcPB.ioNamePtr& = @SrcName$srcPB.ioPermssn` =_fsRdPermerr = fn PBHOpenRFSync( (ptr)@srcPB )long if err = _noErrdstPB.ioVRefNum% = dVol%dstPB.ioWDDirID& = dDir&dstPB.ioNamePtr& = @DesName$dstPB.ioPermssn` =_fsWrPermerr = fn PBHOpenRFSync( (ptr)@dstPB )long if err = _noErrerr = fn FBCopyFork(srcPB,dstPB)xelsefn pbclosesync( (ptr)@srcPB )end ifxelseerr = _noErrend if'~'1long if err = _noErrdstPB.ioFVersNum`    = 0dstPB.ioFDirIndex%   = 0dstPB.ioVRefNum%     = dVol%dstPB.ioWDDirID&     = dDir&dstPB.ioNamePtr&     = @DesName$fn PBHGetFInfoSync( (ptr)@dstPB )dstPB.ioFlUsrWds%;16 = @FndrInfo'Make a duplicate of Source...dstPB.ioFlCrDat&     = crDate&dstPB.ioFlMdDat&     = mdDate&dstPB.ioVRefNum%     = dVol%dstPB.ioWDDirID&     = dDir&dstPB.ioNamePtr&     = @DesName$err = fn PBHSetFInfoSync( (ptr)@dstPB )end if'~'1end ifend fn = err/*// fn MoveFile commented out to allow Editor source to build with FBtoC 5.7.99//    it would fail because this uses the old 'rename' syntax// The editor does not call this fn. // The newer 'rename' uses modern code to implement a file move. See latest FileHandle.c in build goodies. Brian 20170310clear local modedim @sVol%,dVol%,sDir&,dDir&DIM MovePBRec.128dim oldName$dim as short err,n,sLenlocal fn MoveFile(SrcName$,SrcVol%,SrcDir&,DstVol%,DstDir&)'~'1sVol% = SrcVol% : sDir& = SrcDir&dVol% = DstVol% : dDir& = DstDir&oldName$ = SrcName$while fn FileExists(oldName$,DstVol%,DstDir&)long if n = 0sLen = len(oldName$) : if slen > 29 then sLen = 29end ifn++oldName$ = left$(oldName$,sLen) + str$(n)wendlong if nrename SrcName$,oldName$,dVol%,dDir&end ifMovePBRec.ioNamePtr&  = @SrcName$MovePBRec.ioVRefNum%  =  sVol%MovePBRec.ioDirID&    =  sDir&MovePBRec.ioNewDirID&  = dDir&err = FN PBCatMoveSync( (ptr)@MovePBRec )end fn = err*//*local modedim OriginalLen,Renamedruntime USR MakeUniqueFileName(@OldNamePtr&,@NewNamePtr&,@x&,limit,vol%,dir&)'~'1NewNamePtr&.nil$ = OldNamePtr&.nil$'Copy Original nameRenamed          = _False'False and Zerowhile usr FileExists(NewNamePtr&.nil$,vol%,dir&)long if Renamed <= 99 and (Renamed or len(x&.nil$) = 0)Renamed++OriginalLen = len(OldNamePtr&.nil$)if OriginalLen > limit-(len(x&.nil$)+3) then OriginalLen = limit-(len(x&.nil$)+3)NewNamePtr&.nil$ = left$(OldNamePtr&.nil$,OriginalLen)+x&.nil$+STR$(Renamed)xelseOriginalLen = len(OldNamePtr&.nil$)if OriginalLen > limit-len(x&.nil$) then OriginalLen = limit-len(x&.nil$)NewNamePtr&.nil$ = left$(OldNamePtr&.nil$,OriginalLen)+x&.nil$Renamed = 1end ifwendend fn = Renamed'Return Vers or _False if not Renamed*//* this takes a wdRefNum and will not be implemented in FBtoCLOCAL ModeDIM myFileSpec as FSSpecDIM osErr%runtime usr SendFileToTrash(fName$,wdRefnum%)'~'1osErr%    =  fn FBMakeFSSpec(wdRefnum%,0,fName$,myFileSpec)if osErr% = _noErr then osErr% = usr FSSendFileToTrash(myFileSpec)End FN = osErr%*/clear local modedim pb.128dim @dir&,vol%local fn getFolderName(inVol%,inDir&,@theNamePtr as ptr )'~'1vol% = inVol% : dir& = inDir&pb.ioDirID&     = dir&pb.ioVRefNum%   = vol%pb.ioFDirIndex% = -1pb.ioNamePtr&   = theNamePtrend fn = FN PBGetCatInfoSync( (ptr)@pb )clear local modedim as OSErr OSErrdim pb.128dim DirectoryName$dim @dir&,vol%local fn GetFullPathName(inVol%,inDir&,@FullNamePtr as ptr )'~'1vol% = inVol% : dir& = inDir&FullNamePtr.nil$ = ""pb.ioNamePtr&     = @DirectoryName$dopb.ioVRefNum%   = vol%pb.ioDirID&     = dir&pb.ioFDirIndex% = -1OSErr = FN PBGetCatInfoSync( (ptr)@pb )FullNamePtr.nil$ = DirectoryName$ + ":" + FullNamePtr.nil$dir&  = pb.ioDrParID&until OSErr or (pb.ioDirID& == 2)end fn = OSErrlocal fn FSGetFolderName(fs as ^fsspec,@nameptr&)'~'1end fn = fn GetFolderName(fs.vrefnum,fs.parid,#nameptr&)local fn FSGetFullPathName(fs as ^fsspec,@nameptr&)'~'1end fn = fn GetFullPathName(fs.vrefnum,fs.parid,#nameptr&)/* Trash a file or folder by sending an AE to the Finder. This method transparently accomplishes renaming so that duplicates have unique names in Trash.  It also ensures that the Trash icon is updated. Returns an error code, for example:  _noErr (0)          trash succeeded  _fLckdErr (-45)     file locked  errAEEventFailed (-10000)*/// AERegistry.h_kAEDelete          = _"delo"_kAEWaitReply       =  3_keyErrorNumber     = _"errn"_errAEDescNotFound  = -1701local modelocal fn FSSendFileToTrash( sourceObj as ^FSSpec )'~'1dim as OSErr      errdim as OSType   @ creatordim as AEDesc     addrDesc, theAE, replydim as long     @ replyErrcreator = _"MACS"err = fn AECreateDesc( _typeApplSignature, @creator, sizeof( OSType ), @addrDesc )if ( err ) then exit fnerr = fn AECreateAppleEvent( _kAECoreSuite, _kAEDelete, addrDesc, _kAutoGenerateReturnID, _kAnyTransactionID, theAE )fn AEDisposeDesc( addrDesc )if ( err ) then exit fnerr = fn AECreateDesc( _typeFSS, #sourceObj, sizeof( FSSpec ), @addrDesc )if ( err == _noErr ) then err = fn AEPutParamDesc( theAE, _keyDirectObject, addrDesc )fn AEDisposeDesc( addrDesc )long if ( err == _noErr ) err = fn AESend( theAE, reply, _kAEWaitReply + _kAENeverInteract, _kAENormalPriority, _kAEDefaultTimeout, 0, 0 )long if ( err == _noErr ) // AESend worked; check Finder's reply// see if Finder specified an error (replyErr) in the replyerr = fn AEGetParamPtr( reply, _keyErrorNumber, _typeLongInteger, #0, @replyErr, sizeof( long ), #0 ) long if ( err == _errAEDescNotFound ) or ( replyErr == _noErr ) // no replyErr found, or replyErr was _noErr...err = _noErr // ... means successxelseerr = replyErr // FSpTrashObject's return code is the Finder error end ifend iffn AEDisposeDesc( reply )end iffn AEDisposeDesc( theAE )end fn = err