/*Util_MouseTracking.inclA simplified method to implement cursor-change over edit fields, text controls and text windows.The MouseTrackingRegion API is used on 10.3, and HIViewTrackingArea in 10.4+fn MTAutoTextCursorForControl( c as ControlRef ) as OSStatussets _kThemeIBeamCursor or _kThemeArrowCursor as appropriate when the cursor enters or leaves the text control.The control may be an edit field, an EUTC appearance button, or an HITextView.fn MTAutoTextCursorForControlWithOptions( c as ControlRef, enterCursor as ThemeCursor, exitCursor as ThemeCursor )allows the cursors to be specified. This might be used with _kThemePointingHandCursor, _kThemeArrowCursor for a push button.fn MTAutoTextCursorForWindow( w as WindowRef ) as OSStatussets _kThemeIBeamCursor or _kThemeArrowCursor as appropriate when the cursor enters or leaves the window.Two other functions are for aficionados of the MouseTrackingRegion:  fn MTMakeMouseTrackingRegionForEditTextPartOfControl( c as ControlRef ) as MouseTrackingRef  fn MTMakeMouseTrackingRegionForWindowContentRegion( w as WindowRef ) as MouseTrackingRefKNOWN BUGS- in a compositing window in OS X 10.3, MTAutoTextCursorForControl() does nothing - in a compositing window in OS X 10.4+, the boundary of the cursor-change region    set by MTAutoTextCursorForControl() is slightly outset from the text region.   This cosmetic bug seems to be in Carbon.rp 20090221*/ include "Tlbx HIView.incl"// privatelocal modelocal fn MTWindowTrackingRegionHandler_priv( nextHandler as EventHandlerCallRef, theEvent as EventRef, userData as ptr )'~'1dim as Boolean           reactdim as ControlRef        cdim as WindowRef         wdim as WindowAttributes  wadim as MouseTrackingRef  trackRefdim as MouseTrackingRegionID trackIDnextHandler = 0 // suppress gcc warning: unused parameter long if ( userData ) // call set by MTMakeMouseTrackingRegionForEditTextPartOfControl()c = userDatareact = fn IsControlVisible( c )w = fn GetControlOwner( c ) if ( react ) then react = ( fn FrontWindow() == w ) // ignore unless frontlong if ( react )fn GetWindowAttributes( w, @wa )react = (wa and _kWindowCompositingAttribute) == 0 // do nothing if compositing (for which MouseTrackingRegion stuff is no good)end ifxelse // call set by MTMakeMouseTrackingRegionForWindowContentRegion()react = _zTrueend iflong if ( react )fn GetEventParameter( theEvent, _kEventParamMouseTrackingRef, _typeMouseTrackingRef, #0, sizeof( MouseTrackingRef ), #0, @trackRef )fn GetMouseTrackingRegionID( trackRef, @trackID )select fn GetEventKind( theEvent ) // EventClass is _kEventClassMousecase _kEventMouseEntered : fn SetThemeCursor( trackID.id ) case _kEventMouseExited  : fn SetThemeCursor( trackID.signature )end selectend ifend fn = _noErr// privatelocal modelocal fn MTHITrackingAreaHandler_priv( nextHandler as EventHandlerCallRef, theEvent as EventRef, c as ControlRef )'~'1dim as UInt64  id : id = 0 // HIViewTrackingAreaIDnextHandler = 0 // suppress gcc warning: unused parameter long if ( fn IsControlVisible( c ) )long if ( fn FrontNonFloatingWindow() == fn GetControlOwner( c ) ) // ignore unless frontbeginCCode#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_3HIViewTrackingAreaRef area;GetEventParameter( theEvent, kEventParamHIViewTrackingArea, typeHIViewTrackingAreaRef, NULL, sizeof( HIViewTrackingAreaID ), NULL, &area );HIViewGetTrackingAreaID( area, &id );#endifendClong if ( id )select fn GetEventKind( theEvent ) // EventClass is _kEventClassControlcase _kEventControlTrackingAreaEntered : fn SetThemeCursor( id >> 32 )case _kEventControlTrackingAreaExited  : fn SetThemeCursor( id and 0xFFFFFFFF )end selectend ifend ifend ifend fn = _noErr/* A wrapper making it easy to call CreateMouseTrackingRegion. Returns a MouseTrackingRef (often ignored by the caller).*/local modelocal fn MTMakeMouseTrackingRegionForControl( c as ControlRef, part as ControlPartCode, enterCursor as ThemeCursor, exitCursor as ThemeCursor ) as MouseTrackingRef'~'1dim as RgnHandle             controlRegiondim as MouseTrackingRegionID trackIDdim as MouseTrackingRef      trackRefcontrolRegion = fn NewRgn()fn GetControlRegion( c, part, controlRegion )trackID.signature = exitCursortrackID.id        = enterCursorlong if ( _noErr !=  fn CreateMouseTrackingRegion( fn GetControlOwner( c ), controlRegion, 0, _kMouseTrackingOptionsStandard, trackID, c, 0, @trackRef ) )trackRef = 0end ifDisposeRgn( controlRegion )end fn = trackRef/* A wrapper making it easy to call CreateMouseTrackingRegion. Returns a MouseTrackingRef (often ignored by the caller).*/local modelocal fn MTMakeMouseTrackingRegionForWindowContentRegion( w as WindowRef ) as MouseTrackingRef'~'1dim as RgnHandle             contentRegiondim as MouseTrackingRegionID trackIDdim as MouseTrackingRef      trackRefcontentRegion = fn NewRgn()fn GetWindowRegion( w, _kWindowContentRgn, contentRegion )trackID.signature = _kThemeArrowCursortrackID.id        = _kThemeIBeamCursorlong if ( _noErr !=  fn CreateMouseTrackingRegion( w, contentRegion, 0, _kMouseTrackingOptionsStandard, trackID, 0, 0, @trackRef ) )trackRef = 0end ifDisposeRgn( contentRegion )end fn = trackRef// returns an error code (0 == _noErr)local modelocal fn MTAutoCursorForControlWithOptions( c as ControlRef, part as ControlPartCode, enterCursor as ThemeCursor, exitCursor as ThemeCursor ) as OSStatus'~'1dim as EventTypeSpec  evnt(1)dim as OSStatus       result : result = _paramErrdim as UInt64         id // HIViewTrackingAreaIDlong if ( system( _sysVers ) >= 1040 ) // HIViewNewTrackingArea() is availableid = enterCursorid = (id << 32) + exitCursorbeginCCode#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_3result = HIViewNewTrackingArea( c, NULL, id, NULL );#endifendClong if ( result == _noErr )// install our handler on the control, for the two relevant control eventsevnt.eventClass(0) = _kEventClassControl : evnt.eventKind(0) = _kEventControlTrackingAreaEnteredevnt.eventClass(1) = _kEventClassControl : evnt.eventKind(1) = _kEventControlTrackingAreaExitedresult = fn InstallEventHandler( fn GetControlEventTarget( c ), @fn MTHITrackingAreaHandler_priv, 2, @evnt(0), #c, #0 )end ifend iflong if ( result )// MouseTrackingRegion (works in 10.2-10.5 but deprecated in 10.5)long if ( 0 != fn MTMakeMouseTrackingRegionForControl( c, part, enterCursor, exitCursor ) )// install our handler on the owning window, for the two relevant mouse eventsevnt.eventClass(0) = _kEventClassMouse : evnt.eventKind(0) = _kEventMouseEnteredevnt.eventClass(1) = _kEventClassMouse : evnt.eventKind(1) = _kEventMouseExitedresult = fn InstallEventHandler( fn GetWindowEventTarget( fn GetControlOwner( c ) ), @fn MTWindowTrackingRegionHandler_priv, 2, @evnt(0), #c, #0 )end ifend ifend fn = result// returns an error code (0 == _noErr)local modelocal fn MTAutoTextCursorForControl( c as ControlRef ) as OSStatus'~'1end fn = fn MTAutoCursorForControlWithOptions( c, _kControlEditTextPart, _kThemeIBeamCursor, _kThemeArrowCursor )// returns an error code (0 == _noErr)local modelocal fn MTAutoTextCursorForWindow( w as WindowRef ) as OSStatus'~'1dim as HIViewRef      contentViewdim as OSStatus       result : result = _paramErrdim as EventTypeSpec  evnt(1)long if ( system( _sysVers ) >= 1040 ) fn HIViewFindByID( fn HIViewGetRoot( w ), kHIViewWindowContentID, @contentView )result = fn MTAutoTextCursorForControl( contentView )end iflong if ( result )long if ( 0 != fn MTMakeMouseTrackingRegionForWindowContentRegion( w ) )// install our handler on the window, for the two relevant mouse eventsevnt.eventClass(0) = _kEventClassMouse : evnt.eventKind(0) = _kEventMouseEnteredevnt.eventClass(1) = _kEventClassMouse : evnt.eventKind(1) = _kEventMouseExitedresult = fn InstallEventHandler( fn GetWindowEventTarget( w ), @fn MTWindowTrackingRegionHandler_priv, 2, @evnt(0), #0, #0 )end ifend ifend fn = result