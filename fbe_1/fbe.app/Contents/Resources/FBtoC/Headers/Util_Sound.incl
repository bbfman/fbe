/*   Util_Sound.incl   Bernie Wylde 20170925   1.0.0*/BeginCDeclaration#import <objc/runtime.h>@interface SoundDelegate : NSObject <NSSoundDelegate> {     NSMutableArray *sounds;}@property (retain) NSMutableArray *sounds;@end@interface NSSound (Additions)@property (nonatomic,retain) NSNumber *tagNumber;@property (nonatomic,retain) NSNumber *isPausedNumber;- (NSInteger)tag;- (void)setTag:(NSInteger)tag;- (BOOL)isPaused;- (void)setIsPaused:(BOOL)flag;@endNSSound *SoundWithTag( SInt32 inTag );NSSound *SoundWithName( NSString *name );// publicBoolean SoundInit( SInt32 inTag, CFStringRef inName, CFTypeRef inSrc );//Boolean SoundCanInitWithPasteboard( void *pb );CFStringRef SoundName( SInt32 tag );void SoundSetName( SInt32 tag, CFStringRef name );float SoundVolume( SInt32 tag );void SoundSetVolume( SInt32 tag, float value );CFTimeInterval SoundCurrentTime( SInt32 tag );void SoundSetCurrentTime( SInt32 tag, CFTimeInterval value );Boolean SoundLoops( SInt32 tag );void SoundSetLoops( SInt32 tag, Boolean flag );CFStringRef SoundPlaybackDeviceIdentifier( SInt32 tag );CFArrayRef SoundUnfilteredTypes();//SInt32 SoundNamed( CFStringRef name );CFTimeInterval SoundDuration( SInt32 tag );Boolean SoundIsPlaying( SInt32 tag );Boolean SoundIsPaused( SInt32 tag );Boolean SoundPause( SInt32 tag );Boolean SoundPlay( SInt32 tag );Boolean SoundResume( SInt32 tag );Boolean SoundStop( SInt32 tag );//void SoundWriteToPasteboard( SInt32 tag, void *pb );// customvoid SoundRelease( SInt32 tag );EndCBeginCFunction@implementation SoundDelegate@synthesize sounds;- (void)dealloc {Ê [sounds release];Ê [super dealloc];}- (void)sound:(NSSound *)sound didFinishPlaying:(BOOL)flag {     CallUserDefinedOnDialogFunction( soundDidFinishPlaying, [sound tag], flag );}@endSoundDelegate *SoundDelegateObj(){    static SoundDelegate *sSoundDelegate = nil;    if ( !sSoundDelegate ) sSoundDelegate = [[SoundDelegate alloc] init];    return sSoundDelegate;}@implementation NSSound (Additions)@dynamic tagNumber;@dynamic isPausedNumber;- (NSInteger)tag {    return [objc_getAssociatedObject(self, @selector(tagNumber)) integerValue];}- (void)setTag:(NSInteger)tag {    objc_setAssociatedObject(self, @selector(tagNumber), [NSNumber numberWithInteger:tag], OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (BOOL)isPaused {    return [objc_getAssociatedObject(self, @selector(isPausedNumber)) boolValue];}- (void)setIsPaused:(BOOL)flag {    objc_setAssociatedObject(self, @selector(isPausedNumber), [NSNumber numberWithBool:flag], OBJC_ASSOCIATION_RETAIN_NONATOMIC);}@endNSSound *SoundWithTag( SInt32 tag ){     SoundDelegate *delegate = SoundDelegateObj();     if ( delegate.sounds ) {          for ( NSSound *snd in delegate.sounds ) {               if ( [snd tag] == tag ) return snd;          }     }     return nil;}NSSound *SoundWithName( NSString *name ){     SoundDelegate *delegate = SoundDelegateObj();     if ( delegate.sounds ) {          for ( NSSound *snd in delegate.sounds ) {               if ( [[snd name] isEqualToString:name] ) return snd;          }     }     return nil;}// publicBoolean SoundInit( SInt32 inTag, CFStringRef inName, CFTypeRef inSrc ){     NSString *name = (NSString *)inName;     NSSound *snd = SoundWithTag( inTag );     if ( snd ) SoundRelease( inTag );     if ( inSrc ) {          if ( CFGetTypeID( inSrc ) == CFURLGetTypeID() ) {               snd = [[NSSound alloc] initWithContentsOfURL:(NSURL *)inSrc byReference:YES];               if ( !name ) name = [[(NSURL *)inSrc URLByDeletingPathExtension] lastPathComponent];               [snd setName:name];          } else if ( CFGetTypeID( inSrc ) == CFDataGetTypeID() ) {               snd = [[NSSound alloc] initWithData:(NSData *)inSrc];               if ( name ) [snd setName:name];          } else {               // ...          }     } else {          if ( name ) snd = [NSSound soundNamed:name];     }     if ( snd ) {          [snd setTag:inTag];          SoundDelegate *delegate = SoundDelegateObj();          [snd setDelegate:delegate];          if ( !delegate.sounds ) delegate.sounds = [NSMutableArray arrayWithCapacity:0];          [delegate.sounds addObject:snd];          [snd release];          return YES;     }     return NO;}/*Boolean SoundCanInitWithPasteboard( void *pb ){ return [NSSound canInitWithPasteboard:(NSPasteboard *)pb]; }*/CFStringRef SoundName( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return (CFStringRef)[snd name];     return NULL;}void SoundSetName( SInt32 tag, CFStringRef name ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) [snd setName:(NSString *)name];}float SoundVolume( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd volume];     return 0.0;}void SoundSetVolume( SInt32 tag, float value ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) [snd setVolume:value];}CFTimeInterval SoundCurrentTime( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd currentTime];     return 0.0;}void SoundSetCurrentTime( SInt32 tag, CFTimeInterval value ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) [snd setCurrentTime:value];}Boolean SoundLoops( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd loops];     return NO;}void SoundSetLoops( SInt32 tag, Boolean flag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) [snd setLoops:flag];}CFStringRef SoundPlaybackDeviceIdentifier( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return (CFStringRef)[snd playbackDeviceIdentifier];     return NULL;}CFArrayRef SoundUnfilteredTypes(){ return (CFArrayRef)[NSSound soundUnfilteredTypes]; }/*SInt32 SoundNamed( CFStringRef name ){     NSSound *snd = SoundWithName( (NSString *)name );     if ( snd ) {          return [snd tag];     } else {          snd = [NSSound soundNamed:(NSString *)name];                    if ( snd ) {               [snd setTag:inTag];               SoundDelegate *delegate = SoundDelegateObj();               [snd setDelegate:delegate];               if ( !delegate.sounds ) delegate.sounds = [[NSMutableArray alloc] initWithCapacity:0];               [delegate.sounds addObject:snd];          }     }     return 0;}*/CFTimeInterval SoundDuration( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd duration];     return 0.0;}Boolean SoundIsPlaying( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd isPlaying];     return NO;}Boolean SoundIsPaused( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd isPaused];     return NO;}Boolean SoundPause( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) {          if ( [snd pause] ) {               [snd setIsPaused:YES];                         return YES;          }     }     return NO;}Boolean SoundPlay( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) return [snd play];     return NO;}Boolean SoundResume( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) {          if ( [snd resume] ) {               [snd setIsPaused:NO];               return YES;          }     }     return NO;}Boolean SoundStop( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) {          if ( [snd stop] ) {               [snd setIsPaused:NO];               return YES;          }     }     return NO;}/*void SoundWriteToPasteboard( SInt32 tag, void *pb ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) [snd writeToPasteboard:(NSPasteboard *)pb];}*/// customvoid SoundRelease( SInt32 tag ){     NSSound *snd = SoundWithTag( tag );     if ( snd ) {          if ( [snd isPlaying] ) [snd stop];          SoundDelegate *delegate = SoundDelegateObj();          [delegate.sounds removeObject:snd];     }}EndCbegin enum output 2000_soundDidFinishPlayingend enumtoolbox fn SoundInit( SInt32 tag, CFStringRef name, CFTypeRef src ) = Boolean//toolbox fn SoundCanInitWithPasteboard( ptr pb ) = Booleantoolbox fn SoundName( SInt32 tag ) = CFStringReftoolbox SoundSetName( SInt32 tag, CFStringRef name )toolbox fn SoundVolume( SInt32 tag ) = floattoolbox SoundSetVolume( SInt32 tag, float value )toolbox fn SoundCurrentTime( SInt32 tag ) = CFTimeIntervaltoolbox SoundSetCurrentTime( SInt32 tag, CFTimeInterval value )toolbox fn SoundLoops( SInt32 tag ) = Booleantoolbox SoundSetLoops( SInt32 tag, Boolean flag )toolbox fn SoundPlaybackDeviceIdentifier( SInt32 tag ) = CFStringReftoolbox fn SoundUnfilteredTypes = CFArrayRef//toolbox fn SoundNamed( CFStringRef name ) = SInt32toolbox fn SoundDuration( SInt32 tag ) = CFTimeIntervaltoolbox fn SoundIsPlaying( SInt32 tag ) = Booleantoolbox fn SoundIsPaused( SInt32 tag ) = Booleantoolbox fn SoundPause( SInt32 tag ) = Booleantoolbox fn SoundPlay( SInt32 tag ) = Booleantoolbox fn SoundResume( SInt32 tag ) = Booleantoolbox fn SoundStop( SInt32 tag ) = Boolean//toolbox SoundWriteToPasteboard( SInt32 tag, ptr pb )// customtoolbox SoundRelease( SInt32 tag )