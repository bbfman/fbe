/*  Util_String.incl  InString, RightString, LeftString, MidString, HexString - Brian 20170428  Others - Bernie 20140424  v1.0.2*/include "StringUtils.h"include "StringUtils.m" #if ndef _DEFINEDINCARBON#define NSInteger as SInt64#endifsystem NSInteger NSNotFound // fn InString returns this when search string isn't found. This is different from FB's INSTR. See below note./*N.B. for fn InString: [1] Because CFStrings start at position zero, returning a ZERO position is a valid value and different from FB's INSTR which returns zero for not found      Pascal strings start at position one ( with position zero the length byte )  [2] Replaces FB's INSTR but check to make sure the logic does not rely on a zero return for not found.  [3] fn InString returns NSNotFound for not found. NSNotFound can be different values depending on where it runs, so use the constant and not a hard-coded number. Brian 20151011*/toolbox fn InString(  SInt32 startPos,  CFStringRef strToSearch, CFStringRef strToSearchFor ) = SInt64/*CF equivalent string functions for FB's:FB               CF--------------------------------right$           fn RightStringleft$            fn LeftStringmid$             fn MidStringhex$             fn HexStringBrian 20160707*/toolbox fn RightString( CFStringRef inString, CFIndex howManyChars ) = CFStringRef toolbox fn LeftString( CFStringRef inString, CFIndex toIndex ) = CFStringRef toolbox fn MidString( CFStringRef inString , CFIndex startPos, CFIndex howManyChars ) = CFStringReftoolbox fn HexString( SInt32 num ) = CFStringRefBeginCDeclarationCFMutableStringRef StringWithCapacity( UInt32 capacity );CFStringRef StringWithFormat( CFStringRef format, ... );CFStringRef StringWithContentsOfURL( CFURLRef url );Boolean StringWriteToURL( CFStringRef string, CFURLRef url, Boolean atomically, UInt32 encoding );CFStringRef StringSubstringFromIndex( CFStringRef string, CFIndex index );CFStringRef StringSubstringWithRange( CFStringRef string, CFRange range );CFStringRef StringSubstringToIndex( CFStringRef string, CFIndex index );CFStringRef StringByAppendingFormat( CFStringRef string, CFStringRef format, ... );CFStringRef StringByAppendingString( CFStringRef string1, CFStringRef string2 );CFStringRef StringByPaddingToLength( CFStringRef string, UInt32 newLength, CFStringRef padString, UInt32 padIndex );#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1090Boolean StringContainsString( CFStringRef string1, CFStringRef string2 );#endifCFTypeRef StringPropertyList( CFStringRef string );EndCBeginCFunctionCFMutableStringRef StringWithCapacity( UInt32 capacity ){ return (CFMutableStringRef)[NSMutableString stringWithCapacity:capacity]; }CFStringRef StringWithFormat( CFStringRef format, ... ){     va_list ap;     va_start( ap, format );     NSString *string = [[[NSString alloc] initWithFormat:(NSString *)format arguments:ap] autorelease];     va_end( ap );     return (CFStringRef)string;}CFStringRef StringWithContentsOfURL( CFURLRef url ){ return (CFStringRef)[NSString stringWithContentsOfURL:(NSURL *)url]; }Boolean StringWriteToURL( CFStringRef string, CFURLRef url, Boolean atomically, UInt32 encoding ){ return [(NSString *)string writeToURL:(NSURL *)url atomically:atomically encoding:CFStringConvertEncodingToNSStringEncoding(encoding) error:nil]; }CFStringRef StringSubstringFromIndex( CFStringRef string, CFIndex index ){ return (CFStringRef)[(NSString *)string substringFromIndex:index]; }CFStringRef StringSubstringWithRange( CFStringRef string, CFRange range ){ return (CFStringRef)[(NSString *)string substringWithRange:NSMakeRange(range.location,range.length)]; }CFStringRef StringSubstringToIndex( CFStringRef string, CFIndex index ){ return (CFStringRef)[(NSString *)string substringToIndex:index]; }CFStringRef StringByAppendingFormat( CFStringRef string, CFStringRef format, ... ){     va_list ap;     va_start( ap, format );     NSString *formattedString = [[NSString alloc] initWithFormat:(NSString *)format arguments:ap];     NSString *outString = [(NSString *)string stringByAppendingString:formattedString];     [formattedString release];     va_end( ap );     return (CFStringRef)outString;}CFStringRef StringByAppendingString( CFStringRef string1, CFStringRef string2 ){ return (CFStringRef)[(NSString *)string1 stringByAppendingString:(NSString *)string2]; }CFStringRef StringByPaddingToLength( CFStringRef string, UInt32 newLength, CFStringRef padString, UInt32 padIndex ){ return (CFStringRef)[(NSString *)string stringByPaddingToLength:newLength withString:(NSString *)padString startingAtIndex:padIndex]; }#if __MAC_OS_X_VERSION_MAX_ALLOWED > 1090Boolean StringContainsString( CFStringRef string1, CFStringRef string2 ){ return [(NSString *)string1 containsString:(NSString *)string2]; }#endifCFTypeRef StringPropertyList( CFStringRef string ){ return (CFTypeRef)[(NSString *)string propertyList]; }EndC/*  StringWithCapacity( capacity )  Returns an empty CFMutableString object with initial storage for a given number of characters.  Params:    capacity - The number of characters the string is expected to initially contain.  Return value: An empty, autoreleased CFMutableString object with initial storage for capacity characters.*/toolbox fn StringWithCapacity( UInt32 capacity ) = CFMutableStringRef/*  StringWithFormat( format, ... )  Returns a string created by using a given format string as a template into which the remaining argument values are substituted.*/toolbox fn StringWithFormat( CFStringRef format, ... ) = CFStringRef/*  StringWithContentsOfURL( url )  Returns a string created by reading data from the file named by a given URL.*/toolbox fn StringWithContentsOfURL( CFURLRef url ) = CFStringRef/*  StringWriteToURL( string, url, atomically, encoding )  Writes the contents of the receiver to the URL specified by url using the specified encoding.*/toolbox fn StringWriteToURL( CFStringRef string, CFURLRef url, Boolean atomically, UInt32 encoding ) = Boolean/*  StringSubstringFromIndex( string, index )*/toolbox fn StringSubstringFromIndex( CFStringRef string, CFIndex index ) = CFStringRef/*  StringSubstringWithRange( string, range )*/toolbox fn StringSubstringWithRange( CFStringRef string, CFRange range ) = CFStringRef/*  StringSubstringToIndex( string, index )*/toolbox fn StringSubstringToIndex( CFStringRef string, CFIndex index ) = CFStringRef/*  StringByAppendingFormat( string, format, ... )*/toolbox fn StringByAppendingFormat( CFStringRef string, CFStringRef format, ... ) = CFStringRef/*  StringByAppendingString( string1, string2 )*/toolbox fn StringByAppendingString( CFStringRef string1, CFStringRef string2 ) = CFStringRef/*  StringByPaddingToLength( string, newLength, padString, padIndex )  Returns a new string formed from the receiver by either removing characters from the end, or by appending as many occurrences as necessary of a given pad string.  Params:    newLength - The new length of the receiver.    padString - The string with which to extend the receiver.    padIndex  - The index in padString from which to start padding.*/toolbox fn StringByPaddingToLength( CFStringRef string, UInt32 newLength, CFStringRef padString, UInt32 padIndex ) = CFStringRef/*  StringContainsString( string1, string2 )*/toolbox fn StringContainsString( CFStringRef string1, CFStringRef string2 ) = Boolean/*  StringPropertyList( string )  Parses the receiver as a text representation of a property list, returning a CFStringRef, CFDataRef, CFArrayRef, or CFDictionaryRef, according to the topmost element.  The receiver must contain a string in a property list format. For a discussion of property list formats, see "Property List Programming Guide" in Apple documentation.*/toolbox fn StringPropertyList( CFStringRef string ) = CFTypeRef